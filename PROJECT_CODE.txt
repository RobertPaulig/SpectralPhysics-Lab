================================================================================
–ü–†–û–ï–ö–¢: SpectralPhysics-Lab
–î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∞—Ä—Ö–∏–≤–∞: 2025-12-01 00:25:52
================================================================================

–°–¢–†–£–ö–¢–£–†–ê –ü–†–û–ï–ö–¢–ê:
--------------------------------------------------------------------------------
SpectralPhysics-Lab
‚îú‚îÄ‚îÄ configs
‚îÇ   ‚îú‚îÄ‚îÄ pump_score.yaml
‚îÇ   ‚îú‚îÄ‚îÄ pump_thresholds.yaml
‚îÇ   ‚îî‚îÄ‚îÄ pump_train.yaml
‚îú‚îÄ‚îÄ data
‚îÇ   ‚îî‚îÄ‚îÄ pump
‚îÇ       ‚îú‚îÄ‚îÄ current_motor.csv
‚îÇ       ‚îú‚îÄ‚îÄ current_pump.csv
‚îÇ       ‚îú‚îÄ‚îÄ profile.npz
‚îÇ       ‚îú‚îÄ‚îÄ report.md
‚îÇ       ‚îú‚îÄ‚îÄ train_motor_1.csv
‚îÇ       ‚îú‚îÄ‚îÄ train_motor_2.csv
‚îÇ       ‚îú‚îÄ‚îÄ train_pump_1.csv
‚îÇ       ‚îî‚îÄ‚îÄ train_pump_2.csv
‚îú‚îÄ‚îÄ examples
‚îÇ   ‚îú‚îÄ‚îÄ atomic_valence_demo.py
‚îÇ   ‚îú‚îÄ‚îÄ atomic_valence_table_demo.py
‚îÇ   ‚îú‚îÄ‚îÄ generate_synthetic_pump_data.py
‚îÇ   ‚îú‚îÄ‚îÄ geophysics_1d_demo.py
‚îÇ   ‚îú‚îÄ‚îÄ geophysics_2d_health_demo.py
‚îÇ   ‚îú‚îÄ‚îÄ geophysics_2d_toy_demo.py
‚îÇ   ‚îú‚îÄ‚îÄ geophysics_health_demo.py
‚îÇ   ‚îú‚îÄ‚îÄ health_monitor_demo.py
‚îÇ   ‚îú‚îÄ‚îÄ material_defect_demo.py
‚îÇ   ‚îú‚îÄ‚îÄ material_health_demo.py
‚îÇ   ‚îú‚îÄ‚îÄ material_spectrum_guess_demo.py
‚îÇ   ‚îú‚îÄ‚îÄ medium_2d_modes_demo.py
‚îÇ   ‚îî‚îÄ‚îÄ ndt_synthetic_defect_demo.py
‚îú‚îÄ‚îÄ src
‚îÇ   ‚îú‚îÄ‚îÄ spectral_physics
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ atoms.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cli.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ diagnostics.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ geophysics_1d.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ geophysics_2d.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ grav_toy.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ io.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ldos.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ material.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ materials.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ medium_1d.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ medium_2d.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ndt.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ report.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ root_finding.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ spectrum.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ timeseries.py
‚îÇ   ‚îî‚îÄ‚îÄ spectral_physics_lab.egg-info
‚îÇ       ‚îú‚îÄ‚îÄ PKG-INFO
‚îÇ       ‚îú‚îÄ‚îÄ SOURCES.txt
‚îÇ       ‚îú‚îÄ‚îÄ dependency_links.txt
‚îÇ       ‚îú‚îÄ‚îÄ entry_points.txt
‚îÇ       ‚îú‚îÄ‚îÄ requires.txt
‚îÇ       ‚îî‚îÄ‚îÄ top_level.txt
‚îú‚îÄ‚îÄ tests
‚îÇ   ‚îú‚îÄ‚îÄ test_atoms.py
‚îÇ   ‚îú‚îÄ‚îÄ test_diagnostics.py
‚îÇ   ‚îú‚îÄ‚îÄ test_diagnostics_features.py
‚îÇ   ‚îú‚îÄ‚îÄ test_geophysics_1d.py
‚îÇ   ‚îú‚îÄ‚îÄ test_grav_toy.py
‚îÇ   ‚îú‚îÄ‚îÄ test_io.py
‚îÇ   ‚îú‚îÄ‚îÄ test_ldos.py
‚îÇ   ‚îú‚îÄ‚îÄ test_material.py
‚îÇ   ‚îú‚îÄ‚îÄ test_material_features.py
‚îÇ   ‚îú‚îÄ‚îÄ test_materials.py
‚îÇ   ‚îú‚îÄ‚îÄ test_medium_1d.py
‚îÇ   ‚îú‚îÄ‚îÄ test_medium_2d.py
‚îÇ   ‚îú‚îÄ‚îÄ test_ndt.py
‚îÇ   ‚îú‚îÄ‚îÄ test_report.py
‚îÇ   ‚îú‚îÄ‚îÄ test_root_finding.py
‚îÇ   ‚îú‚îÄ‚îÄ test_spectrum.py
‚îÇ   ‚îî‚îÄ‚îÄ test_timeseries.py
‚îú‚îÄ‚îÄ AI_TASKS.md
‚îú‚îÄ‚îÄ PROJECT_CODE.txt
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ pyproject.toml

================================================================================
–°–û–î–ï–†–ñ–ò–ú–û–ï –§–ê–ô–õ–û–í
================================================================================


================================================================================
–§–ê–ô–õ: AI_TASKS.md
================================================================================

# –ú–ï–ì–ê-–ü–†–û–ï–ö–¢: spectral-health v1.0

–¶–µ–ª—å: –ø—Ä–µ–≤—Ä–∞—Ç–∏—Ç—å —Ç–µ–∫—É—â–∏–π –∫–æ–¥ –≤ **–ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω—ã–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏ –º–∞—à–∏–Ω**:

- –í—Ö–æ–¥: CSV —Å –≤–∏–±—Ä–∞—Ü–∏–µ–π/—Å–∏–≥–Ω–∞–ª–∞–º–∏.
- –í—ã—Ö–æ–¥: CLI-—É—Ç–∏–ª–∏—Ç–∞ `spectral-health`, –∫–æ—Ç–æ—Ä–∞—è:
  - –æ–±—É—á–∞–µ—Ç "–∑–¥–æ—Ä–æ–≤—ã–π –ø—Ä–æ—Ñ–∏–ª—å" –ø–æ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–º –¥–∞–Ω–Ω—ã–º;
  - –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –Ω–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ;
  - –¥–∞—ë—Ç —Å—Ç–∞—Ç—É—Å –ø–æ –∫–∞–∂–¥–æ–º—É –∫–∞–Ω–∞–ª—É (OK / ANOMALY);
  - –ø–∏—à–µ—Ç –∫—Ä–∞—Å–∏–≤—ã–π Markdown-–æ—Ç—á—ë—Ç.

---

## –≠–¢–ê–ü 20. –î–æ–≤–æ–¥–∏–º —è–¥—Ä–æ –∏ —É–ø–∞–∫–æ–≤–∫—É –¥–æ –±–æ–µ–≤–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è

**–§–∞–π–ª—ã:** `pyproject.toml`, `README.md`, `src/spectral_physics/cli.py`

- [ ] –ò—Å–ø—Ä–∞–≤–∏—Ç—å `pyproject.toml`:
  - –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –±–ª–æ–∫ `[project]` —Å:
    - `name`, `version`, `description`, `readme`, `requires-python`;
    - `dependencies = ["numpy", "scipy", "matplotlib", "pyyaml"]` –∏ —Ç.–ø.
  - —Ä–∞–±–æ—á–∏–π `[project.scripts]`:
    ```toml
    [project.scripts]
    spectral-health = "spectral_physics.cli:main"
    ```

- [ ] –ü–æ–ø—Ä–∞–≤–∏—Ç—å –∏–º–ø–æ—Ä—Ç `HealthProfile` –≤ `cli.py`:
  - –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å `HealthProfile` –∏–∑ `spectral_physics.material`.

- [ ] –ü—Ä–æ—á–∏—Å—Ç–∏—Ç—å `README.md`:
  - —É–±—Ä–∞—Ç—å –¥—É–±–ª–∏—Ä—É—é—â–∏–π—Å—è –∫—É—Å–æ–∫ —Ç–µ–∫—Å—Ç–∞;
  - –¥–æ–±–∞–≤–∏—Ç—å —Ä–∞–∑–¥–µ–ª:
    ```markdown
    ## Installation

    ```bash
    pip install -e .
    spectral-health --help
    ```
    ```

---

## –≠–¢–ê–ü 21. YAML-–∫–æ–Ω—Ñ–∏–≥–∏ –∏ –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–æ–Ω–Ω—ã–π pipeline

**–ù–æ–≤—ã–µ —Ñ–∞–π–ª—ã:**
- `configs/pump_train.yaml`
- `configs/pump_score.yaml`
- `configs/pump_thresholds.yaml`
- `examples/generate_synthetic_pump_data.py`

### 21.1. –ü—Ä–∏–º–µ—Ä –∫–æ–Ω—Ñ–∏–≥–æ–≤

- [ ] –°–æ–∑–¥–∞—Ç—å –ø–∞–ø–∫—É `configs/`.

- [ ] `configs/pump_train.yaml` ‚Äî –ø—Ä–∏–º–µ—Ä –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –¥–ª—è –æ–±—É—á–µ–Ω–∏—è:

  ```yaml
  dt: 0.001          # —à–∞–≥ –¥–∏—Å–∫—Ä–µ—Ç–∏–∑–∞—Ü–∏–∏
  window: hann

  channels:
    motor_vibration:
      column: 1
      freq_min: 0.0
      freq_max: 500.0
      files:
        - data/pump/train_motor_1.csv
        - data/pump/train_motor_2.csv

    pump_vibration:
      column: 2
      freq_min: 0.0
      freq_max: 500.0
      files:
        - data/pump/train_pump_1.csv
        - data/pump/train_pump_2.csv
  ```

- [ ] `configs/pump_score.yaml` ‚Äî –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ, –Ω–æ –¥–ª—è **—Ç–µ–∫—É—â–µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è**:

  ```yaml
  dt: 0.001
  window: hann

  channels:
    motor_vibration:
      column: 1
      freq_min: 0.0
      freq_max: 500.0
      files:
        - data/pump/current_motor.csv

    pump_vibration:
      column: 2
      freq_min: 0.0
      freq_max: 500.0
      files:
        - data/pump/current_pump.csv
  ```

- [ ] `configs/pump_thresholds.yaml` ‚Äî –ø–æ—Ä–æ–≥–∏:

  ```yaml
  motor_vibration: 0.15
  pump_vibration: 0.20
  ```

### 21.2. –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö

**–§–∞–π–ª:** `examples/generate_synthetic_pump_data.py`

- [ ] –ù–∞–ø–∏—Å–∞—Ç—å —Å–∫—Ä–∏–ø—Ç, –∫–æ—Ç–æ—Ä—ã–π:

  * —Å–æ–∑–¥–∞—ë—Ç –ø–∞–ø–∫—É `data/pump/`;
  * –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ—á–Ω—ã–µ CSV:

    * `train_motor_1.csv`, `train_motor_2.csv`;
    * `train_pump_1.csv`, `train_pump_2.csv`;
  * –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç "—Ç–µ–∫—É—â–∏–µ" CSV:

    * `current_motor.csv` (–Ω–æ—Ä–º–∞–ª—å–Ω—ã–π);
    * `current_pump.csv` (—Å –∞–Ω–æ–º–∞–ª–∏–µ–π: –¥–æ–±–∞–≤–ª–µ–Ω –Ω–æ–≤—ã–π –ø–∏–∫, —à—É–º –∏–ª–∏ –¥—Ä–µ–π—Ñ).

- [ ] –§–æ—Ä–º–∞—Ç CSV:

  ```text
  time, motor_vibration, pump_vibration
  0.000, ...
  0.001, ...
  ...
  ```

  * –ø–µ—Ä–≤–∞—è —Å—Ç—Ä–æ–∫–∞ ‚Äî –∑–∞–≥–æ–ª–æ–≤–æ–∫;
  * —Å—Ç–æ–ª–±–µ—Ü 1 ‚Äî –≤—Ä–µ–º—è, —Å—Ç–æ–ª–±–µ—Ü 2 ‚Äî –º–æ—Ç–æ—Ä, —Å—Ç–æ–ª–±–µ—Ü 3 ‚Äî –Ω–∞—Å–æ—Å.

- [ ] –í–Ω—É—Ç—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å `numpy` –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å–∏–≥–Ω–∞–ª–æ–≤:

  * Healthy: —Å—É–º–º–∞ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Å–∏–Ω—É—Å–æ–≤ + –Ω–µ–º–Ω–æ–≥–æ —à—É–º–∞;
  * Anomaly: —É—Å–∏–ª–µ–Ω–Ω—ã–π –æ–¥–∏–Ω –∏–∑ –ø–∏–∫–æ–≤ + –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π —à—É–º.

---

## –≠–¢–ê–ü 22. –£–º–Ω—ã–π health-–ø—Ä–æ—Ñ–∏–ª—å —Å —Ñ–∏—á–∞–º–∏ (band-power + —ç–Ω—Ç—Ä–æ–ø–∏—è)

–°–µ–π—á–∞—Å `MaterialSignature.distance_l2` —Å—Ä–∞–≤–Ω–∏–≤–∞–µ—Ç **–Ω–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å–ø–µ–∫—Ç—Ä—ã —Ü–µ–ª–∏–∫–æ–º** 

–•–æ—á–µ—Ç—Å—è –¥–æ–±–∞–≤–∏—Ç—å –µ—â—ë –æ–¥–∏–Ω —É—Ä–æ–≤–µ–Ω—å: —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø–æ –Ω–∞–±–æ—Ä—É —Ñ–∏—á.

**–§–∞–π–ª—ã:** `src/spectral_physics/material.py`, `src/spectral_physics/diagnostics.py`, `tests/test_material.py`, `tests/test_diagnostics.py`

### 22.1. –í–µ–∫—Ç–æ—Ä —Ñ–∏—á –ø–æ —Å–ø–µ–∫—Ç—Ä—É

- [ ] –î–æ–±–∞–≤–∏—Ç—å –≤ `diagnostics.py` —Ñ—É–Ω–∫—Ü–∏—é:

  ```python
  import numpy as np
  from .spectrum import Spectrum1D
  from .diagnostics import spectral_band_power, spectral_entropy

  def extract_features(
      spectrum: Spectrum1D,
      bands_hz: list[tuple[float, float]],
  ) -> np.ndarray:
      """
      –ü–æ—Å—Ç—Ä–æ–∏—Ç—å –≤–µ–∫—Ç–æ—Ä —Ñ–∏—á:
      [ band_power_1, ..., band_power_N, spectral_entropy ]
      """
      features = []
      for fmin, fmax in bands_hz:
          features.append(spectral_band_power(spectrum, fmin, fmax))
      features.append(spectral_entropy(spectrum))
      return np.asarray(features, dtype=float)
  ```

- [ ] –î–æ–±–∞–≤–∏—Ç—å —Ç–µ—Å—Ç –≤ `tests/test_diagnostics.py`:

  * —Å–æ–∑–¥–∞—Ç—å –ø—Ä–æ—Å—Ç–æ–π —Å–ø–µ–∫—Ç—Ä —Å –¥–≤—É–º—è —á–∞—Å—Ç–æ—Ç–∞–º–∏;
  * –ø—Ä–æ–≤–µ—Ä–∏—Ç—å, —á—Ç–æ `extract_features` –¥–∞—ë—Ç –æ–∂–∏–¥–∞–µ–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è band power;
  * –ø—Ä–æ–≤–µ—Ä–∏—Ç—å, —á—Ç–æ —Ä–∞–∑–º–µ—Ä–Ω–æ—Å—Ç—å –≤–µ–∫—Ç–æ—Ä–∞ = `len(bands) + 1`.

### 22.2. –§–∏—á–µ–≤–∞—è —Å–∏–≥–Ω–∞—Ç—É—Ä–∞ –º–∞—Ç–µ—Ä–∏–∞–ª–∞

- [ ] –í `material.py` –¥–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—ã–π dataclass:

  ```python
  @dataclass
  class FeatureSignature:
      """
      –°–ø–µ–∫—Ç—Ä–∞–ª—å–Ω–∞—è —Å–∏–≥–Ω–∞—Ç—É—Ä–∞ –Ω–∞ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ —Ñ–∏—á.
      """
      reference_features: np.ndarray

      def distance_l2(self, other_features: np.ndarray) -> float:
          if other_features.shape != self.reference_features.shape:
              raise ValueError("Feature vector shape mismatch")
          diff = self.reference_features - other_features
          return float(np.sqrt(np.sum(diff**2)))
  ```

- [ ] –î–æ–±–∞–≤–∏—Ç—å —Ç–µ—Å—Ç—ã –≤ `tests/test_material.py`:

  * `test_feature_signature_zero_distance_for_identical`;
  * `test_feature_signature_shape_mismatch_raises`.

### 22.3. HealthProfile —Å –¥–≤—É–º—è —É—Ä–æ–≤–Ω—è–º–∏

- [ ] –û–±–Ω–æ–≤–∏—Ç—å `HealthProfile` —Ç–∞–∫, —á—Ç–æ–±—ã –æ–Ω –º–æ–≥ —Ö—Ä–∞–Ω–∏—Ç—å **–æ–±–∞ —Ç–∏–ø–∞** —Å–∏–≥–Ω–∞—Ç—É—Ä:

  ```python
  @dataclass
  class HealthProfile:
      signatures: dict[str, MaterialSignature]
      feature_signatures: dict[str, FeatureSignature] | None = None
  ```

- [ ] –î–æ–±–∞–≤–∏—Ç—å –º–µ—Ç–æ–¥:

  ```python
  def score_features(
      self,
      current: dict[str, Spectrum1D],
      bands_hz: dict[str, list[tuple[float, float]]],
  ) -> dict[str, float]:
      """
      –î–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–∞–Ω–∞–ª–∞:
      - –∏–∑–≤–ª–µ—á—å —Ñ–∏—á–∏,
      - –ø–æ—Å—á–∏—Ç–∞—Ç—å L2-–¥–∏—Å—Ç–∞–Ω—Ü–∏—é –≤ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ —Ñ–∏—á.
      """
  ```

- [ ] –î–æ–±–∞–≤–∏—Ç—å —Ç–µ—Å—Ç –≤ `tests/test_material.py`, –∫–æ—Ç–æ—Ä—ã–π:

  * —Å—Ç—Ä–æ–∏—Ç –ø—Ä–æ—Å—Ç—ã–µ —Å–ø–µ–∫—Ç—Ä—ã;
  * —Å–æ–∑–¥–∞—ë—Ç `FeatureSignature`;
  * –ø—Ä–æ–≤–µ—Ä—è–µ—Ç, —á—Ç–æ `score_features` –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Å–ª–æ–≤–∞—Ä—å.

---

## –≠–¢–ê–ü 23. –ü–æ–ª–Ω—ã–π –¥–µ–º–æ-–∫–µ–π—Å: –æ—Ç –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö –¥–æ –æ—Ç—á—ë—Ç–∞

**–¶–µ–ª—å:** –û–¥–∏–Ω —Å—Ü–µ–Ω–∞—Ä–∏–π, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–Ω–æ –æ–ø–∏—Å–∞—Ç—å –≤ README: *¬´–∑–∞–ø—É—Å—Ç–∏ —ç—Ç–∏ –∫–æ–º–∞–Ω–¥—ã ‚Äî –∏ –ø–æ–ª—É—á–∏—à—å –æ—Ç—á—ë—Ç –æ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–≥–æ –Ω–∞—Å–æ—Å–∞¬ª.*

**–§–∞–π–ª—ã:** `README.md`, `examples/health_monitor_demo.ipynb`, –≤–æ–∑–º–æ–∂–Ω–æ –Ω–æ–≤—ã–π `examples/pump_health_demo.ipynb`.

- [ ] –û–±–Ω–æ–≤–∏—Ç—å –∏–ª–∏ —Å–æ–∑–¥–∞—Ç—å –Ω–æ—É—Ç–±—É–∫ `examples/health_monitor_demo.ipynb` —Ç–∞–∫, —á—Ç–æ–±—ã –æ–Ω –¥–µ–ª–∞–ª:

  1. `!python examples/generate_synthetic_pump_data.py`
  2. `!spectral-health train --config configs/pump_train.yaml --out data/pump/profile.npz`
  3. `!spectral-health score --config configs/pump_score.yaml --profile data/pump/profile.npz --thresholds configs/pump_thresholds.yaml --report data/pump/report.md`
  4. –í –∫–æ–Ω—Ü–µ –Ω–æ—É—Ç–±—É–∫–∞ –æ—Ç–∫—Ä—ã—Ç—å –∏ –ø–æ–∫–∞–∑–∞—Ç—å `report.md`.

- [ ] –î–æ–ø–æ–ª–Ω–∏—Ç—å `README.md` —Ä–∞–∑–¥–µ–ª–æ–º **"Quick start: Pump demo"**:

  ```markdown
  ## Quick start: Pump health demo

  ```bash
  pip install -e .

  # 1. –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ
  python examples/generate_synthetic_pump_data.py

  # 2. –û–±—É—á–∏—Ç—å –ø—Ä–æ—Ñ–∏–ª—å "–∑–¥–æ—Ä–æ–≤–æ–≥–æ" —Å–æ—Å—Ç–æ—è–Ω–∏—è
  spectral-health train \
    --config configs/pump_train.yaml \
    --out data/pump/profile.npz

  # 3. –û—Ü–µ–Ω–∏—Ç—å —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏ –ø–æ–ª—É—á–∏—Ç—å –æ—Ç—á—ë—Ç
  spectral-health score \
    --config configs/pump_score.yaml \
    --profile data/pump/profile.npz \
    --thresholds configs/pump_thresholds.yaml \
    --report data/pump/report.md
  ```
  ```

- [ ] –£–±–µ–¥–∏—Ç—å—Å—è, —á—Ç–æ –≤ –æ—Ç—á—ë—Ç–µ –µ—Å—Ç—å –∫–∞–∫ –º–∏–Ω–∏–º—É–º:

  * —Ç–∞–±–ª–∏—Ü–∞ —Å –∫–∞–Ω–∞–ª–∞–º–∏, distance, threshold, —Å—Ç–∞—Ç—É—Å–æ–º (—É–∂–µ –¥–µ–ª–∞–µ—Ç `generate_markdown_report`) 
  * –ø–æ–Ω—è—Ç–Ω—ã–π —Ç–µ–∫—Å—Ç: "All systems nominal" –∏–ª–∏ "Anomalies detected!"

---

## üß± –ú–ï–ì–ê-–ë–õ–û–ö 3 ‚Äî Spectral NDT Kit v1.0 (–¥–µ—Ñ–µ–∫—Ç—ã –≤ –º–∞—Ç–µ—Ä–∏–∞–ª–∞—Ö)

**–¶–µ–ª—å:** –ø—Ä–µ–≤—Ä–∞—Ç–∏—Ç—å –ø—Ä–∏–º–µ—Ä `material_health_demo` + LDOS –≤ –Ω–∞—Å—Ç–æ—è—â–∏–π –∫–æ–º–ø–ª–µ–∫—Ç –¥–ª—è –ù–ö (–Ω–µ—Ä–∞–∑—Ä—É—à–∞—é—â–∏–π –∫–æ–Ω—Ç—Ä–æ–ª—å):
–≤—Ö–æ–¥ ‚Äî –∫–∞—Ä—Ç–∞ –∏–∑–º–µ—Ä–µ–Ω–∏–π (–∏–ª–∏ —Å—ã—Ä—ã–µ –∫–æ–ª–µ–±–∞–Ω–∏—è –Ω–∞ —Å–µ—Ç–∫–µ), –≤—ã—Ö–æ–¥ ‚Äî –∫–∞—Ä—Ç–∞ –¥–µ—Ñ–µ–∫—Ç–æ–≤ + –æ—Ç—á—ë—Ç.

### 3.1. –Ø–¥—Ä–æ NDT

**–§–∞–π–ª:** `src/spectral_physics/ndt.py`

- [ ] –°–¥–µ–ª–∞—Ç—å –∫–ª–∞—Å—Å `NDTProfile`:

  ```python
  @dataclass
  class NDTProfile:
      freq_window: tuple[float, float]
      ldos_mean: np.ndarray   # —É—Å—Ä–µ–¥–Ω—ë–Ω–Ω–∞—è –ø–æ –≤—Ä–µ–º–µ–Ω–∏/–æ–±—Ä–∞–∑—Ü–∞–º LDOS
      ldos_std: np.ndarray    # –≤–∞—Ä–∏–∞–±–µ–ª—å–Ω–æ—Å—Ç—å (–¥–ª—è –Ω–æ—Ä–º–∏—Ä–æ–≤–∫–∏)
  ```

- [ ] –§—É–Ω–∫—Ü–∏—è `build_ndt_profile(grid: OscillatorGrid2D, n_modes: int, freq_window) -> NDTProfile`
  –ò—Å–ø–æ–ª—å–∑—É–µ—Ç `grid.ldos_map(...)`, —É—Å—Ä–µ–¥–Ω—è–µ—Ç –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–π (—à—É–º, —Ä–∞–∑–Ω—ã–µ –≤–æ–∑–±—É–∂–¥–µ–Ω–∏—è).

- [ ] –§—É–Ω–∫—Ü–∏—è `score_ndt_state(profile: NDTProfile, ldos_current: np.ndarray) -> np.ndarray`
  –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç **–∫–∞—Ä—Ç—É –¥–∏—Å—Ç–∞–Ω—Ü–∏–π/–∞–Ω–æ–º–∞–ª–∏–π** (–Ω–∞–ø—Ä–∏–º–µ—Ä, –Ω–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω–∞—è L2 –∏–ª–∏ Mahalanobis –ø–æ –∫–∞–∂–¥–æ–º—É –ø–∏–∫—Å–µ–ª—é).

- [ ] –§—É–Ω–∫—Ü–∏—è `ndt_defect_mask(scores, threshold)` ‚Üí –±—É–ª–µ–≤–∞ –º–∞—Å–∫–∞ –¥–µ—Ñ–µ–∫—Ç–Ω—ã—Ö –∑–æ–Ω.

### 3.2. –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å spectral-health

**–§–∞–π–ª—ã:** `src/spectral_physics/cli.py`, `src/spectral_physics/materials.py`, `src/spectral_physics/io.py`

- [ ] –ü–æ–¥–∫–æ–º–∞–Ω–¥–∞ CLI:
  `spectral-health ndt-train --grid-config cfg.yaml --profile-out path.npz`
  –°—Ü–µ–Ω–∞—Ä–∏–π:

  * –∑–∞–≥—Ä—É–∂–∞–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Å–µ—Ç–∫–∏ (nx, ny, kx, ky, m, –¥–µ—Ñ–æ–ª—Ç–Ω—É—é mass_map);
  * —Å—Ç—Ä–æ–∏—Ç `OscillatorGrid2D`;
  * –≤—ã–∑—ã–≤–∞–µ—Ç `build_ndt_profile`;
  * —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –ø—Ä–æ—Ñ–∏–ª—å.

- [ ] –ü–æ–¥–∫–æ–º–∞–Ω–¥–∞ CLI:
  `spectral-health ndt-score --grid-config cfg.yaml --profile path.npz --data data.npy --report report.md`
  –ì–¥–µ `data.npy` ‚Äî –ª–∏–±–æ —É–∂–µ –ø–æ—Å—á–∏—Ç–∞–Ω–Ω–∞—è LDOS-–∫–∞—Ä—Ç–∞, –ª–∏–±–æ —Å—ã—Ä—ã–µ –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ä—è–¥—ã –Ω–∞ —É–∑–ª–∞—Ö (–µ—Å–ª–∏ —Å—ã—Ä—ã–µ ‚Äî –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å `timeseries`/`ldos` –¥–ª—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è).

- [ ] –í `report.py` –¥–æ–±–∞–≤–∏—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é –æ—Ç—á—ë—Ç–∞ –¥–ª—è NDT:

  * –∫–∞—Ä—Ç–∏–Ω–∫–∞: –∫–∞—Ä—Ç–∞ –∑–¥–æ—Ä–æ–≤–æ–≥–æ LDOS, —Ç–µ–∫—É—â–µ–≥–æ LDOS, –∫–∞—Ä—Ç–∞ –¥–µ—Ñ–µ–∫—Ç–æ–≤;
  * —Å–ø–∏—Å–æ–∫ ¬´–ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω—ã—Ö –æ–±–ª–∞—Å—Ç–µ–π¬ª (–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã + –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π score).

### 3.3. –î–µ–º–∫–∏

**–§–∞–π–ª—ã –≤ `examples/`:**

- [ ] `ndt_synthetic_defect_demo.py`

  * –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç ¬´—á–∏—Å—Ç—É—é¬ª —Å–µ—Ç–∫—É –∏ —Å–µ—Ç–∫—É —Å –¥–µ—Ñ–µ–∫—Ç–æ–º (–∫–∞–∫ –≤ `material_health_demo`, –Ω–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –Ω–æ–≤—ã–π `ndt.py`);
  * —Å—Ç—Ä–æ–∏—Ç –ø—Ä–æ—Ñ–∏–ª—å, —Å–∫–∞–Ω–∏—Ä—É–µ—Ç –¥–µ—Ñ–µ–∫—Ç–Ω—É—é, —Ä–∏—Å—É–µ—Ç 3 –∫–∞—Ä—Ç–∏–Ω–∫–∏:

    * LDOS clean,
    * LDOS defect,
    * anomaly map (scores / mask).

- [ ] `ndt_cli_demo.sh` –∏–ª–∏ `.md`
  –ú–∏–Ω–∏-—Å—Ü–µ–Ω–∞—Ä–∏–π –∏–∑ –∫–æ–º–∞–Ω–¥:

  * `spectral-health ndt-train ...`
  * `spectral-health ndt-score ...`
  * –≥–¥–µ –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –æ—Ç—á—ë—Ç.

---

## üåç –ú–ï–ì–ê-–ë–õ–û–ö 4 ‚Äî GeoSpectra 2D: –∑–µ–º–ª—è, —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç—ã, –±–æ–ª—å—à–∏–µ –¥–µ–Ω—å–≥–∏

**–¶–µ–ª—å:** —Ä–∞—Å—à–∏—Ä–∏—Ç—å 1D –≥–µ–æ—Ñ–∏–∑–∏–∫—É –¥–æ 2D, —á—Ç–æ–±—ã –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –∑–∞–∫–∞–∑—á–∏–∫—É:
¬´–í–æ—Ç –∫–∞—Ä—Ç–∞ –∂—ë—Å—Ç–∫–æ—Å—Ç–∏/–ø–æ–ª–æ—Å—Ç–µ–π –ø–æ–¥ –≤–∞—à–∏–º –æ–±—ä–µ–∫—Ç–æ–º. –í–æ—Ç –≥–¥–µ —É –≤–∞—Å –¥–µ–Ω—å–≥–∏ –≤ –∑–µ–º–ª–µ –ª–µ–∂–∞—Ç –∏–ª–∏ –¥–æ–º —Ç—Ä–µ—Å–Ω–µ—Ç¬ª.

### 4.1. 2D –≥–µ–æ—Ñ–∏–∑–∏—á–µ—Å–∫–∞—è —Å—Ä–µ–¥–∞

**–§–∞–π–ª:** `src/spectral_physics/geophysics_2d.py`

- [ ] –ö–ª–∞—Å—Å `GeoGrid2D` (–æ–±—ë—Ä—Ç–∫–∞ –Ω–∞–¥ `OscillatorGrid2D`):

  * –ø–æ–ª—è: `nx, ny, depth_scale, stiffness_map, density_map`;
  * –º–µ—Ç–æ–¥—ã:

    * `forward_response(source_pattern, freq_window) -> np.ndarray`
      –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–µ–∫—Ç—Ä—ã/LDOS –Ω–∞ ¬´–ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–Ω—ã—Ö¬ª —Ç–æ—á–∫–∞—Ö (–≤–µ—Ä—Ö–Ω—è—è —Å—Ç—Ä–æ–∫–∞ —É–∑–ª–æ–≤).

- [ ] –§—É–Ω–∫—Ü–∏—è `invert_stiffness(ldos_surface, prior_model, regularization)`
  –û—á–µ–Ω—å –≥—Ä—É–±–∞—è –∏–Ω–≤–µ—Ä—Å–∏—è:

  * –Ω–∞—á–∞–ª—å–Ω–∞—è –º–æ–¥–µ–ª—å ‚Äî –æ–¥–Ω–æ—Ä–æ–¥–Ω–∞—è –∂—ë—Å—Ç–∫–æ—Å—Ç—å;
  * —Ü–µ–ª—å ‚Äî –ø–æ–¥–æ–±—Ä–∞—Ç—å `kx, ky`/`stiffness_map`, —á—Ç–æ–±—ã —Ä–∞—Å—Å—á–∏—Ç–∞–Ω–Ω—ã–π LDOS –Ω–∞ –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏ –±—ã–ª –±–ª–∏–∂–µ –∫ –Ω–∞–±–ª—é–¥–∞–µ–º–æ–º—É;
  * –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å `symmetric_newton` / –ø—Ä–æ—Å—Ç—ã–µ –≥—Ä–∞–¥–∏–µ–Ω—Ç-free —à–∞–≥–∏.

### 4.2. Geo-CLI

**–§–∞–π–ª:** `src/spectral_physics/cli.py`

- [ ] –ü–æ–¥–∫–æ–º–∞–Ω–¥–∞ `spectral-health geo2d-train`

  * –≤—Ö–æ–¥: `geo_train.yaml` (–≥–µ–æ–º–µ—Ç—Ä–∏—è, –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º–∞—è —Å–ª–æ–∏—Å—Ç–æ—Å—Ç—å, –¥–∞–Ω–Ω—ã–µ –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–Ω—ã—Ö –¥–∞—Ç—á–∏–∫–æ–≤);
  * –≤—ã—Ö–æ–¥: ¬´–∑–¥–æ—Ä–æ–≤—ã–π¬ª –ø—Ä–æ—Ñ–∏–ª—å –≥—Ä—É–Ω—Ç–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, `stiffness_profile.npz`).

- [ ] –ü–æ–¥–∫–æ–º–∞–Ω–¥–∞ `spectral-health geo2d-scan`

  * –≤—Ö–æ–¥: –Ω–æ–≤—ã–µ –∏–∑–º–µ—Ä–µ–Ω–∏—è —Å –¥–∞—Ç—á–∏–∫–æ–≤ (CSV/NPY);
  * –≤—ã—Ö–æ–¥: –∫–∞—Ä—Ç–∞ –∞–Ω–æ–º–∞–ª–∏–π –ø–æ –ø–ª–æ—â–∞–¥–∏ (heatmap –∂—ë—Å—Ç–∫–æ—Å—Ç–∏/–¥–µ—Ñ–µ–∫—Ç–æ–≤) + –æ—Ç—á—ë—Ç.

### 4.3. –ì–µ–æ-–¥–µ–º–∫–∏

**–§–∞–π–ª—ã –≤ `examples/`:**

- [ ] `geophysics_2d_toy_demo.py`

  * —Å–∏–Ω—Ç–µ—Ç–∏–∫–∞: –≤–µ—Ä—Ö–Ω–∏–π —Å–ª–æ–π –º—è–≥–∫–∏–π, –≤–Ω–∏–∑—É ¬´–∫–∞–º–µ–Ω—å¬ª, –ø–ª—é—Å –ø–æ–ª–æ—Å—Ç—å;
  * —Å—á–∏—Ç–∞–µ—à—å –æ—Ç–∫–ª–∏–∫ –Ω–∞ —Å–µ—Ä–∏–∏ —É–¥–∞—Ä–æ–≤;
  * –ø—Ä–æ–±—É–µ—à—å –∏–Ω–≤–µ—Ä—Å–∏—é ‚Üí –ø–æ–∫–∞–∑—ã–≤–∞–µ—à—å —Ä–µ–∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏—é –∫–∞—Ä—Ç—ã –∂—ë—Å—Ç–∫–æ—Å—Ç–∏.

- [ ] `geophysics_2d_health_demo.py`

  * –ø–æ–∫–∞–∑—ã–≤–∞–µ—à—å –¥–≤–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è: ¬´–Ω–æ—Ä–º–∞–ª—å–Ω—ã–π —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç¬ª –∏ ¬´–ø–æ–¥–º—ã–ª–æ –≥—Ä—É–Ω—Ç¬ª;
  * —Ä–∏—Å—É–µ—à—å —Ä–∞–∑–Ω–∏—Ü—É.

---

## üß™ –ú–ï–ì–ê-–ë–õ–û–ö 5 ‚Äî –ê—Ç–æ–º—ã ‚Üí –ú–∞—Ç–µ—Ä–∏–∞–ª—ã ‚Üí –ú–∞–∫—Ä–æ–º–∏—Ä

**–¶–µ–ª—å:** —Å–≤—è–∑–∞—Ç—å `atoms.py`, `materials.py`, `OscillatorGrid2D` –∏ NDT –≤ –æ–¥–Ω—É –ª–∏–Ω–∏—é:
–æ—Ç **—Ç–∞–±–ª–∏—Ü—ã –≤–∞–ª–µ–Ω—Ç–Ω–æ—Å—Ç–µ–π** –¥–æ **–æ–∂–∏–¥–∞–µ–º–æ–≥–æ —Å–ø–µ–∫—Ç—Ä–∞ –∏ –ø—Ä–æ—á–Ω–æ—Å—Ç–∏ –º–∞—Ç–µ—Ä–∏–∞–ª–∞**.

### 5.1. –ö–∞—Ç–∞–ª–æ–≥ –∞—Ç–æ–º–æ–≤ –∏ —Å–≤—è–∑–µ–π

**–§–∞–π–ª:** `src/spectral_physics/atoms.py`

- [ ] –î–æ–±–∞–≤–∏—Ç—å –∫–ª–∞—Å—Å/—Å—Ç—Ä—É–∫—Ç—É—Ä—É `AtomicResonator` (—Ä–∞—Å—à–∏—Ä–∏—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π):

  * –∫–ª—é—á–∏: `Z, name, core_modes (freq ranges), valence_modes (freq ranges)`.

- [ ] –§—É–Ω–∫—Ü–∏—è `load_default_atom_db()` ‚Üí —Å–ª–æ–≤–∞—Ä—å –ø–æ —Å–∏–º–≤–æ–ª—É (`"H"`, `"O"`, `"C"`, `"Fe"`...) —Å –ø—Ä–∏–º–µ—Ä–Ω—ã–º–∏ –¥–∏–∞–ø–∞–∑–æ–Ω–∞–º–∏ —á–∞—Å—Ç–æ—Ç (–º–æ–∂–Ω–æ –ø—Ä–æ—Å—Ç–æ ¬´–∏–≥—Ä—É—à–µ—á–Ω—ã–µ¬ª —á–∏—Å–ª–∞, –Ω–æ —Ñ–∏–∑–∏—á–µ—Å–∫–∏ —É–ø–æ—Ä—è–¥–æ—á–µ–Ω–Ω—ã–µ).

### 5.2. –ú–æ–ª–µ–∫—É–ª—ã –∏ –º–∞—Ç–µ—Ä–∏–∞–ª—ã

**–§–∞–π–ª:** `src/spectral_physics/materials.py`

- [ ] –ö–ª–∞—Å—Å `MoleculeGraph`:

  * –≤–µ—Ä—à–∏–Ω—ã ‚Äî –∞—Ç–æ–º—ã (`AtomicResonator`),
  * —Ä—ë–±—Ä–∞ ‚Äî —Å–≤—è–∑–∏ —Å —Ç–∏–ø–æ–º (`single`, `double`, `ionic`),
  * –º–µ—Ç–æ–¥ `combined_valence_spectrum()` ‚Äî –¥–∞—ë—Ç —Å–ø–µ–∫—Ç—Ä–∞–ª—å–Ω—É—é –ø–æ–¥–ø–∏—Å—å –º–æ–ª–µ–∫—É–ª—ã.

- [ ] –ö–ª–∞—Å—Å `MaterialSignature` —É–∂–µ –µ—Å—Ç—å ‚Äî —Ä–∞—Å—à–∏—Ä–∏—Ç—å:

  * –¥–æ–±–∞–≤–∏—Ç—å –ø–æ–ª–µ `chemical_hint` (—Å–ø–∏—Å–æ–∫ –≤–µ—Ä–æ—è—Ç–Ω—ã—Ö –±–∞–∑–æ–≤—ã—Ö –º–æ–ª–µ–∫—É–ª/–∞—Ç–æ–º–æ–≤);
  * –º–µ—Ç–æ–¥ `from_molecule(molecule: MoleculeGraph, ...)`.

- [ ] –ú—ç–ø–ø–∏–Ω–≥ `material_spectrum -> effective_medium_params`:

  * –ø–ª–æ—Ç–Ω–æ—Å—Ç—å,
  * —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–∞—è –∂—ë—Å—Ç–∫–æ—Å—Ç—å,
  * –≤–∞–ª–µ–Ω—Ç–Ω–æ—Å—Ç—å (–∫–∞–∫ —Å—É–º–º–∞—Ä–Ω–æ–µ –ø–µ—Ä–µ–∫—Ä—ã—Ç–∏–µ –≤–∞–ª–µ–Ω—Ç–Ω—ã—Ö –º–æ–¥).

### 5.3. –°–≤—è–∑—å —Å NDT –∏ LDOS

**–§–∞–π–ª:** `src/spectral_physics/material.py` / `ndt.py`

- [ ] –§—É–Ω–∫—Ü–∏—è `infer_material_from_ldos(ldos_map, atom_db) -> list[CandidateMaterial]`
  –í–µ—Ä–Ω—É—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ ¬´–∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤¬ª —Å –æ—Ü–µ–Ω–∫–æ–π –ø–æ—Ö–æ–∂–µ—Å—Ç–∏ –ø–æ —Å–ø–µ–∫—Ç—Ä—É.

- [ ] –ö–ª–∞—Å—Å `CandidateMaterial` (name, confidence, predicted_properties).

### 5.4. –î–µ–º–∫–∏ –ø–æ —Ö–∏–º–∏–∏

**–§–∞–π–ª—ã –≤ `examples/`:**

- [ ] `atomic_valence_table_demo.py`

  * —Å—Ç—Ä–æ–∏—à—å ¬´—Ç–∞–±–ª–∏—Ü—É¬ª (–Ω–µ –ø–æ–ª–Ω—É—é –ú–µ–Ω–¥–µ–ª–µ–µ–≤–∞, –∞ 5‚Äì10 —ç–ª–µ–º–µ–Ω—Ç–æ–≤);
  * –ø–æ–∫–∞–∑—ã–≤–∞–µ—à—å –∏—Ö –≤–∞–ª–µ–Ω—Ç–Ω—ã–µ —Å–ø–µ–∫—Ç—Ä—ã, —Ä—è–¥–æ–º ‚Äî –∫–ª–∞—Å—Å–∏—á–µ—Å–∫—É—é –≤–∞–ª–µ–Ω—Ç–Ω–æ—Å—Ç—å.

- [ ] `material_spectrum_guess_demo.py`

  * –±–µ—Ä—ë—à—å —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–∏–π LDOS –¥–ª—è ¬´—Å—Ç–∞–ª–∏¬ª, ¬´–≤–æ–¥—ã¬ª, ¬´–±–µ—Ç–æ–Ω–∞¬ª (—á–µ—Ä–µ–∑ –º–æ–¥–µ–ª—å –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤);
  * –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–µ—à—å/—à—É–º, –∞ –∑–∞—Ç–µ–º –ø—Ä–æ—Å–∏—à—å `infer_material_from_ldos` —É–≥–∞–¥–∞—Ç—å, —á—Ç–æ —ç—Ç–æ.

---

## üéØ –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏

**–†–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã–π –ø–æ—Ä—è–¥–æ–∫:** 3 ‚Üí 4 ‚Üí 5

- **–ë–ª–æ–∫ 3 (NDT)** ‚Äî –≥–æ—Ç–æ–≤—ã–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –¥–µ—Ñ–µ–∫—Ç–æ—Å–∫–æ–ø–∏–∏ —Å CLI
- **–ë–ª–æ–∫ 4 (Geo2D)** ‚Äî –∫–æ–º–º–µ—Ä—á–µ—Å–∫–∞—è —Ü–µ–Ω–Ω–æ—Å—Ç—å –¥–ª—è —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞/–≥–µ–æ–ª–æ–≥–∏–∏
- **–ë–ª–æ–∫ 5 (–ê—Ç–æ–º—ã)** ‚Äî —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω–∞—è —Ç–µ–æ—Ä–∏—è + –Ω–æ–≤–∞—è —Ö–∏–º–∏—è



================================================================================
–§–ê–ô–õ: configs\pump_score.yaml
================================================================================

dt: 0.001
window: hann

channels:
  motor_vibration:
    column: 1
    freq_min: 0.0
    freq_max: 500.0
    files:
      - data/pump/current_motor.csv

  pump_vibration:
    column: 2
    freq_min: 0.0
    freq_max: 500.0
    files:
      - data/pump/current_pump.csv



================================================================================
–§–ê–ô–õ: configs\pump_thresholds.yaml
================================================================================

motor_vibration: 0.15
pump_vibration: 0.20



================================================================================
–§–ê–ô–õ: configs\pump_train.yaml
================================================================================

dt: 0.001          # —à–∞–≥ –¥–∏—Å–∫—Ä–µ—Ç–∏–∑–∞—Ü–∏–∏
window: hann

channels:
  motor_vibration:
    column: 1
    freq_min: 0.0
    freq_max: 500.0
    files:
      - data/pump/train_motor_1.csv
      - data/pump/train_motor_2.csv

  pump_vibration:
    column: 2
    freq_min: 0.0
    freq_max: 500.0
    files:
      - data/pump/train_pump_1.csv
      - data/pump/train_pump_2.csv



================================================================================
–§–ê–ô–õ: data\pump\report.md
================================================================================

# Spectral Health Report

**Date:** 2025-11-30 15:11:37

## Channel Status

| Channel | Distance | Threshold | Status |
|---------|----------|-----------|--------|
| `motor_vibration` | 0.003497 | 0.150000 | üü¢ OK |
| `pump_vibration` | 0.244686 | 0.200000 | üî¥ **ANOMALY** |

> [!WARNING]
> Anomalies detected! Please check the affected channels.


================================================================================
–§–ê–ô–õ: examples\atomic_valence_demo.py
================================================================================

"""
Atomic Valence as Surface Resonances

This demo explores the idea that chemical valence can be modeled as "spectral compatibility" 
between resonators. We use toy models of atoms (H, O, C) defined by their resonance frequencies.
"""

import numpy as np
import matplotlib.pyplot as plt
from spectral_physics.atoms import H, O, C, spectral_overlap, can_form_bond

def plot_atom_spectra(atom1, atom2):
    fig, ax = plt.subplots(figsize=(10, 4))
    
    # Plot lines for Atom 1
    ax.vlines(atom1.omega, 0, atom1.power, colors='blue', label=f'{atom1.name} lines', lw=2)
    
    # Plot lines for Atom 2
    ax.vlines(atom2.omega, 0, atom2.power, colors='red', label=f'{atom2.name} lines', lw=2, linestyle='--')
    
    ax.set_title(f"Spectral Comparison: {atom1.name} vs {atom2.name}")
    ax.set_xlabel("Frequency (arbitrary units)")
    ax.set_ylabel("Intensity")
    ax.legend()
    ax.grid(True, alpha=0.3)
    return fig

def main():
    print("=" * 60)
    print("Atomic Valence as Surface Resonances Demo")
    print("=" * 60)
    
    # 1. Hydrogen vs Oxygen (Water)
    print("\n1. Hydrogen vs Oxygen (Water)")
    print("-" * 40)
    print("Oxygen has multiple lines around 1.0, matching Hydrogen's single line at 1.0.")
    
    fig1 = plot_atom_spectra(H, O)
    
    overlap = spectral_overlap(H, O)
    print(f"Spectral Overlap (H-O): {overlap:.3f}")
    print(f"Can form bond? {can_form_bond(H, O, freq_tol=0.1, threshold=0.1)}")
    print(f"O max bonds: {O.max_bonds} -> Can hold two H atoms (H-O-H)")
    
    plt.show()
    
    # 2. Carbon vs Hydrogen (Methane)
    print("\n2. Carbon vs Hydrogen (Methane)")
    print("-" * 40)
    print("Carbon has a broader spectrum, overlapping well with Hydrogen.")
    
    fig2 = plot_atom_spectra(C, H)
    
    overlap = spectral_overlap(C, H)
    print(f"Spectral Overlap (C-H): {overlap:.3f}")
    print(f"C max bonds: {C.max_bonds} -> Can hold four H atoms (CH4)")
    
    plt.show()
    
    # 3. Carbon vs Oxygen (CO2)
    print("\n3. Carbon vs Oxygen (CO2)")
    print("-" * 40)
    print("Carbon and Oxygen also overlap significantly.")
    
    fig3 = plot_atom_spectra(C, O)
    
    overlap = spectral_overlap(C, O)
    print(f"Spectral Overlap (C-O): {overlap:.3f}")
    
    plt.show()
    
    print("\n" + "=" * 60)
    print("Conclusion: Valence emerges from spectral resonance compatibility!")
    print("=" * 60)

if __name__ == "__main__":
    main()



================================================================================
–§–ê–ô–õ: examples\atomic_valence_table_demo.py
================================================================================

"""
Atomic Valence Table Demo

Visualizes the "Periodic Table of Resonances" for selected atoms.
Shows core modes (stable) and valence modes (active for bonding).
"""

import numpy as np
import matplotlib.pyplot as plt
from spectral_physics.atoms import load_default_atom_db

def main():
    print("=" * 60)
    print("Atomic Valence Table: Spectral Visualization")
    print("=" * 60)
    
    db = load_default_atom_db()
    atoms = ['H', 'C', 'O', 'Si', 'Fe']
    
    fig, axes = plt.subplots(len(atoms), 1, figsize=(10, 2 * len(atoms)), sharex=True)
    
    if len(atoms) == 1:
        axes = [axes]
        
    for i, symbol in enumerate(atoms):
        atom = db[symbol]
        ax = axes[i]
        
        # Plot spectrum lines
        spec = atom.spectrum()
        ax.vlines(spec.omega, 0, spec.power, color='black', linewidth=2, label='Resonances')
        
        # Highlight Core Modes
        for (f_min, f_max) in atom.core_modes:
            ax.axvspan(f_min, f_max, color='blue', alpha=0.2, label='Core (Stable)')
            
        # Highlight Valence Modes
        for (f_min, f_max) in atom.valence_modes:
            ax.axvspan(f_min, f_max, color='red', alpha=0.2, label='Valence (Bonding)')
            
        ax.set_ylabel(f"Intensity")
        ax.set_title(f"Atom: {atom.name} (Max Bonds: {atom.max_bonds})")
        ax.grid(True, alpha=0.3)
        
        # Only add legend to first plot to avoid clutter
        if i == 0:
            ax.legend(loc='upper right')
            
    axes[-1].set_xlabel("Frequency (arbitrary units)")
    plt.tight_layout()
    plt.show()
    
    print("Visualization complete.")

if __name__ == "__main__":
    main()



================================================================================
–§–ê–ô–õ: examples\generate_synthetic_pump_data.py
================================================================================

import numpy as np
import pandas as pd
from pathlib import Path

def generate_signal(t, freqs, amps, noise_level=0.1):
    signal = np.zeros_like(t)
    for f, a in zip(freqs, amps):
        signal += a * np.sin(2 * np.pi * f * t)
    noise = np.random.normal(0, noise_level, size=len(t))
    return signal + noise

def main():
    # Setup
    data_dir = Path("data/pump")
    data_dir.mkdir(parents=True, exist_ok=True)
    
    dt = 0.001
    duration = 10.0
    t = np.arange(0, duration, dt)
    
    print(f"Generating data in {data_dir}...")
    
    # Define "Healthy" characteristics
    # Motor: 50Hz (main), 100Hz (harmonic)
    motor_freqs = [50.0, 100.0]
    motor_amps = [1.0, 0.2]
    
    # Pump: 30Hz (vane pass), 60Hz
    pump_freqs = [30.0, 60.0]
    pump_amps = [0.8, 0.3]
    
    # 1. Generate Training Data (Healthy)
    # We generate slightly different variations for training
    
    # Train Motor 1
    m1 = generate_signal(t, motor_freqs, motor_amps, noise_level=0.1)
    p1 = generate_signal(t, pump_freqs, pump_amps, noise_level=0.1)
    df1 = pd.DataFrame({'time': t, 'motor_vibration': m1, 'pump_vibration': p1})
    df1.to_csv(data_dir / "train_motor_1.csv", index=False)
    # Note: We save the same file for pump training or different ones?
    # The config expects:
    # motor_vibration files: train_motor_1.csv, train_motor_2.csv
    # pump_vibration files: train_pump_1.csv, train_pump_2.csv
    # We can just reuse the same structure or make separate files if we want strictly separate sensors.
    # But the config implies we might have different files for different channels or same files.
    # Let's generate 4 files as requested by the config structure, 
    # but actually the config says:
    # motor: train_motor_1.csv, train_motor_2.csv
    # pump: train_pump_1.csv, train_pump_2.csv
    # So we should probably generate these 4 files.
    
    # Train Motor 2 (slight variation)
    m2 = generate_signal(t, motor_freqs, [a * 1.05 for a in motor_amps], noise_level=0.12)
    p2 = generate_signal(t, pump_freqs, [a * 0.95 for a in pump_amps], noise_level=0.11)
    df2 = pd.DataFrame({'time': t, 'motor_vibration': m2, 'pump_vibration': p2})
    df2.to_csv(data_dir / "train_motor_2.csv", index=False)
    
    # Train Pump 1 (can be same as motor 1 or different)
    # Let's make them distinct files to match the config exactly
    df1.to_csv(data_dir / "train_pump_1.csv", index=False)
    df2.to_csv(data_dir / "train_pump_2.csv", index=False)
    
    print("  Created training files.")
    
    # 2. Generate Current Data (Test)
    
    # Current Motor (Normal)
    m_curr = generate_signal(t, motor_freqs, [a * 1.02 for a in motor_amps], noise_level=0.1)
    p_curr_normal = generate_signal(t, pump_freqs, pump_amps, noise_level=0.1)
    df_curr_motor = pd.DataFrame({'time': t, 'motor_vibration': m_curr, 'pump_vibration': p_curr_normal})
    df_curr_motor.to_csv(data_dir / "current_motor.csv", index=False)
    
    # Current Pump (Anomaly!)
    # Add a new frequency component at 150Hz (bearing fault?) and increase noise
    m_anom = generate_signal(t, motor_freqs, motor_amps, noise_level=0.1)
    
    pump_freqs_anom = pump_freqs + [150.0]
    pump_amps_anom = pump_amps + [0.5] # Significant new peak
    p_anom = generate_signal(t, pump_freqs_anom, pump_amps_anom, noise_level=0.2) # Higher noise
    
    df_curr_pump = pd.DataFrame({'time': t, 'motor_vibration': m_anom, 'pump_vibration': p_anom})
    df_curr_pump.to_csv(data_dir / "current_pump.csv", index=False)
    
    print("  Created current status files (Motor: OK, Pump: ANOMALY).")
    print("Done.")

if __name__ == "__main__":
    main()



================================================================================
–§–ê–ô–õ: examples\geophysics_1d_demo.py
================================================================================

"""
1D Geophysics: Layered Earth & Inversion

This demo simulates a seismic pulse propagating through a layered medium.
We then solve a simple inverse problem: determining the thickness of the top layer 
from the surface response.
"""

import numpy as np
import matplotlib.pyplot as plt
from spectral_physics.geophysics_1d import (
    Layer, LayeredMedium1D, simulate_pulse_response, invert_single_layer_thickness
)

def main():
    print("=" * 60)
    print("1D Geophysics: Layered Earth & Inversion")
    print("=" * 60)
    
    # 1. Setup "True" Earth Model
    # Layer 1: Soft soil (low density/stiffness), unknown thickness
    true_h = 15.0
    layer1 = Layer(thickness=true_h, density=1.5, stiffness=2.0)
    
    # Layer 2: Hard rock (high density/stiffness), known properties
    layer2 = Layer(thickness=50.0, density=3.0, stiffness=10.0)
    
    medium_true = LayeredMedium1D(layers=[layer1, layer2], dx=0.5)
    
    print(f"\nTrue Model: Top layer thickness = {true_h}")
    
    # 2. Simulate Surface Response (The "Measurement")
    t_max = 50.0
    dt = 0.1
    
    print("\nSimulating seismic response...")
    t, signal_true = simulate_pulse_response(medium_true, t_max=t_max, dt=dt)
    
    plt.figure(figsize=(10, 4))
    plt.plot(t, signal_true, label='Observed Signal')
    plt.title("Seismic Response (Surface Displacement)")
    plt.xlabel("Time")
    plt.ylabel("Amplitude")
    plt.grid(True, alpha=0.3)
    plt.legend()
    plt.show()
    
    # 3. Solve Inverse Problem
    # We know density/stiffness of top layer, but not thickness.
    # We know the substrate (layer2).
    
    guess_h = 10.0
    print(f"\nStarting inversion with guess h = {guess_h}...")
    
    found_h = invert_single_layer_thickness(
        target_signal=signal_true,
        t=t,
        density=layer1.density,
        stiffness=layer1.stiffness,
        thickness_guess=guess_h,
        fixed_layers_below=[layer2],
        dx=0.5
    )
    
    print(f"Inversion Result: h = {found_h:.2f} (True: {true_h})")
    error = abs(found_h - true_h)
    print(f"Error: {error:.2f}")
    
    # 4. Verify Result
    # Simulate with found thickness
    print("\nVerifying result...")
    layer_found = Layer(thickness=found_h, density=layer1.density, stiffness=layer1.stiffness)
    medium_found = LayeredMedium1D(layers=[layer_found, layer2], dx=0.5)
    _, signal_found = simulate_pulse_response(medium_found, t_max=t_max, dt=dt)
    
    plt.figure(figsize=(10, 4))
    plt.plot(t, signal_true, 'k-', alpha=0.5, lw=3, label='Observed')
    plt.plot(t, signal_found, 'r--', label='Model (Inverted)')
    plt.title(f"Model Fit (h_found={found_h:.2f})")
    plt.xlabel("Time")
    plt.legend()
    plt.grid(True, alpha=0.3)
    plt.show()
    
    print("\n" + "=" * 60)
    print("Conclusion:")
    print("We successfully recovered the thickness of the top layer")
    print("by matching the seismic response.")
    print("This is a toy example of full-waveform inversion (FWI).")
    print("=" * 60)

if __name__ == "__main__":
    main()



================================================================================
–§–ê–ô–õ: examples\geophysics_2d_health_demo.py
================================================================================

"""
GeoSpectra 2D: Foundation Health Monitoring

This script demonstrates monitoring a building foundation:
1. Baseline: Healthy soil under foundation.
2. Current: "Washout" (erosion) under one side.
3. Compare surface response to detect the issue.
"""

import numpy as np
import matplotlib.pyplot as plt
from spectral_physics.geophysics_2d import GeoGrid2D

def create_foundation_model(washout=False):
    nx, ny = 40, 20
    depth_scale = 0.5
    
    # Base soil
    stiffness = np.full((ny, nx), 5.0)
    density = np.full((ny, nx), 2.0)
    
    # Foundation Block (Concrete) on surface (top 2 rows, center)
    # High stiffness, high density
    fx_start, fx_end = 15, 25
    fy_start = ny - 2
    
    stiffness[fy_start:, fx_start:fx_end] = 20.0
    density[fy_start:, fx_start:fx_end] = 5.0
    
    if washout:
        # Erosion under the right side of foundation
        # Low stiffness (water/air mix)
        wx_start, wx_end = 20, 25
        wy_start, wy_end = fy_start - 3, fy_start
        
        stiffness[wy_start:wy_end, wx_start:wx_end] = 1.0
        density[wy_start:wy_end, wx_start:wx_end] = 1.0
        
    return GeoGrid2D(nx, ny, depth_scale, stiffness, density)

def main():
    print("=" * 60)
    print("GeoSpectra 2D: Foundation Health Monitor")
    print("=" * 60)
    
    # 1. Simulate Baseline
    print("1. Simulating Baseline (Healthy Foundation)...")
    geo_base = create_foundation_model(washout=False)
    resp_base = geo_base.forward_response(freq_window=(0.0, 2.0), n_modes=50)
    
    # 2. Simulate Washout
    print("2. Simulating Current State (Washout/Erosion)...")
    geo_curr = create_foundation_model(washout=True)
    resp_curr = geo_curr.forward_response(freq_window=(0.0, 2.0), n_modes=50)
    
    # 3. Compare
    diff = np.abs(resp_curr - resp_base)
    max_diff_idx = np.argmax(diff)
    print(f"   Max difference at x={max_diff_idx}")
    
    # 4. Visualize
    print("3. Visualizing...")
    fig, axes = plt.subplots(2, 2, figsize=(12, 8))
    
    # Maps
    im0 = axes[0, 0].imshow(geo_base.stiffness_map, origin='lower', cmap='cividis')
    axes[0, 0].set_title("Baseline Stiffness")
    plt.colorbar(im0, ax=axes[0, 0])
    
    im1 = axes[0, 1].imshow(geo_curr.stiffness_map, origin='lower', cmap='cividis')
    axes[0, 1].set_title("Washout Stiffness (Note low val under right)")
    plt.colorbar(im1, ax=axes[0, 1])
    
    # Responses
    ax2 = axes[1, 0]
    ax2.plot(resp_base, 'b-', label='Baseline')
    ax2.plot(resp_curr, 'r--', label='Current (Washout)')
    ax2.set_title("Surface Response (LDOS)")
    ax2.legend()
    ax2.grid(True)
    
    # Difference
    ax3 = axes[1, 1]
    ax3.plot(diff, 'k-', linewidth=2)
    ax3.fill_between(range(len(diff)), diff, color='orange', alpha=0.3)
    ax3.set_title("Difference Signal (Anomaly)")
    ax3.set_xlabel("Position (x)")
    ax3.grid(True)
    
    plt.tight_layout()
    plt.show()
    
    print("\n" + "=" * 60)
    if np.max(diff) > 0.01:
        print("ALERT: Significant foundation anomaly detected!")
    else:
        print("Status: Stable.")
    print("=" * 60)

if __name__ == "__main__":
    main()



================================================================================
–§–ê–ô–õ: examples\geophysics_2d_toy_demo.py
================================================================================

"""
GeoSpectra 2D: Toy Demo (Cavity Detection)

This script demonstrates 2D geophysical modeling:
1. Create a ground model with a hidden cavity.
2. Simulate surface response (LDOS).
3. Visualize the "hidden" structure and the surface signal.
"""

import numpy as np
import matplotlib.pyplot as plt
from spectral_physics.geophysics_2d import GeoGrid2D

def main():
    print("=" * 60)
    print("GeoSpectra 2D: Cavity Detection Demo")
    print("=" * 60)
    
    # 1. Define Ground Model
    nx, ny = 40, 30
    depth_scale = 1.0 # meters per pixel
    
    print(f"1. Creating Ground Model ({nx}x{ny}, {depth_scale}m/px)...")
    
    # Background: Stiff rock
    stiffness_map = np.full((ny, nx), 10.0)
    density_map = np.full((ny, nx), 3.0)
    
    # Top layer: Softer soil (top 5 rows)
    # Note: y=0 is bottom, y=ny-1 is top.
    top_layer_height = 5
    stiffness_map[-top_layer_height:, :] = 2.0
    density_map[-top_layer_height:, :] = 1.5
    
    # Cavity: Hidden void deep underground
    # Low stiffness, low density (air/water)
    cx, cy = 20, 10
    r = 4
    y, x = np.ogrid[:ny, :nx]
    mask = (x - cx)**2 + (y - cy)**2 <= r**2
    
    stiffness_map[mask] = 0.1
    density_map[mask] = 0.1
    
    geo_grid = GeoGrid2D(
        nx=nx, ny=ny, depth_scale=depth_scale,
        stiffness_map=stiffness_map,
        density_map=density_map
    )
    
    # 2. Simulate Surface Response
    print("2. Simulating Surface Response...")
    freq_window = (0.0, 2.0)
    n_modes = 60
    
    # Get full LDOS for visualization
    grid = geo_grid.to_oscillator_grid()
    ldos_map = grid.ldos_map(n_modes=n_modes, freq_window=freq_window)
    
    # Extract surface signal (top row)
    surface_signal = ldos_map[-1, :]
    
    # 3. Visualize
    print("3. Visualizing...")
    fig, axes = plt.subplots(2, 2, figsize=(12, 10))
    
    # Stiffness Map (Ground Truth)
    im0 = axes[0, 0].imshow(stiffness_map, origin='lower', cmap='cividis')
    axes[0, 0].set_title("Ground Stiffness (True Model)")
    plt.colorbar(im0, ax=axes[0, 0], label='Stiffness')
    
    # Density Map
    im1 = axes[0, 1].imshow(density_map, origin='lower', cmap='bone')
    axes[0, 1].set_title("Ground Density (True Model)")
    plt.colorbar(im1, ax=axes[0, 1], label='Density')
    
    # Full LDOS Map (What's happening inside)
    im2 = axes[1, 0].imshow(ldos_map, origin='lower', cmap='inferno')
    axes[1, 0].set_title("Internal Vibration Intensity (LDOS)")
    plt.colorbar(im2, ax=axes[1, 0], label='LDOS')
    
    # Surface Signal (What we measure)
    ax3 = axes[1, 1]
    ax3.plot(surface_signal, 'r-o', linewidth=2)
    ax3.set_title("Surface Measurement (LDOS at Top)")
    ax3.set_xlabel("Position (x)")
    ax3.set_ylabel("Response Intensity")
    ax3.grid(True)
    
    # Highlight cavity position on surface plot
    ax3.axvspan(cx - r, cx + r, color='yellow', alpha=0.3, label='Cavity X-range')
    ax3.legend()
    
    plt.tight_layout()
    plt.show()
    
    print("\n" + "=" * 60)
    print("Demo Complete.")
    print("Notice the dip/peak in surface response above the cavity?")
    print("=" * 60)

if __name__ == "__main__":
    main()



================================================================================
–§–ê–ô–õ: examples\geophysics_health_demo.py
================================================================================

"""
Geophysics Health Monitoring

This demo applies health monitoring to geophysical data.
We assume a "healthy" baseline response (e.g., from a stable formation) 
and detect changes (e.g., fluid injection, subsidence).
"""

import numpy as np
import matplotlib.pyplot as plt
from spectral_physics.geophysics_1d import (
    Layer, LayeredMedium1D, simulate_pulse_response, build_geo1d_health_profile
)

def main():
    print("=" * 60)
    print("Geophysics Health Monitoring Demo")
    print("=" * 60)
    
    # 1. Baseline (Healthy) Model
    print("\nSetting up baseline (healthy) model...")
    l1 = Layer(thickness=15.0, density=1.5, stiffness=2.0)
    l2 = Layer(thickness=50.0, density=3.0, stiffness=10.0)
    medium_base = LayeredMedium1D(layers=[l1, l2], dx=0.5)
    
    t, sig_base = simulate_pulse_response(medium_base, t_max=50.0, dt=0.1)
    
    profile = build_geo1d_health_profile(sig_base)
    print("Baseline Features:", profile.reference_features)
    
    # 2. Changed Model (Anomaly)
    # Suppose the top layer becomes softer (e.g., water saturation)
    print("\nSimulating anomaly (softened top layer)...")
    l1_soft = Layer(thickness=15.0, density=1.4, stiffness=1.5)  # Stiffness dropped
    medium_anom = LayeredMedium1D(layers=[l1_soft, l2], dx=0.5)
    
    _, sig_anom = simulate_pulse_response(medium_anom, t_max=50.0, dt=0.1)
    
    current_sig = build_geo1d_health_profile(sig_anom)
    
    distance = profile.distance_l2(current_sig.reference_features)
    print(f"\nHealth Distance: {distance:.4f}")
    
    # 3. Threshold check
    threshold = 50.0  # Arbitrary threshold
    print(f"Threshold: {threshold}")
    
    if distance > threshold:
        print("Status: ‚ö†Ô∏è  ANOMALY DETECTED (Formation Change)")
    else:
        print("Status: ‚úì OK")
    
    # 4. Visualization
    plt.figure(figsize=(10, 4))
    plt.plot(t, sig_base, label='Baseline')
    plt.plot(t, sig_anom, label='Anomaly (Soft Layer)')
    plt.title(f"Seismic Response Change (Dist={distance:.2f})")
    plt.xlabel("Time")
    plt.ylabel("Amplitude")
    plt.legend()
    plt.grid(True, alpha=0.3)
    plt.show()
    
    print("\n" + "=" * 60)
    print("Conclusion: Formation change detected via health monitoring!")
    print("=" * 60)

if __name__ == "__main__":
    main()



================================================================================
–§–ê–ô–õ: examples\health_monitor_demo.py
================================================================================

"""
Health Monitor Demo (Pump Monitoring)

This script demonstrates the end-to-end spectral-health pipeline:
1. Generate synthetic pump vibration data
2. Train a health profile
3. Score current data
4. Display the generated report
"""

import subprocess
import sys
from pathlib import Path

def main():
    print("=" * 60)
    print("Pump Health Monitoring Demo")
    print("=" * 60)
    
    # Get project root
    project_root = Path(__file__).parent.parent
    
    # 1. Generate synthetic data
    print("\n[Step 1/3] Generating synthetic pump data...")
    result = subprocess.run(
        [sys.executable, str(project_root / "examples" / "generate_synthetic_pump_data.py")],
        capture_output=True,
        text=True
    )
    if result.returncode != 0:
        print("Error:", result.stderr)
        return
    print("‚úì Data generated")
    
    # 2. Train health profile
    print("\n[Step 2/3] Training health profile...")
    result = subprocess.run(
        [
            "spectral-health", "train",
            "--config", str(project_root / "configs" / "pump_train.yaml"),
            "--out", str(project_root / "data" / "pump" / "profile.npz")
        ],
        capture_output=True,
        text=True,
        cwd=str(project_root)
    )
    if result.returncode != 0:
        print("Error:", result.stderr)
        return
    print("‚úì Profile trained")
    
    # 3. Score current data
    print("\n[Step 3/3] Scoring current data and generating report...")
    result = subprocess.run(
        [
            "spectral-health", "score",
            "--config", str(project_root / "configs" / "pump_score.yaml"),
            "--profile", str(project_root / "data" / "pump" / "profile.npz"),
            "--thresholds", str(project_root / "configs" / "pump_thresholds.yaml"),
            "--report", str(project_root / "data" / "pump" / "report.md")
        ],
        capture_output=True,
        text=True,
        cwd=str(project_root)
    )
    if result.returncode != 0:
        print("Error:", result.stderr)
        return
    print("‚úì Report generated")
    
    # 4. Display report
    print("\n" + "=" * 60)
    print("HEALTH REPORT:")
    print("=" * 60)
    report_path = project_root / "data" / "pump" / "report.md"
    if report_path.exists():
        print(report_path.read_text())
    else:
        print("Report not found!")
    
    print("\n" + "=" * 60)
    print("Demo completed successfully!")
    print("=" * 60)

if __name__ == "__main__":
    main()



================================================================================
–§–ê–ô–õ: examples\material_defect_demo.py
================================================================================

"""
Material Defect Demo: LDOS Anomalies

This script demonstrates how a local defect (change in mass or stiffness) affects 
the Local Spectral Density (LDOS) of a 2D medium.
We compare a "pristine" plate with a "defective" one.
"""

import numpy as np
import matplotlib.pyplot as plt
from spectral_physics.medium_2d import OscillatorGrid2D

def main():
    print("=" * 60)
    print("Material Defect Demo: LDOS Anomalies")
    print("=" * 60)
    
    # 1. Setup Pristine Grid
    nx, ny = 20, 20
    grid_clean = OscillatorGrid2D(nx=nx, ny=ny, kx=1.0, ky=1.0, m=1.0)
    
    # Calculate LDOS map in a low-frequency window
    freq_window = (0.0, 1.5)
    n_modes = 50  # Calculate enough modes to cover the window
    
    print("\nCalculating LDOS for pristine grid...")
    ldos_clean = grid_clean.ldos_map(n_modes=n_modes, freq_window=freq_window)
    
    # 2. Setup Defective Grid
    # Defect: Heavy mass in the center (3x3 block)
    mass_map = np.ones((ny, nx))
    cx, cy = nx // 2, ny // 2
    mass_map[cy-1:cy+2, cx-1:cx+2] = 5.0  # 5x heavier
    
    grid_defect = OscillatorGrid2D(nx=nx, ny=ny, kx=1.0, ky=1.0, m=1.0, mass_map=mass_map)
    
    print("Calculating LDOS for defective grid...")
    ldos_defect = grid_defect.ldos_map(n_modes=n_modes, freq_window=freq_window)
    
    # 3. Visualize Comparison
    fig, axes = plt.subplots(1, 3, figsize=(18, 5))
    
    vmin = min(ldos_clean.min(), ldos_defect.min())
    vmax = max(ldos_clean.max(), ldos_defect.max())
    
    im0 = axes[0].imshow(ldos_clean, origin='lower', cmap='inferno', vmin=vmin, vmax=vmax)
    axes[0].set_title("Pristine LDOS")
    plt.colorbar(im0, ax=axes[0])
    
    im1 = axes[1].imshow(ldos_defect, origin='lower', cmap='inferno', vmin=vmin, vmax=vmax)
    axes[1].set_title("Defective LDOS (Heavy Center)")
    plt.colorbar(im1, ax=axes[1])
    
    # Difference
    diff = ldos_defect - ldos_clean
    im2 = axes[2].imshow(diff, origin='lower', cmap='RdBu_r')
    axes[2].set_title("Difference (Defect - Clean)")
    plt.colorbar(im2, ax=axes[2])
    
    plt.tight_layout()
    plt.show()
    
    print("\n" + "=" * 60)
    print("Interpretation:")
    print("The heavy defect changes the local spectral density.")
    print("In the low-frequency window, the heavy mass might accumulate")
    print("more energy (or less, depending on the modes shifted).")
    print("The difference map clearly highlights the location of the anomaly.")
    print("=" * 60)

if __name__ == "__main__":
    main()



================================================================================
–§–ê–ô–õ: examples\material_health_demo.py
================================================================================

"""
Material Health Monitoring

This demo shows how to use spectral-health concepts for materials.
We treat the LDOS map as the "state" of the material and detect defects 
as deviations from a healthy profile.
"""

import numpy as np
import matplotlib.pyplot as plt
from spectral_physics.medium_2d import OscillatorGrid2D
from spectral_physics.materials import build_material_health_profile

def main():
    print("=" * 60)
    print("Material Health Monitoring Demo")
    print("=" * 60)
    
    # 1. Train Healthy Profile
    # Create a pristine grid
    nx, ny = 20, 20
    grid_clean = OscillatorGrid2D(nx=nx, ny=ny, kx=1.0, ky=1.0, m=1.0)
    
    print("\nCalculating healthy LDOS...")
    # Calculate LDOS
    ldos_clean = grid_clean.ldos_map(n_modes=50, freq_window=(0.0, 1.5))
    
    # Build profile
    profile = build_material_health_profile(ldos_clean)
    print("Healthy Profile Features:", profile.reference_features)
    
    # 2. Test Defective Material
    # Create grid with defect
    print("\nCreating defective material (heavy spot)...")
    mass_map = np.ones((ny, nx))
    cx, cy = nx // 2, ny // 2
    mass_map[cy-1:cy+2, cx-1:cx+2] = 5.0  # Heavy spot
    
    grid_defect = OscillatorGrid2D(nx=nx, ny=ny, kx=1.0, ky=1.0, m=1.0, mass_map=mass_map)
    ldos_defect = grid_defect.ldos_map(n_modes=50, freq_window=(0.0, 1.5))
    
    # Build "current" features (using same logic as profile builder)
    current_sig = build_material_health_profile(ldos_defect)
    
    # Calculate distance
    distance = profile.distance_l2(current_sig.reference_features)
    print(f"\nHealth Distance: {distance:.4f}")
    
    # 3. Threshold Check
    threshold = 1.0  # Arbitrary threshold
    print(f"Threshold: {threshold}")
    
    if distance > threshold:
        print("Status: ‚ö†Ô∏è  ANOMALY DETECTED (Material Defect)")
    else:
        print("Status: ‚úì OK")
    
    # 4. Visualize
    fig, axes = plt.subplots(1, 2, figsize=(12, 5))
    
    im0 = axes[0].imshow(ldos_clean, origin='lower', cmap='inferno')
    axes[0].set_title("Healthy Material")
    plt.colorbar(im0, ax=axes[0])
    
    im1 = axes[1].imshow(ldos_defect, origin='lower', cmap='inferno')
    axes[1].set_title(f"Defective Material (Dist={distance:.2f})")
    plt.colorbar(im1, ax=axes[1])
    
    plt.tight_layout()
    plt.show()
    
    print("\n" + "=" * 60)
    print("Conclusion: Defect automatically detected via health distance!")
    print("=" * 60)

if __name__ == "__main__":
    main()



================================================================================
–§–ê–ô–õ: examples\material_spectrum_guess_demo.py
================================================================================

"""
Material Spectrum Guess Demo

A "game" where the system tries to identify a material based on its LDOS signature.
1. We generate a synthetic LDOS map corresponding to a material (Steel, Water, Concrete).
2. We add noise to simulate real measurement.
3. The inference engine guesses the material.
"""

import numpy as np
import matplotlib.pyplot as plt
from spectral_physics.atoms import load_default_atom_db
from spectral_physics.materials import infer_material_from_ldos

def generate_mystery_ldos(material_type: str, nx=20, ny=20) -> np.ndarray:
    """
    Generate synthetic LDOS map for a given material type.
    """
    if material_type == "Steel":
        # Steel: Low mean (heavy), low variance (uniform)
        base = 0.04
        noise = 0.005
    elif material_type == "Water":
        # Water: High mean (light), high variance (liquid/disordered)
        base = 0.12
        noise = 0.03
    elif material_type == "Concrete":
        # Concrete: Medium mean, medium variance
        base = 0.08
        noise = 0.015
    else:
        raise ValueError(f"Unknown material: {material_type}")
        
    ldos = np.random.normal(base, noise, size=(ny, nx))
    return np.abs(ldos) # LDOS must be positive

def main():
    print("=" * 60)
    print("Material Spectrum Guess: AI Inference Demo")
    print("=" * 60)
    
    atom_db = load_default_atom_db()
    
    # Test cases
    test_materials = ["Steel", "Water", "Concrete"]
    
    for true_material in test_materials:
        print(f"\n--- Mystery Sample: {true_material} ---")
        
        # 1. Generate Data
        ldos_map = generate_mystery_ldos(true_material)
        print(f"Generated LDOS map. Mean: {np.mean(ldos_map):.4f}, Std: {np.std(ldos_map):.4f}")
        
        # 2. Infer
        candidates = infer_material_from_ldos(ldos_map, atom_db)
        
        # 3. Report
        print("AI Guesses:")
        top_guess = candidates[0]
        for i, cand in enumerate(candidates):
            print(f"  {i+1}. {cand.name:<20} Confidence: {cand.confidence:.2f}")
            
        # Check result
        # Note: Our inference names are "Steel (Fe-C)", "Water (H2O)", etc.
        if true_material in top_guess.name:
            print("‚úÖ CORRECT IDENTIFICATION")
        else:
            print("‚ùå INCORRECT IDENTIFICATION")
            
    print("\n" + "=" * 60)
    print("Demo Complete.")

if __name__ == "__main__":
    main()



================================================================================
–§–ê–ô–õ: examples\medium_2d_modes_demo.py
================================================================================

"""
2D Medium Modes Demo

This script visualizes the eigenmodes (standing waves) of a 2D oscillator grid (elastic plate).
We use OscillatorGrid2D to calculate the modes and matplotlib to display them.
"""

import numpy as np
import matplotlib.pyplot as plt
from spectral_physics.medium_2d import OscillatorGrid2D

def main():
    # 1. Create a 2D Grid
    nx, ny = 20, 20
    grid = OscillatorGrid2D(nx=nx, ny=ny, kx=1.0, ky=1.0, m=1.0)
    
    print(f"Grid size: {nx}x{ny} = {nx*ny} oscillators")
    
    # 2. Calculate Eigenmodes
    n_modes = 9
    print(f"Calculating first {n_modes} modes...")
    omega, modes = grid.eigenmodes(n_modes=n_modes)
    
    print("Frequencies:", omega)
    
    # 3. Visualize Modes
    fig, axes = plt.subplots(3, 3, figsize=(12, 12))
    axes = axes.flatten()
    
    for i in range(n_modes):
        ax = axes[i]
        
        # Extract mode vector and reshape to 2D grid
        mode_vec = modes[:, i]
        mode_grid = mode_vec.reshape((ny, nx))
        
        # Plot
        im = ax.imshow(mode_grid, cmap='RdBu', origin='lower', interpolation='bicubic')
        ax.set_title(f"Mode {i+1}: $\\omega$ = {omega[i]:.3f}")
        plt.colorbar(im, ax=ax, fraction=0.046, pad=0.04)
    
    plt.tight_layout()
    plt.suptitle("2D Medium Eigenmodes", y=1.001)
    plt.show()
    
    print("\nThese patterns represent the fundamental resonances of the medium.")
    print("In a 'spectral physics' context, these are the available 'slots' for energy to occupy.")

if __name__ == "__main__":
    main()



================================================================================
–§–ê–ô–õ: examples\ndt_synthetic_defect_demo.py
================================================================================

"""
NDT Synthetic Defect Demo

This script demonstrates the Spectral NDT workflow:
1. Train a profile on a healthy grid.
2. Introduce a defect (mass anomaly).
3. Detect the defect using the NDT profile.
"""

import numpy as np
import matplotlib.pyplot as plt
from spectral_physics.medium_2d import OscillatorGrid2D
from spectral_physics.ndt import build_ndt_profile, score_ndt_state, ndt_defect_mask

def main():
    print("=" * 60)
    print("Spectral NDT: Synthetic Defect Detection")
    print("=" * 60)
    
    # 1. Setup Healthy Grid
    nx, ny = 30, 30
    print(f"\n1. Creating Healthy Grid ({nx}x{ny})...")
    grid_clean = OscillatorGrid2D(nx=nx, ny=ny, kx=1.0, ky=1.0, m=1.0)
    
    # 2. Train NDT Profile
    print("2. Training NDT Profile...")
    # We use a low-frequency window where mass effects are visible
    freq_window = (0.0, 1.5)
    n_modes = 60
    
    # Add some noise to training to make it robust (simulate real measurements)
    profile = build_ndt_profile(
        grid=grid_clean,
        n_modes=n_modes,
        freq_window=freq_window,
        n_samples=5,
        noise_level=0.05
    )
    
    print(f"   Profile built. Mean LDOS range: [{profile.ldos_mean.min():.4f}, {profile.ldos_mean.max():.4f}]")
    
    # 3. Create Defective Grid
    print("\n3. Creating Defective Grid...")
    # Defect: Heavy mass block in the center-right
    mass_map = np.ones((ny, nx))
    
    # Add defect
    cx, cy = 20, 15
    r = 3
    y, x = np.ogrid[:ny, :nx]
    mask = (x - cx)**2 + (y - cy)**2 <= r**2
    mass_map[mask] = 5.0  # 5x heavier
    
    grid_defect = OscillatorGrid2D(
        nx=nx, ny=ny, kx=1.0, ky=1.0, m=1.0,
        mass_map=mass_map
    )
    
    # Calculate current LDOS
    print("   Calculating LDOS for defective grid...")
    ldos_current = grid_defect.ldos_map(n_modes=n_modes, freq_window=freq_window)
    
    # 4. Score and Detect
    print("\n4. Scoring and Detecting...")
    scores = score_ndt_state(profile, ldos_current)
    
    threshold = 5.0 # Z-score threshold
    defect_mask = ndt_defect_mask(scores, threshold)
    
    n_defects = np.sum(defect_mask)
    print(f"   Defects detected: {n_defects} pixels (Threshold={threshold})")
    
    # 5. Visualize
    fig, axes = plt.subplots(2, 2, figsize=(12, 10))
    
    # Healthy Mean
    im0 = axes[0, 0].imshow(profile.ldos_mean, origin='lower', cmap='inferno')
    axes[0, 0].set_title("Healthy Profile (Mean LDOS)")
    plt.colorbar(im0, ax=axes[0, 0])
    
    # Current LDOS
    im1 = axes[0, 1].imshow(ldos_current, origin='lower', cmap='inferno')
    axes[0, 1].set_title("Current LDOS (with Defect)")
    plt.colorbar(im1, ax=axes[0, 1])
    
    # Score Map
    im2 = axes[1, 0].imshow(scores, origin='lower', cmap='Reds')
    axes[1, 0].set_title("Defect Scores (Z-score)")
    plt.colorbar(im2, ax=axes[1, 0])
    
    # Defect Mask
    im3 = axes[1, 1].imshow(defect_mask, origin='lower', cmap='gray')
    axes[1, 1].set_title(f"Defect Mask (Threshold={threshold})")
    
    plt.tight_layout()
    plt.show()
    
    print("\n" + "=" * 60)
    if n_defects > 0:
        print("SUCCESS: Defect detected!")
    else:
        print("FAILURE: Defect NOT detected.")
    print("=" * 60)

if __name__ == "__main__":
    main()



================================================================================
–§–ê–ô–õ: PROJECT_CODE.txt
================================================================================

================================================================================
–ü–†–û–ï–ö–¢: SpectralPhysics-Lab
–î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∞—Ä—Ö–∏–≤–∞: 2025-11-30 18:50:56
================================================================================

–°–¢–†–£–ö–¢–£–†–ê –ü–†–û–ï–ö–¢–ê:
--------------------------------------------------------------------------------
SpectralPhysics-Lab
‚îú‚îÄ‚îÄ configs
‚îÇ   ‚îú‚îÄ‚îÄ pump_score.yaml
‚îÇ   ‚îú‚îÄ‚îÄ pump_thresholds.yaml
‚îÇ   ‚îî‚îÄ‚îÄ pump_train.yaml
‚îú‚îÄ‚îÄ data
‚îÇ   ‚îî‚îÄ‚îÄ pump
‚îÇ       ‚îú‚îÄ‚îÄ current_motor.csv
‚îÇ       ‚îú‚îÄ‚îÄ current_pump.csv
‚îÇ       ‚îú‚îÄ‚îÄ profile.npz
‚îÇ       ‚îú‚îÄ‚îÄ report.md
‚îÇ       ‚îú‚îÄ‚îÄ train_motor_1.csv
‚îÇ       ‚îú‚îÄ‚îÄ train_motor_2.csv
‚îÇ       ‚îú‚îÄ‚îÄ train_pump_1.csv
‚îÇ       ‚îî‚îÄ‚îÄ train_pump_2.csv
‚îú‚îÄ‚îÄ examples
‚îÇ   ‚îú‚îÄ‚îÄ atomic_valence_demo.py
‚îÇ   ‚îú‚îÄ‚îÄ generate_synthetic_pump_data.py
‚îÇ   ‚îú‚îÄ‚îÄ geophysics_1d_demo.py
‚îÇ   ‚îú‚îÄ‚îÄ geophysics_health_demo.py
‚îÇ   ‚îú‚îÄ‚îÄ health_monitor_demo.py
‚îÇ   ‚îú‚îÄ‚îÄ material_defect_demo.py
‚îÇ   ‚îú‚îÄ‚îÄ material_health_demo.py
‚îÇ   ‚îî‚îÄ‚îÄ medium_2d_modes_demo.py
‚îú‚îÄ‚îÄ src
‚îÇ   ‚îú‚îÄ‚îÄ spectral_physics
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ atoms.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cli.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ diagnostics.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ geophysics_1d.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ grav_toy.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ io.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ldos.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ material.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ materials.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ medium_1d.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ medium_2d.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ report.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ root_finding.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ spectrum.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ timeseries.py
‚îÇ   ‚îî‚îÄ‚îÄ spectral_physics_lab.egg-info
‚îÇ       ‚îú‚îÄ‚îÄ PKG-INFO
‚îÇ       ‚îú‚îÄ‚îÄ SOURCES.txt
‚îÇ       ‚îú‚îÄ‚îÄ dependency_links.txt
‚îÇ       ‚îú‚îÄ‚îÄ entry_points.txt
‚îÇ       ‚îú‚îÄ‚îÄ requires.txt
‚îÇ       ‚îî‚îÄ‚îÄ top_level.txt
‚îú‚îÄ‚îÄ tests
‚îÇ   ‚îú‚îÄ‚îÄ test_atoms.py
‚îÇ   ‚îú‚îÄ‚îÄ test_diagnostics.py
‚îÇ   ‚îú‚îÄ‚îÄ test_diagnostics_features.py
‚îÇ   ‚îú‚îÄ‚îÄ test_geophysics_1d.py
‚îÇ   ‚îú‚îÄ‚îÄ test_grav_toy.py
‚îÇ   ‚îú‚îÄ‚îÄ test_io.py
‚îÇ   ‚îú‚îÄ‚îÄ test_ldos.py
‚îÇ   ‚îú‚îÄ‚îÄ test_material.py
‚îÇ   ‚îú‚îÄ‚îÄ test_material_features.py
‚îÇ   ‚îú‚îÄ‚îÄ test_materials.py
‚îÇ   ‚îú‚îÄ‚îÄ test_medium_1d.py
‚îÇ   ‚îú‚îÄ‚îÄ test_medium_2d.py
‚îÇ   ‚îú‚îÄ‚îÄ test_report.py
‚îÇ   ‚îú‚îÄ‚îÄ test_root_finding.py
‚îÇ   ‚îú‚îÄ‚îÄ test_spectrum.py
‚îÇ   ‚îî‚îÄ‚îÄ test_timeseries.py
‚îú‚îÄ‚îÄ AI_TASKS.md
‚îú‚îÄ‚îÄ PROJECT_CODE.txt
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ pyproject.toml

================================================================================
–°–û–î–ï–†–ñ–ò–ú–û–ï –§–ê–ô–õ–û–í
================================================================================


================================================================================
–§–ê–ô–õ: AI_TASKS.md
================================================================================

# –ú–ï–ì–ê-–ü–†–û–ï–ö–¢: spectral-health v1.0

–¶–µ–ª—å: –ø—Ä–µ–≤—Ä–∞—Ç–∏—Ç—å —Ç–µ–∫—É—â–∏–π –∫–æ–¥ –≤ **–ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω—ã–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏ –º–∞—à–∏–Ω**:

- –í—Ö–æ–¥: CSV —Å –≤–∏–±—Ä–∞—Ü–∏–µ–π/—Å–∏–≥–Ω–∞–ª–∞–º–∏.
- –í—ã—Ö–æ–¥: CLI-—É—Ç–∏–ª–∏—Ç–∞ `spectral-health`, –∫–æ—Ç–æ—Ä–∞—è:
  - –æ–±—É—á–∞–µ—Ç "–∑–¥–æ—Ä–æ–≤—ã–π –ø—Ä–æ—Ñ–∏–ª—å" –ø–æ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–º –¥–∞–Ω–Ω—ã–º;
  - –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –Ω–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ;
  - –¥–∞—ë—Ç —Å—Ç–∞—Ç—É—Å –ø–æ –∫–∞–∂–¥–æ–º—É –∫–∞–Ω–∞–ª—É (OK / ANOMALY);
  - –ø–∏—à–µ—Ç –∫—Ä–∞—Å–∏–≤—ã–π Markdown-–æ—Ç—á—ë—Ç.

---

## –≠–¢–ê–ü 20. –î–æ–≤–æ–¥–∏–º —è–¥—Ä–æ –∏ —É–ø–∞–∫–æ–≤–∫—É –¥–æ –±–æ–µ–≤–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è

**–§–∞–π–ª—ã:** `pyproject.toml`, `README.md`, `src/spectral_physics/cli.py`

- [ ] –ò—Å–ø—Ä–∞–≤–∏—Ç—å `pyproject.toml`:
  - –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –±–ª–æ–∫ `[project]` —Å:
    - `name`, `version`, `description`, `readme`, `requires-python`;
    - `dependencies = ["numpy", "scipy", "matplotlib", "pyyaml"]` –∏ —Ç.–ø.
  - —Ä–∞–±–æ—á–∏–π `[project.scripts]`:
    ```toml
    [project.scripts]
    spectral-health = "spectral_physics.cli:main"
    ```

- [ ] –ü–æ–ø—Ä–∞–≤–∏—Ç—å –∏–º–ø–æ—Ä—Ç `HealthProfile` –≤ `cli.py`:
  - –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å `HealthProfile` –∏–∑ `spectral_physics.material`.

- [ ] –ü—Ä–æ—á–∏—Å—Ç–∏—Ç—å `README.md`:
  - —É–±—Ä–∞—Ç—å –¥—É–±–ª–∏—Ä—É—é—â–∏–π—Å—è –∫—É—Å–æ–∫ —Ç–µ–∫—Å—Ç–∞;
  - –¥–æ–±–∞–≤–∏—Ç—å —Ä–∞–∑–¥–µ–ª:
    ```markdown
    ## Installation

    ```bash
    pip install -e .
    spectral-health --help
    ```
    ```

---

## –≠–¢–ê–ü 21. YAML-–∫–æ–Ω—Ñ–∏–≥–∏ –∏ –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–æ–Ω–Ω—ã–π pipeline

**–ù–æ–≤—ã–µ —Ñ–∞–π–ª—ã:**
- `configs/pump_train.yaml`
- `configs/pump_score.yaml`
- `configs/pump_thresholds.yaml`
- `examples/generate_synthetic_pump_data.py`

### 21.1. –ü—Ä–∏–º–µ—Ä –∫–æ–Ω—Ñ–∏–≥–æ–≤

- [ ] –°–æ–∑–¥–∞—Ç—å –ø–∞–ø–∫—É `configs/`.

- [ ] `configs/pump_train.yaml` ‚Äî –ø—Ä–∏–º–µ—Ä –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –¥–ª—è –æ–±—É—á–µ–Ω–∏—è:

  ```yaml
  dt: 0.001          # —à–∞–≥ –¥–∏—Å–∫—Ä–µ—Ç–∏–∑–∞—Ü–∏–∏
  window: hann

  channels:
    motor_vibration:
      column: 1
      freq_min: 0.0
      freq_max: 500.0
      files:
        - data/pump/train_motor_1.csv
        - data/pump/train_motor_2.csv

    pump_vibration:
      column: 2
      freq_min: 0.0
      freq_max: 500.0
      files:
        - data/pump/train_pump_1.csv
        - data/pump/train_pump_2.csv
  ```

- [ ] `configs/pump_score.yaml` ‚Äî –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ, –Ω–æ –¥–ª—è **—Ç–µ–∫—É—â–µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è**:

  ```yaml
  dt: 0.001
  window: hann

  channels:
    motor_vibration:
      column: 1
      freq_min: 0.0
      freq_max: 500.0
      files:
        - data/pump/current_motor.csv

    pump_vibration:
      column: 2
      freq_min: 0.0
      freq_max: 500.0
      files:
        - data/pump/current_pump.csv
  ```

- [ ] `configs/pump_thresholds.yaml` ‚Äî –ø–æ—Ä–æ–≥–∏:

  ```yaml
  motor_vibration: 0.15
  pump_vibration: 0.20
  ```

### 21.2. –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö

**–§–∞–π–ª:** `examples/generate_synthetic_pump_data.py`

- [ ] –ù–∞–ø–∏—Å–∞—Ç—å —Å–∫—Ä–∏–ø—Ç, –∫–æ—Ç–æ—Ä—ã–π:

  * —Å–æ–∑–¥–∞—ë—Ç –ø–∞–ø–∫—É `data/pump/`;
  * –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ—á–Ω—ã–µ CSV:

    * `train_motor_1.csv`, `train_motor_2.csv`;
    * `train_pump_1.csv`, `train_pump_2.csv`;
  * –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç "—Ç–µ–∫—É—â–∏–µ" CSV:

    * `current_motor.csv` (–Ω–æ—Ä–º–∞–ª—å–Ω—ã–π);
    * `current_pump.csv` (—Å –∞–Ω–æ–º–∞–ª–∏–µ–π: –¥–æ–±–∞–≤–ª–µ–Ω –Ω–æ–≤—ã–π –ø–∏–∫, —à—É–º –∏–ª–∏ –¥—Ä–µ–π—Ñ).

- [ ] –§–æ—Ä–º–∞—Ç CSV:

  ```text
  time, motor_vibration, pump_vibration
  0.000, ...
  0.001, ...
  ...
  ```

  * –ø–µ—Ä–≤–∞—è —Å—Ç—Ä–æ–∫–∞ ‚Äî –∑–∞–≥–æ–ª–æ–≤–æ–∫;
  * —Å—Ç–æ–ª–±–µ—Ü 1 ‚Äî –≤—Ä–µ–º—è, —Å—Ç–æ–ª–±–µ—Ü 2 ‚Äî –º–æ—Ç–æ—Ä, —Å—Ç–æ–ª–±–µ—Ü 3 ‚Äî –Ω–∞—Å–æ—Å.

- [ ] –í–Ω—É—Ç—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å `numpy` –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å–∏–≥–Ω–∞–ª–æ–≤:

  * Healthy: —Å—É–º–º–∞ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Å–∏–Ω—É—Å–æ–≤ + –Ω–µ–º–Ω–æ–≥–æ —à—É–º–∞;
  * Anomaly: —É—Å–∏–ª–µ–Ω–Ω—ã–π –æ–¥–∏–Ω –∏–∑ –ø–∏–∫–æ–≤ + –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π —à—É–º.

---

## –≠–¢–ê–ü 22. –£–º–Ω—ã–π health-–ø—Ä–æ—Ñ–∏–ª—å —Å —Ñ–∏—á–∞–º–∏ (band-power + —ç–Ω—Ç—Ä–æ–ø–∏—è)

–°–µ–π—á–∞—Å `MaterialSignature.distance_l2` —Å—Ä–∞–≤–Ω–∏–≤–∞–µ—Ç **–Ω–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å–ø–µ–∫—Ç—Ä—ã —Ü–µ–ª–∏–∫–æ–º** 

–•–æ—á–µ—Ç—Å—è –¥–æ–±–∞–≤–∏—Ç—å –µ—â—ë –æ–¥–∏–Ω —É—Ä–æ–≤–µ–Ω—å: —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø–æ –Ω–∞–±–æ—Ä—É —Ñ–∏—á.

**–§–∞–π–ª—ã:** `src/spectral_physics/material.py`, `src/spectral_physics/diagnostics.py`, `tests/test_material.py`, `tests/test_diagnostics.py`

### 22.1. –í–µ–∫—Ç–æ—Ä —Ñ–∏—á –ø–æ —Å–ø–µ–∫—Ç—Ä—É

- [ ] –î–æ–±–∞–≤–∏—Ç—å –≤ `diagnostics.py` —Ñ—É–Ω–∫—Ü–∏—é:

  ```python
  import numpy as np
  from .spectrum import Spectrum1D
  from .diagnostics import spectral_band_power, spectral_entropy

  def extract_features(
      spectrum: Spectrum1D,
      bands_hz: list[tuple[float, float]],
  ) -> np.ndarray:
      """
      –ü–æ—Å—Ç—Ä–æ–∏—Ç—å –≤–µ–∫—Ç–æ—Ä —Ñ–∏—á:
      [ band_power_1, ..., band_power_N, spectral_entropy ]
      """
      features = []
      for fmin, fmax in bands_hz:
          features.append(spectral_band_power(spectrum, fmin, fmax))
      features.append(spectral_entropy(spectrum))
      return np.asarray(features, dtype=float)
  ```

- [ ] –î–æ–±–∞–≤–∏—Ç—å —Ç–µ—Å—Ç –≤ `tests/test_diagnostics.py`:

  * —Å–æ–∑–¥–∞—Ç—å –ø—Ä–æ—Å—Ç–æ–π —Å–ø–µ–∫—Ç—Ä —Å –¥–≤—É–º—è —á–∞—Å—Ç–æ—Ç–∞–º–∏;
  * –ø—Ä–æ–≤–µ—Ä–∏—Ç—å, —á—Ç–æ `extract_features` –¥–∞—ë—Ç –æ–∂–∏–¥–∞–µ–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è band power;
  * –ø—Ä–æ–≤–µ—Ä–∏—Ç—å, —á—Ç–æ —Ä–∞–∑–º–µ—Ä–Ω–æ—Å—Ç—å –≤–µ–∫—Ç–æ—Ä–∞ = `len(bands) + 1`.

### 22.2. –§–∏—á–µ–≤–∞—è —Å–∏–≥–Ω–∞—Ç—É—Ä–∞ –º–∞—Ç–µ—Ä–∏–∞–ª–∞

- [ ] –í `material.py` –¥–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—ã–π dataclass:

  ```python
  @dataclass
  class FeatureSignature:
      """
      –°–ø–µ–∫—Ç—Ä–∞–ª—å–Ω–∞—è —Å–∏–≥–Ω–∞—Ç—É—Ä–∞ –Ω–∞ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ —Ñ–∏—á.
      """
      reference_features: np.ndarray

      def distance_l2(self, other_features: np.ndarray) -> float:
          if other_features.shape != self.reference_features.shape:
              raise ValueError("Feature vector shape mismatch")
          diff = self.reference_features - other_features
          return float(np.sqrt(np.sum(diff**2)))
  ```

- [ ] –î–æ–±–∞–≤–∏—Ç—å —Ç–µ—Å—Ç—ã –≤ `tests/test_material.py`:

  * `test_feature_signature_zero_distance_for_identical`;
  * `test_feature_signature_shape_mismatch_raises`.

### 22.3. HealthProfile —Å –¥–≤—É–º—è —É—Ä–æ–≤–Ω—è–º–∏

- [ ] –û–±–Ω–æ–≤–∏—Ç—å `HealthProfile` —Ç–∞–∫, —á—Ç–æ–±—ã –æ–Ω –º–æ–≥ —Ö—Ä–∞–Ω–∏—Ç—å **–æ–±–∞ —Ç–∏–ø–∞** —Å–∏–≥–Ω–∞—Ç—É—Ä:

  ```python
  @dataclass
  class HealthProfile:
      signatures: dict[str, MaterialSignature]
      feature_signatures: dict[str, FeatureSignature] | None = None
  ```

- [ ] –î–æ–±–∞–≤–∏—Ç—å –º–µ—Ç–æ–¥:

  ```python
  def score_features(
      self,
      current: dict[str, Spectrum1D],
      bands_hz: dict[str, list[tuple[float, float]]],
  ) -> dict[str, float]:
      """
      –î–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–∞–Ω–∞–ª–∞:
      - –∏–∑–≤–ª–µ—á—å —Ñ–∏—á–∏,
      - –ø–æ—Å—á–∏—Ç–∞—Ç—å L2-–¥–∏—Å—Ç–∞–Ω—Ü–∏—é –≤ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ —Ñ–∏—á.
      """
  ```

- [ ] –î–æ–±–∞–≤–∏—Ç—å —Ç–µ—Å—Ç –≤ `tests/test_material.py`, –∫–æ—Ç–æ—Ä—ã–π:

  * —Å—Ç—Ä–æ–∏—Ç –ø—Ä–æ—Å—Ç—ã–µ —Å–ø–µ–∫—Ç—Ä—ã;
  * —Å–æ–∑–¥–∞—ë—Ç `FeatureSignature`;
  * –ø—Ä–æ–≤–µ—Ä—è–µ—Ç, —á—Ç–æ `score_features` –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Å–ª–æ–≤–∞—Ä—å.

---

## –≠–¢–ê–ü 23. –ü–æ–ª–Ω—ã–π –¥–µ–º–æ-–∫–µ–π—Å: –æ—Ç –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö –¥–æ –æ—Ç—á—ë—Ç–∞

**–¶–µ–ª—å:** –û–¥–∏–Ω —Å—Ü–µ–Ω–∞—Ä–∏–π, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–Ω–æ –æ–ø–∏—Å–∞—Ç—å –≤ README: *¬´–∑–∞–ø—É—Å—Ç–∏ —ç—Ç–∏ –∫–æ–º–∞–Ω–¥—ã ‚Äî –∏ –ø–æ–ª—É—á–∏—à—å –æ—Ç—á—ë—Ç –æ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–≥–æ –Ω–∞—Å–æ—Å–∞¬ª.*

**–§–∞–π–ª—ã:** `README.md`, `examples/health_monitor_demo.ipynb`, –≤–æ–∑–º–æ–∂–Ω–æ –Ω–æ–≤—ã–π `examples/pump_health_demo.ipynb`.

- [ ] –û–±–Ω–æ–≤–∏—Ç—å –∏–ª–∏ —Å–æ–∑–¥–∞—Ç—å –Ω–æ—É—Ç–±—É–∫ `examples/health_monitor_demo.ipynb` —Ç–∞–∫, —á—Ç–æ–±—ã –æ–Ω –¥–µ–ª–∞–ª:

  1. `!python examples/generate_synthetic_pump_data.py`
  2. `!spectral-health train --config configs/pump_train.yaml --out data/pump/profile.npz`
  3. `!spectral-health score --config configs/pump_score.yaml --profile data/pump/profile.npz --thresholds configs/pump_thresholds.yaml --report data/pump/report.md`
  4. –í –∫–æ–Ω—Ü–µ –Ω–æ—É—Ç–±—É–∫–∞ –æ—Ç–∫—Ä—ã—Ç—å –∏ –ø–æ–∫–∞–∑–∞—Ç—å `report.md`.

- [ ] –î–æ–ø–æ–ª–Ω–∏—Ç—å `README.md` —Ä–∞–∑–¥–µ–ª–æ–º **"Quick start: Pump demo"**:

  ```markdown
  ## Quick start: Pump health demo

  ```bash
  pip install -e .

  # 1. –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ
  python examples/generate_synthetic_pump_data.py

  # 2. –û–±—É—á–∏—Ç—å –ø—Ä–æ—Ñ–∏–ª—å "–∑–¥–æ—Ä–æ–≤–æ–≥–æ" —Å–æ—Å—Ç–æ—è–Ω–∏—è
  spectral-health train \
    --config configs/pump_train.yaml \
    --out data/pump/profile.npz

  # 3. –û—Ü–µ–Ω–∏—Ç—å —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏ –ø–æ–ª—É—á–∏—Ç—å –æ—Ç—á—ë—Ç
  spectral-health score \
    --config configs/pump_score.yaml \
    --profile data/pump/profile.npz \
    --thresholds configs/pump_thresholds.yaml \
    --report data/pump/report.md
  ```
  ```

- [ ] –£–±–µ–¥–∏—Ç—å—Å—è, —á—Ç–æ –≤ –æ—Ç—á—ë—Ç–µ –µ—Å—Ç—å –∫–∞–∫ –º–∏–Ω–∏–º—É–º:

  * —Ç–∞–±–ª–∏—Ü–∞ —Å –∫–∞–Ω–∞–ª–∞–º–∏, distance, threshold, —Å—Ç–∞—Ç—É—Å–æ–º (—É–∂–µ –¥–µ–ª–∞–µ—Ç `generate_markdown_report`) 
  * –ø–æ–Ω—è—Ç–Ω—ã–π —Ç–µ–∫—Å—Ç: "All systems nominal" –∏–ª–∏ "Anomalies detected!"



================================================================================
–§–ê–ô–õ: configs\pump_score.yaml
================================================================================

dt: 0.001
window: hann

channels:
  motor_vibration:
    column: 1
    freq_min: 0.0
    freq_max: 500.0
    files:
      - data/pump/current_motor.csv

  pump_vibration:
    column: 2
    freq_min: 0.0
    freq_max: 500.0
    files:
      - data/pump/current_pump.csv



================================================================================
–§–ê–ô–õ: configs\pump_thresholds.yaml
================================================================================

motor_vibration: 0.15
pump_vibration: 0.20



================================================================================
–§–ê–ô–õ: configs\pump_train.yaml
================================================================================

dt: 0.001          # —à–∞–≥ –¥–∏—Å–∫—Ä–µ—Ç–∏–∑–∞—Ü–∏–∏
window: hann

channels:
  motor_vibration:
    column: 1
    freq_min: 0.0
    freq_max: 500.0
    files:
      - data/pump/train_motor_1.csv
      - data/pump/train_motor_2.csv

  pump_vibration:
    column: 2
    freq_min: 0.0
    freq_max: 500.0
    files:
      - data/pump/train_pump_1.csv
      - data/pump/train_pump_2.csv



================================================================================
–§–ê–ô–õ: data\pump\report.md
================================================================================

# Spectral Health Report

**Date:** 2025-11-30 15:11:37

## Channel Status

| Channel | Distance | Threshold | Status |
|---------|----------|-----------|--------|
| `motor_vibration` | 0.003497 | 0.150000 | üü¢ OK |
| `pump_vibration` | 0.244686 | 0.200000 | üî¥ **ANOMALY** |

> [!WARNING]
> Anomalies detected! Please check the affected channels.


================================================================================
–§–ê–ô–õ: examples\atomic_valence_demo.py
================================================================================

"""
Atomic Valence as Surface Resonances

This demo explores the idea that chemical valence can be modeled as "spectral compatibility" 
between resonators. We use toy models of atoms (H, O, C) defined by their resonance frequencies.
"""

import numpy as np
import matplotlib.pyplot as plt
from spectral_physics.atoms import H, O, C, spectral_overlap, can_form_bond

def plot_atom_spectra(atom1, atom2):
    fig, ax = plt.subplots(figsize=(10, 4))
    
    # Plot lines for Atom 1
    ax.vlines(atom1.omega, 0, atom1.power, colors='blue', label=f'{atom1.name} lines', lw=2)
    
    # Plot lines for Atom 2
    ax.vlines(atom2.omega, 0, atom2.power, colors='red', label=f'{atom2.name} lines', lw=2, linestyle='--')
    
    ax.set_title(f"Spectral Comparison: {atom1.name} vs {atom2.name}")
    ax.set_xlabel("Frequency (arbitrary units)")
    ax.set_ylabel("Intensity")
    ax.legend()
    ax.grid(True, alpha=0.3)
    return fig

def main():
    print("=" * 60)
    print("Atomic Valence as Surface Resonances Demo")
    print("=" * 60)
    
    # 1. Hydrogen vs Oxygen (Water)
    print("\n1. Hydrogen vs Oxygen (Water)")
    print("-" * 40)
    print("Oxygen has multiple lines around 1.0, matching Hydrogen's single line at 1.0.")
    
    fig1 = plot_atom_spectra(H, O)
    
    overlap = spectral_overlap(H, O)
    print(f"Spectral Overlap (H-O): {overlap:.3f}")
    print(f"Can form bond? {can_form_bond(H, O, freq_tol=0.1, threshold=0.1)}")
    print(f"O max bonds: {O.max_bonds} -> Can hold two H atoms (H-O-H)")
    
    plt.show()
    
    # 2. Carbon vs Hydrogen (Methane)
    print("\n2. Carbon vs Hydrogen (Methane)")
    print("-" * 40)
    print("Carbon has a broader spectrum, overlapping well with Hydrogen.")
    
    fig2 = plot_atom_spectra(C, H)
    
    overlap = spectral_overlap(C, H)
    print(f"Spectral Overlap (C-H): {overlap:.3f}")
    print(f"C max bonds: {C.max_bonds} -> Can hold four H atoms (CH4)")
    
    plt.show()
    
    # 3. Carbon vs Oxygen (CO2)
    print("\n3. Carbon vs Oxygen (CO2)")
    print("-" * 40)
    print("Carbon and Oxygen also overlap significantly.")
    
    fig3 = plot_atom_spectra(C, O)
    
    overlap = spectral_overlap(C, O)
    print(f"Spectral Overlap (C-O): {overlap:.3f}")
    
    plt.show()
    
    print("\n" + "=" * 60)
    print("Conclusion: Valence emerges from spectral resonance compatibility!")
    print("=" * 60)

if __name__ == "__main__":
    main()



================================================================================
–§–ê–ô–õ: examples\generate_synthetic_pump_data.py
================================================================================

import numpy as np
import pandas as pd
from pathlib import Path

def generate_signal(t, freqs, amps, noise_level=0.1):
    signal = np.zeros_like(t)
    for f, a in zip(freqs, amps):
        signal += a * np.sin(2 * np.pi * f * t)
    noise = np.random.normal(0, noise_level, size=len(t))
    return signal + noise

def main():
    # Setup
    data_dir = Path("data/pump")
    data_dir.mkdir(parents=True, exist_ok=True)
    
    dt = 0.001
    duration = 10.0
    t = np.arange(0, duration, dt)
    
    print(f"Generating data in {data_dir}...")
    
    # Define "Healthy" characteristics
    # Motor: 50Hz (main), 100Hz (harmonic)
    motor_freqs = [50.0, 100.0]
    motor_amps = [1.0, 0.2]
    
    # Pump: 30Hz (vane pass), 60Hz
    pump_freqs = [30.0, 60.0]
    pump_amps = [0.8, 0.3]
    
    # 1. Generate Training Data (Healthy)
    # We generate slightly different variations for training
    
    # Train Motor 1
    m1 = generate_signal(t, motor_freqs, motor_amps, noise_level=0.1)
    p1 = generate_signal(t, pump_freqs, pump_amps, noise_level=0.1)
    df1 = pd.DataFrame({'time': t, 'motor_vibration': m1, 'pump_vibration': p1})
    df1.to_csv(data_dir / "train_motor_1.csv", index=False)
    # Note: We save the same file for pump training or different ones?
    # The config expects:
    # motor_vibration files: train_motor_1.csv, train_motor_2.csv
    # pump_vibration files: train_pump_1.csv, train_pump_2.csv
    # We can just reuse the same structure or make separate files if we want strictly separate sensors.
    # But the config implies we might have different files for different channels or same files.
    # Let's generate 4 files as requested by the config structure, 
    # but actually the config says:
    # motor: train_motor_1.csv, train_motor_2.csv
    # pump: train_pump_1.csv, train_pump_2.csv
    # So we should probably generate these 4 files.
    
    # Train Motor 2 (slight variation)
    m2 = generate_signal(t, motor_freqs, [a * 1.05 for a in motor_amps], noise_level=0.12)
    p2 = generate_signal(t, pump_freqs, [a * 0.95 for a in pump_amps], noise_level=0.11)
    df2 = pd.DataFrame({'time': t, 'motor_vibration': m2, 'pump_vibration': p2})
    df2.to_csv(data_dir / "train_motor_2.csv", index=False)
    
    # Train Pump 1 (can be same as motor 1 or different)
    # Let's make them distinct files to match the config exactly
    df1.to_csv(data_dir / "train_pump_1.csv", index=False)
    df2.to_csv(data_dir / "train_pump_2.csv", index=False)
    
    print("  Created training files.")
    
    # 2. Generate Current Data (Test)
    
    # Current Motor (Normal)
    m_curr = generate_signal(t, motor_freqs, [a * 1.02 for a in motor_amps], noise_level=0.1)
    p_curr_normal = generate_signal(t, pump_freqs, pump_amps, noise_level=0.1)
    df_curr_motor = pd.DataFrame({'time': t, 'motor_vibration': m_curr, 'pump_vibration': p_curr_normal})
    df_curr_motor.to_csv(data_dir / "current_motor.csv", index=False)
    
    # Current Pump (Anomaly!)
    # Add a new frequency component at 150Hz (bearing fault?) and increase noise
    m_anom = generate_signal(t, motor_freqs, motor_amps, noise_level=0.1)
    
    pump_freqs_anom = pump_freqs + [150.0]
    pump_amps_anom = pump_amps + [0.5] # Significant new peak
    p_anom = generate_signal(t, pump_freqs_anom, pump_amps_anom, noise_level=0.2) # Higher noise
    
    df_curr_pump = pd.DataFrame({'time': t, 'motor_vibration': m_anom, 'pump_vibration': p_anom})
    df_curr_pump.to_csv(data_dir / "current_pump.csv", index=False)
    
    print("  Created current status files (Motor: OK, Pump: ANOMALY).")
    print("Done.")

if __name__ == "__main__":
    main()



================================================================================
–§–ê–ô–õ: examples\geophysics_1d_demo.py
================================================================================

"""
1D Geophysics: Layered Earth & Inversion

This demo simulates a seismic pulse propagating through a layered medium.
We then solve a simple inverse problem: determining the thickness of the top layer 
from the surface response.
"""

import numpy as np
import matplotlib.pyplot as plt
from spectral_physics.geophysics_1d import (
    Layer, LayeredMedium1D, simulate_pulse_response, invert_single_layer_thickness
)

def main():
    print("=" * 60)
    print("1D Geophysics: Layered Earth & Inversion")
    print("=" * 60)
    
    # 1. Setup "True" Earth Model
    # Layer 1: Soft soil (low density/stiffness), unknown thickness
    true_h = 15.0
    layer1 = Layer(thickness=true_h, density=1.5, stiffness=2.0)
    
    # Layer 2: Hard rock (high density/stiffness), known properties
    layer2 = Layer(thickness=50.0, density=3.0, stiffness=10.0)
    
    medium_true = LayeredMedium1D(layers=[layer1, layer2], dx=0.5)
    
    print(f"\nTrue Model: Top layer thickness = {true_h}")
    
    # 2. Simulate Surface Response (The "Measurement")
    t_max = 50.0
    dt = 0.1
    
    print("\nSimulating seismic response...")
    t, signal_true = simulate_pulse_response(medium_true, t_max=t_max, dt=dt)
    
    plt.figure(figsize=(10, 4))
    plt.plot(t, signal_true, label='Observed Signal')
    plt.title("Seismic Response (Surface Displacement)")
    plt.xlabel("Time")
    plt.ylabel("Amplitude")
    plt.grid(True, alpha=0.3)
    plt.legend()
    plt.show()
    
    # 3. Solve Inverse Problem
    # We know density/stiffness of top layer, but not thickness.
    # We know the substrate (layer2).
    
    guess_h = 10.0
    print(f"\nStarting inversion with guess h = {guess_h}...")
    
    found_h = invert_single_layer_thickness(
        target_signal=signal_true,
        t=t,
        density=layer1.density,
        stiffness=layer1.stiffness,
        thickness_guess=guess_h,
        fixed_layers_below=[layer2],
        dx=0.5
    )
    
    print(f"Inversion Result: h = {found_h:.2f} (True: {true_h})")
    error = abs(found_h - true_h)
    print(f"Error: {error:.2f}")
    
    # 4. Verify Result
    # Simulate with found thickness
    print("\nVerifying result...")
    layer_found = Layer(thickness=found_h, density=layer1.density, stiffness=layer1.stiffness)
    medium_found = LayeredMedium1D(layers=[layer_found, layer2], dx=0.5)
    _, signal_found = simulate_pulse_response(medium_found, t_max=t_max, dt=dt)
    
    plt.figure(figsize=(10, 4))
    plt.plot(t, signal_true, 'k-', alpha=0.5, lw=3, label='Observed')
    plt.plot(t, signal_found, 'r--', label='Model (Inverted)')
    plt.title(f"Model Fit (h_found={found_h:.2f})")
    plt.xlabel("Time")
    plt.legend()
    plt.grid(True, alpha=0.3)
    plt.show()
    
    print("\n" + "=" * 60)
    print("Conclusion:")
    print("We successfully recovered the thickness of the top layer")
    print("by matching the seismic response.")
    print("This is a toy example of full-waveform inversion (FWI).")
    print("=" * 60)

if __name__ == "__main__":
    main()



================================================================================
–§–ê–ô–õ: examples\geophysics_health_demo.py
================================================================================

"""
Geophysics Health Monitoring

This demo applies health monitoring to geophysical data.
We assume a "healthy" baseline response (e.g., from a stable formation) 
and detect changes (e.g., fluid injection, subsidence).
"""

import numpy as np
import matplotlib.pyplot as plt
from spectral_physics.geophysics_1d import (
    Layer, LayeredMedium1D, simulate_pulse_response, build_geo1d_health_profile
)

def main():
    print("=" * 60)
    print("Geophysics Health Monitoring Demo")
    print("=" * 60)
    
    # 1. Baseline (Healthy) Model
    print("\nSetting up baseline (healthy) model...")
    l1 = Layer(thickness=15.0, density=1.5, stiffness=2.0)
    l2 = Layer(thickness=50.0, density=3.0, stiffness=10.0)
    medium_base = LayeredMedium1D(layers=[l1, l2], dx=0.5)
    
    t, sig_base = simulate_pulse_response(medium_base, t_max=50.0, dt=0.1)
    
    profile = build_geo1d_health_profile(sig_base)
    print("Baseline Features:", profile.reference_features)
    
    # 2. Changed Model (Anomaly)
    # Suppose the top layer becomes softer (e.g., water saturation)
    print("\nSimulating anomaly (softened top layer)...")
    l1_soft = Layer(thickness=15.0, density=1.4, stiffness=1.5)  # Stiffness dropped
    medium_anom = LayeredMedium1D(layers=[l1_soft, l2], dx=0.5)
    
    _, sig_anom = simulate_pulse_response(medium_anom, t_max=50.0, dt=0.1)
    
    current_sig = build_geo1d_health_profile(sig_anom)
    
    distance = profile.distance_l2(current_sig.reference_features)
    print(f"\nHealth Distance: {distance:.4f}")
    
    # 3. Threshold check
    threshold = 50.0  # Arbitrary threshold
    print(f"Threshold: {threshold}")
    
    if distance > threshold:
        print("Status: ‚ö†Ô∏è  ANOMALY DETECTED (Formation Change)")
    else:
        print("Status: ‚úì OK")
    
    # 4. Visualization
    plt.figure(figsize=(10, 4))
    plt.plot(t, sig_base, label='Baseline')
    plt.plot(t, sig_anom, label='Anomaly (Soft Layer)')
    plt.title(f"Seismic Response Change (Dist={distance:.2f})")
    plt.xlabel("Time")
    plt.ylabel("Amplitude")
    plt.legend()
    plt.grid(True, alpha=0.3)
    plt.show()
    
    print("\n" + "=" * 60)
    print("Conclusion: Formation change detected via health monitoring!")
    print("=" * 60)

if __name__ == "__main__":
    main()



================================================================================
–§–ê–ô–õ: examples\health_monitor_demo.py
================================================================================

"""
Health Monitor Demo (Pump Monitoring)

This script demonstrates the end-to-end spectral-health pipeline:
1. Generate synthetic pump vibration data
2. Train a health profile
3. Score current data
4. Display the generated report
"""

import subprocess
import sys
from pathlib import Path

def main():
    print("=" * 60)
    print("Pump Health Monitoring Demo")
    print("=" * 60)
    
    # Get project root
    project_root = Path(__file__).parent.parent
    
    # 1. Generate synthetic data
    print("\n[Step 1/3] Generating synthetic pump data...")
    result = subprocess.run(
        [sys.executable, str(project_root / "examples" / "generate_synthetic_pump_data.py")],
        capture_output=True,
        text=True
    )
    if result.returncode != 0:
        print("Error:", result.stderr)
        return
    print("‚úì Data generated")
    
    # 2. Train health profile
    print("\n[Step 2/3] Training health profile...")
    result = subprocess.run(
        [
            "spectral-health", "train",
            "--config", str(project_root / "configs" / "pump_train.yaml"),
            "--out", str(project_root / "data" / "pump" / "profile.npz")
        ],
        capture_output=True,
        text=True,
        cwd=str(project_root)
    )
    if result.returncode != 0:
        print("Error:", result.stderr)
        return
    print("‚úì Profile trained")
    
    # 3. Score current data
    print("\n[Step 3/3] Scoring current data and generating report...")
    result = subprocess.run(
        [
            "spectral-health", "score",
            "--config", str(project_root / "configs" / "pump_score.yaml"),
            "--profile", str(project_root / "data" / "pump" / "profile.npz"),
            "--thresholds", str(project_root / "configs" / "pump_thresholds.yaml"),
            "--report", str(project_root / "data" / "pump" / "report.md")
        ],
        capture_output=True,
        text=True,
        cwd=str(project_root)
    )
    if result.returncode != 0:
        print("Error:", result.stderr)
        return
    print("‚úì Report generated")
    
    # 4. Display report
    print("\n" + "=" * 60)
    print("HEALTH REPORT:")
    print("=" * 60)
    report_path = project_root / "data" / "pump" / "report.md"
    if report_path.exists():
        print(report_path.read_text())
    else:
        print("Report not found!")
    
    print("\n" + "=" * 60)
    print("Demo completed successfully!")
    print("=" * 60)

if __name__ == "__main__":
    main()



================================================================================
–§–ê–ô–õ: examples\material_defect_demo.py
================================================================================

"""
Material Defect Demo: LDOS Anomalies

This script demonstrates how a local defect (change in mass or stiffness) affects 
the Local Spectral Density (LDOS) of a 2D medium.
We compare a "pristine" plate with a "defective" one.
"""

import numpy as np
import matplotlib.pyplot as plt
from spectral_physics.medium_2d import OscillatorGrid2D

def main():
    print("=" * 60)
    print("Material Defect Demo: LDOS Anomalies")
    print("=" * 60)
    
    # 1. Setup Pristine Grid
    nx, ny = 20, 20
    grid_clean = OscillatorGrid2D(nx=nx, ny=ny, kx=1.0, ky=1.0, m=1.0)
    
    # Calculate LDOS map in a low-frequency window
    freq_window = (0.0, 1.5)
    n_modes = 50  # Calculate enough modes to cover the window
    
    print("\nCalculating LDOS for pristine grid...")
    ldos_clean = grid_clean.ldos_map(n_modes=n_modes, freq_window=freq_window)
    
    # 2. Setup Defective Grid
    # Defect: Heavy mass in the center (3x3 block)
    mass_map = np.ones((ny, nx))
    cx, cy = nx // 2, ny // 2
    mass_map[cy-1:cy+2, cx-1:cx+2] = 5.0  # 5x heavier
    
    grid_defect = OscillatorGrid2D(nx=nx, ny=ny, kx=1.0, ky=1.0, m=1.0, mass_map=mass_map)
    
    print("Calculating LDOS for defective grid...")
    ldos_defect = grid_defect.ldos_map(n_modes=n_modes, freq_window=freq_window)
    
    # 3. Visualize Comparison
    fig, axes = plt.subplots(1, 3, figsize=(18, 5))
    
    vmin = min(ldos_clean.min(), ldos_defect.min())
    vmax = max(ldos_clean.max(), ldos_defect.max())
    
    im0 = axes[0].imshow(ldos_clean, origin='lower', cmap='inferno', vmin=vmin, vmax=vmax)
    axes[0].set_title("Pristine LDOS")
    plt.colorbar(im0, ax=axes[0])
    
    im1 = axes[1].imshow(ldos_defect, origin='lower', cmap='inferno', vmin=vmin, vmax=vmax)
    axes[1].set_title("Defective LDOS (Heavy Center)")
    plt.colorbar(im1, ax=axes[1])
    
    # Difference
    diff = ldos_defect - ldos_clean
    im2 = axes[2].imshow(diff, origin='lower', cmap='RdBu_r')
    axes[2].set_title("Difference (Defect - Clean)")
    plt.colorbar(im2, ax=axes[2])
    
    plt.tight_layout()
    plt.show()
    
    print("\n" + "=" * 60)
    print("Interpretation:")
    print("The heavy defect changes the local spectral density.")
    print("In the low-frequency window, the heavy mass might accumulate")
    print("more energy (or less, depending on the modes shifted).")
    print("The difference map clearly highlights the location of the anomaly.")
    print("=" * 60)

if __name__ == "__main__":
    main()



================================================================================
–§–ê–ô–õ: examples\material_health_demo.py
================================================================================

"""
Material Health Monitoring

This demo shows how to use spectral-health concepts for materials.
We treat the LDOS map as the "state" of the material and detect defects 
as deviations from a healthy profile.
"""

import numpy as np
import matplotlib.pyplot as plt
from spectral_physics.medium_2d import OscillatorGrid2D
from spectral_physics.materials import build_material_health_profile

def main():
    print("=" * 60)
    print("Material Health Monitoring Demo")
    print("=" * 60)
    
    # 1. Train Healthy Profile
    # Create a pristine grid
    nx, ny = 20, 20
    grid_clean = OscillatorGrid2D(nx=nx, ny=ny, kx=1.0, ky=1.0, m=1.0)
    
    print("\nCalculating healthy LDOS...")
    # Calculate LDOS
    ldos_clean = grid_clean.ldos_map(n_modes=50, freq_window=(0.0, 1.5))
    
    # Build profile
    profile = build_material_health_profile(ldos_clean)
    print("Healthy Profile Features:", profile.reference_features)
    
    # 2. Test Defective Material
    # Create grid with defect
    print("\nCreating defective material (heavy spot)...")
    mass_map = np.ones((ny, nx))
    cx, cy = nx // 2, ny // 2
    mass_map[cy-1:cy+2, cx-1:cx+2] = 5.0  # Heavy spot
    
    grid_defect = OscillatorGrid2D(nx=nx, ny=ny, kx=1.0, ky=1.0, m=1.0, mass_map=mass_map)
    ldos_defect = grid_defect.ldos_map(n_modes=50, freq_window=(0.0, 1.5))
    
    # Build "current" features (using same logic as profile builder)
    current_sig = build_material_health_profile(ldos_defect)
    
    # Calculate distance
    distance = profile.distance_l2(current_sig.reference_features)
    print(f"\nHealth Distance: {distance:.4f}")
    
    # 3. Threshold Check
    threshold = 1.0  # Arbitrary threshold
    print(f"Threshold: {threshold}")
    
    if distance > threshold:
        print("Status: ‚ö†Ô∏è  ANOMALY DETECTED (Material Defect)")
    else:
        print("Status: ‚úì OK")
    
    # 4. Visualize
    fig, axes = plt.subplots(1, 2, figsize=(12, 5))
    
    im0 = axes[0].imshow(ldos_clean, origin='lower', cmap='inferno')
    axes[0].set_title("Healthy Material")
    plt.colorbar(im0, ax=axes[0])
    
    im1 = axes[1].imshow(ldos_defect, origin='lower', cmap='inferno')
    axes[1].set_title(f"Defective Material (Dist={distance:.2f})")
    plt.colorbar(im1, ax=axes[1])
    
    plt.tight_layout()
    plt.show()
    
    print("\n" + "=" * 60)
    print("Conclusion: Defect automatically detected via health distance!")
    print("=" * 60)

if __name__ == "__main__":
    main()



================================================================================
–§–ê–ô–õ: examples\medium_2d_modes_demo.py
================================================================================

"""
2D Medium Modes Demo

This script visualizes the eigenmodes (standing waves) of a 2D oscillator grid (elastic plate).
We use OscillatorGrid2D to calculate the modes and matplotlib to display them.
"""

import numpy as np
import matplotlib.pyplot as plt
from spectral_physics.medium_2d import OscillatorGrid2D

def main():
    # 1. Create a 2D Grid
    nx, ny = 20, 20
    grid = OscillatorGrid2D(nx=nx, ny=ny, kx=1.0, ky=1.0, m=1.0)
    
    print(f"Grid size: {nx}x{ny} = {nx*ny} oscillators")
    
    # 2. Calculate Eigenmodes
    n_modes = 9
    print(f"Calculating first {n_modes} modes...")
    omega, modes = grid.eigenmodes(n_modes=n_modes)
    
    print("Frequencies:", omega)
    
    # 3. Visualize Modes
    fig, axes = plt.subplots(3, 3, figsize=(12, 12))
    axes = axes.flatten()
    
    for i in range(n_modes):
        ax = axes[i]
        
        # Extract mode vector and reshape to 2D grid
        mode_vec = modes[:, i]
        mode_grid = mode_vec.reshape((ny, nx))
        
        # Plot
        im = ax.imshow(mode_grid, cmap='RdBu', origin='lower', interpolation='bicubic')
        ax.set_title(f"Mode {i+1}: $\\omega$ = {omega[i]:.3f}")
        plt.colorbar(im, ax=ax, fraction=0.046, pad=0.04)
    
    plt.tight_layout()
    plt.suptitle("2D Medium Eigenmodes", y=1.001)
    plt.show()
    
    print("\nThese patterns represent the fundamental resonances of the medium.")
    print("In a 'spectral physics' context, these are the available 'slots' for energy to occupy.")

if __name__ == "__main__":
    main()



================================================================================
–§–ê–ô–õ: PROJECT_CODE.txt
================================================================================




================================================================================
–§–ê–ô–õ: pyproject.toml
================================================================================

[build-system]
requires = ["setuptools>=61.0"]
build-backend = "setuptools.build_meta"

[project]
name = "spectral-physics-lab"
version = "0.1.0"
description = "Experimental spectral physics toolkit for diagnostics and anomaly detection"
readme = "README.md"
requires-python = ">=3.11"
authors = [
  { name = "Robert Paulig" },
]
dependencies = [
  "numpy>=1.25",
  "scipy>=1.11",
  "matplotlib>=3.7",
  "pyyaml>=6.0",
]

[project.scripts]
spectral-health = "spectral_physics.cli:main"

[tool.setuptools.packages.find]
where = ["src"]

[tool.setuptools.package-data]
spectral_physics = ["py.typed"]



================================================================================
–§–ê–ô–õ: README.md
================================================================================

# SpectralPhysics-Lab

**SpectralPhysics-Lab** ‚Äî —ç—Ç–æ —ç–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç–∞–ª—å–Ω—ã–π –∫–æ–¥–æ–≤—ã–π —Å—Ç–µ–Ω–¥ –¥–ª—è –Ω–æ–≤–æ–π "—Å–ø–µ–∫—Ç—Ä–∞–ª—å–Ω–æ–π —Ñ–∏–∑–∏–∫–∏":

- –í–º–µ—Å—Ç–æ —à–∞—Ä–∏–∫–æ–≤ –∏ —Å–∏–ª: **–°—Ä–µ–¥–∞** –∏ **–∫–æ–ª–µ–±–∞—Ç–µ–ª—å–Ω—ã–µ —Ä–µ–∂–∏–º—ã** (–º–æ–¥—ã).
- –í–º–µ—Å—Ç–æ "–º–∞—Å—Å–∞ —Ç—è–Ω–µ—Ç –º–∞—Å—Å—É": **—Å–ø–µ–∫—Ç—Ä–∞–ª—å–Ω–∞—è —Ç–µ–Ω—å** –∏ **–¥–∞–≤–ª–µ–Ω–∏–µ —Ñ–æ–Ω–æ–≤–æ–≥–æ –ø–æ–ª—è**.
- –í–º–µ—Å—Ç–æ –º–∞–≥–∏–∏ –∫–≤–∞–Ω—Ç–æ–≤–æ–π –º–µ—Ö–∞–Ω–∏–∫–∏: **—É—Å—Ç–æ–π—á–∏–≤—ã–µ —Ä–µ–∑–æ–Ω–∞—Ç–æ—Ä—ã** (—Å–æ–ª–∏—Ç–æ–Ω—ã) –≤ –µ–¥–∏–Ω–æ–π –°—Ä–µ–¥–µ.

–¶–µ–ª—å —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è ‚Äî —Å–æ–±—Ä–∞—Ç—å **—Ä–∞–±–æ—á–∏–π –Ω–∞–±–æ—Ä –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤**, —Å –∫–æ—Ç–æ—Ä—ã–º –º–æ–∂–Ω–æ:

- –º–æ–¥–µ–ª–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–æ—Å—Ç–µ–π—à–∏–µ "—Å—Ä–µ–¥—ã" –∏ —Å–æ–ª–∏—Ç–æ–Ω—ã;
- —Å—á–∏—Ç–∞—Ç—å —Å–ø–µ–∫—Ç—Ä—ã (—á–∞—Å—Ç–æ—Ç–Ω—ã–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è, –ª–æ–∫–∞–ª—å–Ω—É—é –ø–ª–æ—Ç–Ω–æ—Å—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–π);
- –∏–≥—Ä–∞—Ç—å—Å—è —Å "–º–∞—Å–∫–æ–π" (—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–∞—è –º–∞—Å—Å–∞, –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏—è, –≤–∞–ª–µ–Ω—Ç–Ω–æ—Å—Ç—å) –∫–∞–∫ —Å **—Å–ø–µ–∫—Ç—Ä–∞–ª—å–Ω—ã–º–∏ –æ–±—ä–µ–∫—Ç–∞–º–∏**;
- –≥–æ—Ç–æ–≤–∏—Ç—å –æ—Å–Ω–æ–≤—É –¥–ª—è –ø—Ä–∏–∫–ª–∞–¥–Ω—ã—Ö –∑–∞–¥–∞—á (–¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ –º–∞—à–∏–Ω, –≥–µ–æ—Ñ–∏–∑–∏–∫–∞, —Ç.–¥.).

> –í–∞–∂–Ω–æ: —ç—Ç–æ –Ω–µ "–∫—Ä–∞—Å–∏–≤–∞—è —Ç–µ–æ—Ä–∏—è –Ω–∞ –±—É–º–∞–≥–µ", –∞ –ø–µ—Å–æ—á–Ω–∏—Ü–∞,
> –≥–¥–µ –ª—é–±–∞—è –∏–¥–µ—è –¥–æ–ª–∂–Ω–∞ –¥–æ–ø–æ–ª–∑—Ç–∏ –¥–æ **—Ä–∞–±–æ—Ç–∞—é—â–µ–≥–æ –∫–æ–¥–∞ / —ç–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç–∞**.

---

## Installation

```bash
pip install -e .
spectral-health --help
```

---

## Quick start: Pump health demo

```bash
# 1. –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ
python examples/generate_synthetic_pump_data.py

# 2. –û–±—É—á–∏—Ç—å –ø—Ä–æ—Ñ–∏–ª—å "–∑–¥–æ—Ä–æ–≤–æ–≥–æ" —Å–æ—Å—Ç–æ—è–Ω–∏—è
spectral-health train \
  --config configs/pump_train.yaml \
  --out data/pump/profile.npz

# 3. –û—Ü–µ–Ω–∏—Ç—å —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏ –ø–æ–ª—É—á–∏—Ç—å –æ—Ç—á—ë—Ç
spectral-health score \
  --config configs/pump_score.yaml \
  --profile data/pump/profile.npz \
  --thresholds configs/pump_thresholds.yaml \
  --report data/pump/report.md
```

## 2D medium demo

–°–º–æ—Ç—Ä–∏—Ç–µ `examples/medium_2d_modes_demo.ipynb` ‚Äî —Ç–∞–º –≤–∏–¥–Ω–æ,
–∫–∞–∫ —É –ø–ª–∞—Å—Ç–∏–Ω—ã –ø–æ—è–≤–ª—è—é—Ç—Å—è –º–æ–¥—ã –∫–æ–ª–µ–±–∞–Ω–∏–π (—Å—Ç–æ—è—á–∏–µ –≤–æ–ª–Ω—ã).

## Atomic valence as surface resonances (toy model)

–°–º–æ—Ç—Ä–∏—Ç–µ `examples/atomic_valence_demo.ipynb`: —Ç–∞–º –ø–æ–∫–∞–∑–∞–Ω–æ,
–∫–∞–∫ –º–æ–∂–Ω–æ –¥—É–º–∞—Ç—å –ø—Ä–æ –≤–∞–ª–µ–Ω—Ç–Ω–æ—Å—Ç—å –∫–∞–∫ –ø—Ä–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–æ–≤–ø–∞–¥–∞—é—â–∏—Ö
—Ä–µ–∑–æ–Ω–∞–Ω—Å–Ω—ã—Ö —á–∞—Å—Ç–æ—Ç –º–µ–∂–¥—É "–∞—Ç–æ–º–∞–º–∏"-—Ä–µ–∑–æ–Ω–∞—Ç–æ—Ä–∞–º–∏.

---

## –¢–µ–∫—É—â–∏–π —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–π —Ñ–æ–∫—É—Å

1. **–ë–∞–∑–æ–≤–∞—è –º–∞—Ç–µ–º–∞—Ç–∏–∫–∞**  
   - –†–µ–∞–ª–∏–∑–∞—Ü–∏—è *—Å–∏–º–º–µ—Ç—Ä–∏—á–Ω–æ–≥–æ –º–µ—Ç–æ–¥–∞ –ù—å—é—Ç–æ–Ω–∞* –¥–ª—è –ø–æ–∏—Å–∫–∞ –∫–æ—Ä–Ω–µ–π –Ω–µ–ª–∏–Ω–µ–π–Ω—ã—Ö —É—Ä–∞–≤–Ω–µ–Ω–∏–π –∏ —Å–∏—Å—Ç–µ–º **–±–µ–∑ —è–≤–Ω—ã—Ö –ø—Ä–æ–∏–∑–≤–æ–¥–Ω—ã—Ö**.
   - –û–±—ë—Ä—Ç–∫–∏ –¥–ª—è —É—Å—Ç–æ–π—á–∏–≤–æ–≥–æ —Ä–µ—à–µ–Ω–∏—è –∑–∞–¥–∞—á "–ø–æ–¥–±–æ—Ä –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –º–æ–¥–µ–ª–∏ –ø–æ–¥ –¥–∞–Ω–Ω—ã–µ".

2. **–°–ø–µ–∫—Ç—Ä–∞–ª—å–Ω—ã–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏—è**
   - –ö–ª–∞—Å—Å—ã –¥–ª—è –æ–ø–∏—Å–∞–Ω–∏—è 1D-—Å–ø–µ–∫—Ç—Ä–æ–≤ (—á–∞—Å—Ç–æ—Ç—ã, –∞–º–ø–ª–∏—Ç—É–¥—ã, —Ñ–∞–∑—ã).
   - –ü—Ä–æ—Å—Ç–µ–π—à–∞—è –º–æ–¥–µ–ª—å *–ª–æ–∫–∞–ª—å–Ω–æ–π —Å–ø–µ–∫—Ç—Ä–∞–ª—å–Ω–æ–π –ø–ª–æ—Ç–Ω–æ—Å—Ç–∏* `rho_spec(x, œâ)` –≤ –¥–∏—Å–∫—Ä–µ—Ç–Ω–æ–º –≤–∏–¥–µ (—Å–µ—Ç–∫–∞ –ø–æ x –∏ –ø–æ —á–∞—Å—Ç–æ—Ç–µ).

3. **–ü—Ä–æ—Å—Ç—ã–µ —Ñ–∏–∑–∏—á–µ—Å–∫–∏–µ –∏–≥—Ä—É—à–∫–∏ (toy models)**
   - 1D-—Ü–µ–ø–æ—á–∫–∞ –æ—Å—Ü–∏–ª–ª—è—Ç–æ—Ä–æ–≤ (—É–ø—Ä—É–≥–∞—è –°—Ä–µ–¥–∞).
   - –°–ø–µ–∫—Ç—Ä–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –Ω–æ—Ä–º–∞–ª—å–Ω—ã—Ö –º–æ–¥ (–º–æ–¥—ã –∫–æ–ª–µ–±–∞–Ω–∏–π —Ü–µ–ø–æ—á–∫–∏).
   - –ü—Ä–æ—Å—Ç–µ–π—à–∞—è "–≥—Ä–∞–≤–∏—Ç–∞—Ü–∏–æ–Ω–Ω–∞—è" –º–æ–¥–µ–ª—å –∫–∞–∫ **–¥–∏—Å–±–∞–ª–∞–Ω—Å —Å–ø–µ–∫—Ç—Ä–∞**: –≤–ª–∏—è–Ω–∏–µ "–ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏" –º–∞—Ç–µ—Ä–∏–∞–ª–∞ –Ω–∞ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–µ "—É—Å–∫–æ—Ä–µ–Ω–∏–µ".

---

## –ü–ª–∞–Ω–∏—Ä—É–µ–º–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è

```text
SpectralPhysics-Lab/
‚îú‚îÄ README.md                # —ç—Ç–æ—Ç —Ñ–∞–π–ª
‚îú‚îÄ AI_TASKS.md              # –∑–∞–¥–∞–Ω–∏—è –¥–ª—è –ò–ò-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞
‚îú‚îÄ pyproject.toml           # —É–ø–∞–∫–æ–≤–∫–∞ –ø—Ä–æ–µ–∫—Ç–∞ –∫–∞–∫ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏
‚îú‚îÄ src/
‚îÇ  ‚îî‚îÄ spectral_physics/
‚îÇ     ‚îú‚îÄ __init__.py
‚îÇ     ‚îú‚îÄ root_finding.py    # —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω—ã–π –ù—å—é—Ç–æ–Ω –∏ –æ–±—ë—Ä—Ç–∫–∏
‚îÇ     ‚îú‚îÄ spectrum.py        # –∫–ª–∞—Å—Å—ã —Å–ø–µ–∫—Ç—Ä–æ–≤ –∏ —Å–ø–µ–∫—Ç—Ä–∞–ª—å–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
‚îÇ     ‚îú‚îÄ cli.py             # CLI spectral-health
‚îÇ     ‚îî‚îÄ ...
```



================================================================================
–§–ê–ô–õ: src\spectral_physics\__init__.py
================================================================================

"""
SpectralPhysics-Lab: –±–∞–∑–æ–≤—ã–µ —á–∏—Å–ª–µ–Ω–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã
–¥–ª—è —Å–ø–µ–∫—Ç—Ä–∞–ª—å–Ω–æ–π —Ñ–∏–∑–∏–∫–∏.
"""

from .root_finding import symmetric_newton
from .spectrum import Spectrum1D
from .medium_1d import OscillatorChain1D
from .grav_toy import spectral_pressure_difference
from .material import MaterialSignature
from .timeseries import timeseries_to_spectrum
from .diagnostics import (
    ChannelConfig, 
    MultiChannelConfig,
    SpectralAnalyzer, 
    HealthMonitor, 
    build_health_profile,
    average_spectrum,
    spectral_band_power,
    spectral_entropy
)
from .io import (
    load_timeseries_csv, 
    save_spectrum_npz, 
    load_spectrum_npz,
    save_health_profile,
    load_health_profile
)
from .report import generate_markdown_report

__all__ = [
    "symmetric_newton",
    "Spectrum1D",
    "OscillatorChain1D",
    "spectral_pressure_difference",
    "MaterialSignature",
    "timeseries_to_spectrum",
    "ChannelConfig",
    "MultiChannelConfig",
    "SpectralAnalyzer",
    "HealthMonitor",
    "build_health_profile",
    "average_spectrum",
    "spectral_band_power",
    "spectral_entropy",
    "load_timeseries_csv",
    "save_spectrum_npz",
    "load_spectrum_npz",
    "save_health_profile",
    "load_health_profile",
    "generate_markdown_report",
]





================================================================================
–§–ê–ô–õ: src\spectral_physics\atoms.py
================================================================================

import numpy as np
from dataclasses import dataclass
from .spectrum import Spectrum1D

@dataclass
class AtomicResonator:
    """
    –ò–≥—Ä—É—à–µ—á–Ω–∞—è –º–æ–¥–µ–ª—å –∞—Ç–æ–º–∞ –∫–∞–∫ –Ω–∞–±–æ—Ä–∞ —Ä–µ–∑–æ–Ω–∞–Ω—Å–Ω—ã—Ö —á–∞—Å—Ç–æ—Ç –Ω–∞ –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏.
    """
    name: str
    omega: np.ndarray        # —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ —á–∞—Å—Ç–æ—Ç—ã (—Ä–∞–¥/—Å –∏–ª–∏ —É—Å–ª–æ–≤–Ω—ã–µ –µ–¥–∏–Ω–∏—Ü—ã)
    power: np.ndarray        # "–∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å" / –≤–µ—Å–∞ –ª–∏–Ω–∏–π
    max_bonds: int           # —Å–∫–æ–ª—å–∫–æ —Å–≤—è–∑–µ–π –∞—Ç–æ–º "–≤—ã–¥–µ—Ä–∂–∏–≤–∞–µ—Ç"

    @classmethod
    def from_lines(
        cls,
        name: str,
        lines: list[tuple[float, float]],
        max_bonds: int,
    ) -> "AtomicResonator":
        """
        lines: —Å–ø–∏—Å–æ–∫ (—á–∞—Å—Ç–æ—Ç–∞, –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å)
        """
        if not lines:
            return cls(name=name, omega=np.array([]), power=np.array([]), max_bonds=max_bonds)
            
        omega = np.array([f for f, a in lines], dtype=float)
        power = np.array([a for f, a in lines], dtype=float)
        return cls(name=name, omega=omega, power=power, max_bonds=max_bonds)

    def spectrum(self) -> Spectrum1D:
        """
        –í–µ—Ä–Ω—É—Ç—å Spectrum1D —Å –∑–∞–¥–∞–Ω–Ω—ã–º–∏ –ª–∏–Ω–∏—è–º–∏.
        """
        return Spectrum1D(omega=self.omega, power=self.power)

    def normalized_spectrum(self) -> Spectrum1D:
        """
        –ù–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Å–ø–µ–∫—Ç—Ä (—Å—É–º–º–∞ power = 1).
        """
        return self.spectrum().normalize()


def spectral_overlap(
    atom_a: AtomicResonator,
    atom_b: AtomicResonator,
    freq_tol: float = 0.05,
) -> float:
    """
    –û—Ü–µ–Ω–∫–∞ "—Ä–µ–∑–æ–Ω–∞–Ω—Å–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏" –¥–≤—É—Ö –∞—Ç–æ–º–æ–≤.

    –ò–¥–µ—è:
    - –±–µ—Ä—ë–º –ª–∏–Ω–∏–∏ –∏–∑ A –∏ B
    - –µ—Å–ª–∏ —Ä–∞–∑–Ω–æ—Å—Ç—å —á–∞—Å—Ç–æ—Ç |œâ_a - œâ_b| < freq_tol * œâ_avg,
      —Å—á–∏—Ç–∞–µ–º, —á—Ç–æ —ç—Ç–∏ –ª–∏–Ω–∏–∏ –º–æ–≥—É—Ç "—Å—Ü–µ–ø–∏—Ç—å—Å—è"
    - —Å—É–º–º–∞–µ–º –≤–µ—Å–∞ —Å–æ–≤–ø–∞–¥–∞—é—â–∏—Ö –ª–∏–Ω–∏–π –∫–∞–∫ –º–µ—Ä—É —Å–∏–ª—ã —Å–≤—è–∑–∏.

    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —á–∏—Å–ª–æ [0..1] –ø—Ä–∏–º–µ—Ä–Ω–æ: —á–µ–º –±–æ–ª—å—à–µ, —Ç–µ–º "–ª—É—á—à–µ" —Å–≤—è–∑—å.
    """
    if len(atom_a.omega) == 0 or len(atom_b.omega) == 0:
        return 0.0
        
    overlap_score = 0.0
    
    # –ù–æ—Ä–º–∏—Ä—É–µ–º –≤–µ—Å–∞, —á—Ç–æ–±—ã –æ—Ü–µ–Ω–∫–∞ –Ω–µ –∑–∞–≤–∏—Å–µ–ª–∞ –æ—Ç –∞–±—Å–æ–ª—é—Ç–Ω–æ–π –∞–º–ø–ª–∏—Ç—É–¥—ã
    # (–∏–ª–∏ —Å—á–∏—Ç–∞–µ–º, —á—Ç–æ power —É–∂–µ –æ—Ç—Ä–∞–∂–∞–µ—Ç "–≤–∞–∂–Ω–æ—Å—Ç—å")
    # –î–∞–≤–∞–π—Ç–µ —Ä–∞–±–æ—Ç–∞—Ç—å —Å –Ω–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ —Å–ø–µ–∫—Ç—Ä–∞–º–∏ –¥–ª—è —á–µ—Å—Ç–Ω–æ—Å—Ç–∏
    spec_a = atom_a.normalized_spectrum()
    spec_b = atom_b.normalized_spectrum()
    
    # –ü—Ä–æ—Å—Ç–æ–π –ø–µ—Ä–µ–±–æ—Ä –≤—Å–µ—Ö –ø–∞—Ä –ª–∏–Ω–∏–π (O(Na * Nb)) - –¥–ª—è –∞—Ç–æ–º–æ–≤ —ç—Ç–æ –º–∞–ª–æ
    for i, wa in enumerate(spec_a.omega):
        pa = spec_a.power[i]
        
        for j, wb in enumerate(spec_b.omega):
            pb = spec_b.power[j]
            
            w_avg = (wa + wb) / 2.0
            if w_avg == 0:
                continue
                
            diff = abs(wa - wb)
            
            if diff < freq_tol * w_avg:
                # –†–µ–∑–æ–Ω–∞–Ω—Å!
                # –í–∫–ª–∞–¥ –≤ —Å–≤—è–∑—å –ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª–µ–Ω –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—é –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç–µ–π (–∏–ª–∏ –º–∏–Ω–∏–º—É–º—É?)
                # –ü—É—Å—Ç—å –±—É–¥–µ—Ç –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ, –∫–∞–∫ –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è
                # –ò–ª–∏ —Å—É–º–º–∞?
                # –¢–ó: "—Å—É–º–º–∞–µ–º –≤–µ—Å–∞ —Å–æ–≤–ø–∞–¥–∞—é—â–∏—Ö –ª–∏–Ω–∏–π"
                # –í–æ–∑—å–º–µ–º min(pa, pb) –∫–∞–∫ "–æ–±—â–∞—è —ç–Ω–µ—Ä–≥–∏—è —Ä–µ–∑–æ–Ω–∞–Ω—Å–∞"
                overlap_score += min(pa, pb)
                
    # –û–≥—Ä–∞–Ω–∏—á–∏–º 1.0 (—Ö–æ—Ç—è –º–æ–∂–µ—Ç –±—ã—Ç—å –∏ –±–æ–ª—å—à–µ, –µ—Å–ª–∏ –º–Ω–æ–≥–æ –ª–∏–Ω–∏–π —Å–æ–≤–ø–∞–¥–∞—é—Ç —Å –æ–¥–Ω–æ–π)
    return min(overlap_score, 1.0)


def can_form_bond(
    atom_a: AtomicResonator,
    atom_b: AtomicResonator,
    freq_tol: float,
    threshold: float,
) -> bool:
    """
    –†–µ—à–∞–µ–º, –≤–æ–∑–º–æ–∂–Ω–∞ –ª–∏ —É—Å—Ç–æ–π—á–∏–≤–æ–µ "—Å—Ü–µ–ø–ª–µ–Ω–∏–µ":
    overlap >= threshold –∏ –Ω–µ –ø—Ä–µ–≤—ã—à–µ–Ω—ã max_bonds —É –æ–±–æ–∏—Ö.
    """
    if atom_a.max_bonds <= 0 or atom_b.max_bonds <= 0:
        return False
        
    score = spectral_overlap(atom_a, atom_b, freq_tol)
    return score >= threshold


# --- Toy Atoms ---

H = AtomicResonator.from_lines(
    name="H",
    lines=[(1.0, 1.0)],   # –æ–¥–∏–Ω —Ä–µ–∑–æ–Ω–∞–Ω—Å
    max_bonds=1,
)

O = AtomicResonator.from_lines(
    name="O",
    lines=[(0.9, 0.5), (1.0, 0.8), (1.1, 0.5)],
    max_bonds=2,
)

C = AtomicResonator.from_lines(
    name="C",
    lines=[(0.8, 0.7), (1.0, 0.9), (1.2, 0.7)],
    max_bonds=4,
)



================================================================================
–§–ê–ô–õ: src\spectral_physics\cli.py
================================================================================

import argparse
import sys
import yaml
from pathlib import Path
from typing import Dict, List, Any

from .io import load_timeseries_csv, save_health_profile, load_health_profile
from .diagnostics import (
    ChannelConfig, 
    SpectralAnalyzer, 
    build_health_profile,
)
from .material import HealthProfile

from .spectrum import Spectrum1D


def load_config(path: str) -> Dict[str, Any]:
    """Load YAML configuration."""
    with open(path, 'r') as f:
        return yaml.safe_load(f)


def train_command(args):
    """Execute training command."""
    print(f"Loading config from {args.config}...")
    config = load_config(args.config)
    
    dt = config.get('dt')
    window = config.get('window', 'hann')
    channels_conf = config.get('channels', {})
    
    if not channels_conf:
        print("Error: No channels defined in config.")
        return 1
        
    training_data: Dict[str, List[Spectrum1D]] = {}
    
    print(f"Processing {len(channels_conf)} channels...")
    
    for name, ch_data in channels_conf.items():
        print(f"  Channel '{name}':")
        column = ch_data.get('column', 0)
        files = ch_data.get('files', [])
        
        # Create analyzer for this channel
        ch_config = ChannelConfig(
            name=name,
            dt=dt,
            window=window,
            freq_min=ch_data.get('freq_min'),
            freq_max=ch_data.get('freq_max')
        )
        analyzer = SpectralAnalyzer(ch_config)
        
        spectra = []
        for file_path in files:
            try:
                print(f"    Loading {file_path}...", end='', flush=True)
                signal = load_timeseries_csv(file_path, column=column)
                spec = analyzer.analyze(signal)
                spectra.append(spec)
                print(" OK")
            except Exception as e:
                print(f" FAIL: {e}")
        
        if spectra:
            training_data[name] = spectra
        else:
            print(f"    Warning: No valid data for channel '{name}'")

    if not training_data:
        print("Error: No training data collected.")
        return 1
        
    print("Building health profile...")
    profile = build_health_profile(training_data)
    
    print(f"Saving profile to {args.out}...")
    save_health_profile(profile, args.out)
    print("Done.")
    return 0


def score_command(args):
    """Execute scoring command."""
    print(f"Loading profile from {args.profile}...")
    try:
        profile = load_health_profile(args.profile)
    except Exception as e:
        print(f"Error loading profile: {e}")
        return 2

    print(f"Loading config from {args.config}...")
    config = load_config(args.config)
    
    print(f"Loading thresholds from {args.thresholds}...")
    thresholds = load_config(args.thresholds)
    
    dt = config.get('dt')
    window = config.get('window', 'hann')
    channels_conf = config.get('channels', {})
    
    current_spectra: Dict[str, Spectrum1D] = {}
    
    # Process current data (take first file from list or 'current' key)
    for name, ch_data in channels_conf.items():
        if name not in profile.signatures:
            continue
            
        files = ch_data.get('files', [])
        if not files:
            continue
            
        # Use the last file as "current" state
        file_path = files[-1]
        column = ch_data.get('column', 0)
        
        ch_config = ChannelConfig(
            name=name,
            dt=dt,
            window=window,
            freq_min=ch_data.get('freq_min'),
            freq_max=ch_data.get('freq_max')
        )
        analyzer = SpectralAnalyzer(ch_config)
        
        try:
            signal = load_timeseries_csv(file_path, column=column)
            spec = analyzer.analyze(signal)
            current_spectra[name] = spec
        except Exception as e:
            print(f"Error processing channel {name}: {e}")

    if not current_spectra:
        print("Error: No current data to analyze.")
        return 1

    # Calculate scores
    scores = profile.score(current_spectra)
    anomalies = profile.is_anomalous(current_spectra, thresholds)
    
    # Generate report
    print("\n" + "=" * 60)
    print(f"{'Channel':<15} {'Distance':<12} {'Threshold':<12} {'Status':<10}")
    print("-" * 60)
    
    any_anomaly = False
    
    for name in scores:
        dist = scores[name]
        thresh = thresholds.get(name, 0.0)
        is_anom = anomalies.get(name, False)
        status = "ANOMALY" if is_anom else "OK"
        
        if is_anom:
            any_anomaly = True
            
        print(f"{name:<15} {dist:.6f}     {thresh:.6f}     {status:<10}")
        
    print("=" * 60)
    
    if args.report:
        from .report import generate_markdown_report
        print(f"Generating report: {args.report}")
        generate_markdown_report(scores, thresholds, args.report)

    return 1 if any_anomaly else 0


def main():
    parser = argparse.ArgumentParser(
        description="Spectral Health: Multi-channel diagnostics engine"
    )
    subparsers = parser.add_subparsers(dest='command', required=True)
    
    # Train command
    parser_train = subparsers.add_parser('train', help='Train health profile')
    parser_train.add_argument('--config', required=True, help='Path to config.yaml')
    parser_train.add_argument('--out', required=True, help='Output path for profile.npz')
    parser_train.set_defaults(func=train_command)
    
    # Score command
    parser_score = subparsers.add_parser('score', help='Score current data against profile')
    parser_score.add_argument('--config', required=True, help='Path to config.yaml')
    parser_score.add_argument('--profile', required=True, help='Path to profile.npz')
    parser_score.add_argument('--thresholds', required=True, help='Path to thresholds.yaml')
    parser_score.add_argument('--report', help='Path to output markdown report')
    parser_score.set_defaults(func=score_command)
    
    args = parser.parse_args()
    sys.exit(args.func(args))


if __name__ == "__main__":
    main()



================================================================================
–§–ê–ô–õ: src\spectral_physics\diagnostics.py
================================================================================

import numpy as np
from dataclasses import dataclass
from .timeseries import timeseries_to_spectrum
from .spectrum import Spectrum1D
from .material import MaterialSignature


@dataclass
class ChannelConfig:
    """
    –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –æ–¥–Ω–æ–≥–æ –∫–∞–Ω–∞–ª–∞ –∏–∑–º–µ—Ä–µ–Ω–∏–π.

    Attributes:
        name: –ò–º—è –∫–∞–Ω–∞–ª–∞ (—Å—Ç—Ä–æ–∫–∞ –¥–ª—è –æ—Ç—á—ë—Ç–æ–≤).
        dt: –®–∞–≥ –ø–æ –≤—Ä–µ–º–µ–Ω–∏ (—Å–µ–∫—É–Ω–¥—ã).
        window: –¢–∏–ø –æ–∫–Ω–∞ –¥–ª—è FFT ("hann" –∏–ª–∏ None).
        freq_min: –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —á–∞—Å—Ç–æ—Ç–∞ –∞–Ω–∞–ª–∏–∑–∞ (–ì—Ü).
        freq_max: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —á–∞—Å—Ç–æ—Ç–∞ –∞–Ω–∞–ª–∏–∑–∞ (–ì—Ü).
    """
    name: str
    dt: float
    window: str = "hann"
    freq_min: float | None = None
    freq_max: float | None = None


@dataclass
class MultiChannelConfig:
    """
    –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã —Å –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ –∫–∞–Ω–∞–ª–∞–º–∏.
    """
    channels: dict[str, ChannelConfig]



class SpectralAnalyzer:
    """
    –ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç: –≤—Ä–µ–º–µ–Ω–Ω–æ–π —Ä—è–¥ -> —Å–ø–µ–∫—Ç—Ä -> –æ–±—Ä–µ–∑–∫–∞ –ø–æ –¥–∏–∞–ø–∞–∑–æ–Ω—É —á–∞—Å—Ç–æ—Ç.
    """

    def __init__(self, config: ChannelConfig):
        """
        Args:
            config: –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∫–∞–Ω–∞–ª–∞.
        """
        self.config = config

    def analyze(self, signal: np.ndarray) -> Spectrum1D:
        """
        –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å —Å–∏–≥–Ω–∞–ª –≤–æ –≤—Ä–µ–º–µ–Ω–∏ –≤ Spectrum1D —Å —É—á—ë—Ç–æ–º:
        - —É–¥–∞–ª–µ–Ω–∏—è DC,
        - –æ–∫–Ω–∞,
        - –≤—ã—Ä–µ–∑–∞–Ω–∏—è –¥–∏–∞–ø–∞–∑–æ–Ω–∞ —á–∞—Å—Ç–æ—Ç [freq_min, freq_max] (–µ—Å–ª–∏ –∑–∞–¥–∞–Ω—ã).

        Args:
            signal: –í—Ä–µ–º–µ–Ω–Ω–æ–π —Ä—è–¥ (1D array).

        Returns:
            Spectrum1D —Ç–æ–ª—å–∫–æ –ø–æ –≤—ã–±—Ä–∞–Ω–Ω–æ–º—É –¥–∏–∞–ø–∞–∑–æ–Ω—É —á–∞—Å—Ç–æ—Ç.
        """
        # –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤ —Å–ø–µ–∫—Ç—Ä
        spectrum = timeseries_to_spectrum(
            signal,
            dt=self.config.dt,
            window=self.config.window
        )
        
        # –ï—Å–ª–∏ –Ω–µ –∑–∞–¥–∞–Ω—ã –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è —á–∞—Å—Ç–æ—Ç, –≤–µ—Ä–Ω—É—Ç—å –≤–µ—Å—å —Å–ø–µ–∫—Ç—Ä
        if self.config.freq_min is None and self.config.freq_max is None:
            return spectrum
        
        # –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å omega –≤ –ì–µ—Ä—Ü—ã
        freq_hz = spectrum.omega / (2 * np.pi)
        
        # –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å –º–∞—Å–∫—É –¥–ª—è –¥–∏–∞–ø–∞–∑–æ–Ω–∞ —á–∞—Å—Ç–æ—Ç
        mask = np.ones(len(freq_hz), dtype=bool)
        
        if self.config.freq_min is not None:
            mask &= (freq_hz >= self.config.freq_min)
        
        if self.config.freq_max is not None:
            mask &= (freq_hz <= self.config.freq_max)
        
        # –í—ã—Ä–µ–∑–∞—Ç—å –¥–∏–∞–ø–∞–∑–æ–Ω
        omega_filtered = spectrum.omega[mask]
        power_filtered = spectrum.power[mask]
        
        return Spectrum1D(omega=omega_filtered, power=power_filtered)


class HealthMonitor:
    """
    –ú–æ–Ω–∏—Ç–æ—Ä "–∑–¥–æ—Ä–æ–≤—å—è" –∫–∞–Ω–∞–ª–∞ –ø–æ —Å–ø–µ–∫—Ç—Ä—É.
    """

    def __init__(self, reference: Spectrum1D, threshold: float):
        """
        Args:
            reference: –≠—Ç–∞–ª–æ–Ω–Ω—ã–π —Å–ø–µ–∫—Ç—Ä "–∑–¥–æ—Ä–æ–≤–æ–≥–æ" —Å–æ—Å—Ç–æ—è–Ω–∏—è.
            threshold: –ü–æ—Ä–æ–≥ –∞–Ω–æ–º–∞–ª—å–Ω–æ—Å—Ç–∏ –ø–æ L2-–¥–∏—Å—Ç–∞–Ω—Ü–∏–∏.
        """
        self.signature = MaterialSignature(reference=reference)
        self.threshold = float(threshold)

    def score(self, current: Spectrum1D) -> float:
        """
        –í–µ—Ä–Ω—É—Ç—å L2-–¥–∏—Å—Ç–∞–Ω—Ü–∏—é –º–µ–∂–¥—É —Ç–µ–∫—É—â–∏–º —Å–ø–µ–∫—Ç—Ä–æ–º –∏ —ç—Ç–∞–ª–æ–Ω–Ω—ã–º.
        
        Args:
            current: –¢–µ–∫—É—â–∏–π —Å–ø–µ–∫—Ç—Ä.
        
        Returns:
            L2-—Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ (—Å–∫–∞–ª—è—Ä).
        """
        return self.signature.distance_l2(current)

    def is_anomalous(self, current: Spectrum1D) -> bool:
        """
        True, –µ—Å–ª–∏ —Ç–µ–∫—É—â–∏–π —Å–ø–µ–∫—Ç—Ä –∞–Ω–æ–º–∞–ª–µ–Ω (distance > threshold).
        
        Args:
            current: –¢–µ–∫—É—â–∏–π —Å–ø–µ–∫—Ç—Ä.
        
        Returns:
            True –µ—Å–ª–∏ –∞–Ω–æ–º–∞–ª–µ–Ω, False –∏–Ω–∞—á–µ.
        """
        return self.signature.is_anomalous(current, self.threshold)


def average_spectrum(spectra: list[Spectrum1D]) -> Spectrum1D:
    """
    –£—Å—Ä–µ–¥–Ω–∏—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–ø–µ–∫—Ç—Ä–æ–≤ —Å –æ–¥–∏–Ω–∞–∫–æ–≤–æ–π —á–∞—Å—Ç–æ—Ç–Ω–æ–π —Å–µ—Ç–∫–æ–π.

    Args:
        spectra: –°–ø–∏—Å–æ–∫ —Å–ø–µ–∫—Ç—Ä–æ–≤.

    Returns:
        –ù–æ–≤—ã–π Spectrum1D —Å —É—Å—Ä–µ–¥–Ω–µ–Ω–Ω–æ–π –º–æ—â–Ω–æ—Å—Ç—å—é.
    
    Raises:
        ValueError: –ï—Å–ª–∏ —Å–ø–∏—Å–æ–∫ –ø—É—Å—Ç –∏–ª–∏ —Å–µ—Ç–∫–∏ —á–∞—Å—Ç–æ—Ç –Ω–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç.
    """
    if not spectra:
        raise ValueError("Cannot average empty list of spectra")
    
    # –ë–µ—Ä–µ–º –ø–µ—Ä–≤—ã–π —Å–ø–µ–∫—Ç—Ä –∫–∞–∫ —ç—Ç–∞–ª–æ–Ω —Å–µ—Ç–∫–∏
    omega_ref = spectra[0].omega
    n_points = len(omega_ref)
    
    sum_power = np.zeros_like(spectra[0].power)
    
    for i, spec in enumerate(spectra):
        if len(spec.omega) != n_points or not np.allclose(spec.omega, omega_ref):
            raise ValueError(
                f"Spectrum at index {i} has different frequency grid"
            )
        sum_power += spec.power
        
    avg_power = sum_power / len(spectra)
    
    return Spectrum1D(omega=omega_ref.copy(), power=avg_power)


def build_health_profile(
    training_data: dict[str, list[Spectrum1D]]
) -> "HealthProfile":
    """
    –ü–æ—Å—Ç—Ä–æ–∏—Ç—å HealthProfile –ø–æ –æ–±—É—á–∞—é—â–∏–º –¥–∞–Ω–Ω—ã–º.

    Args:
        training_data: –°–ª–æ–≤–∞—Ä—å {–∏–º—è_–∫–∞–Ω–∞–ª–∞: —Å–ø–∏—Å–æ–∫_—Å–ø–µ–∫—Ç—Ä–æ–≤}.

    Returns:
        HealthProfile —Å —É—Å—Ä–µ–¥–Ω–µ–Ω–Ω—ã–º–∏ —Å–∏–≥–Ω–∞—Ç—É—Ä–∞–º–∏.
    """
    from .material import HealthProfile, MaterialSignature
    
    signatures = {}
    
    for channel_name, spectra_list in training_data.items():
        if not spectra_list:
            continue
            
        # 1. –£—Å—Ä–µ–¥–Ω—è–µ–º —Å–ø–µ–∫—Ç—Ä—ã
        avg_spec = average_spectrum(spectra_list)
        
        # 2. –°–æ–∑–¥–∞–µ–º —Å–∏–≥–Ω–∞—Ç—É—Ä—É
        signature = MaterialSignature(reference=avg_spec)
        
        # 3. –°–æ—Ö—Ä–∞–Ω—è–µ–º
        signatures[channel_name] = signature
        
    return HealthProfile(signatures=signatures)


def spectral_band_power(
    spectrum: Spectrum1D,
    freq_min: float,
    freq_max: float,
) -> float:
    """
    –≠–Ω–µ—Ä–≥–∏—è —Å–ø–µ–∫—Ç—Ä–∞ –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ [freq_min, freq_max] (–ì—Ü).
    
    Args:
        spectrum: –°–ø–µ–∫—Ç—Ä –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞.
        freq_min: –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —á–∞—Å—Ç–æ—Ç–∞ (–ì—Ü).
        freq_max: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —á–∞—Å—Ç–æ—Ç–∞ (–ì—Ü).
    
    Returns:
        –°—É–º–º–∞—Ä–Ω–∞—è –º–æ—â–Ω–æ—Å—Ç—å –≤ –ø–æ–ª–æ—Å–µ.
    """
    freq_hz = spectrum.omega / (2 * np.pi)
    mask = (freq_hz >= freq_min) & (freq_hz <= freq_max)
    return float(np.sum(spectrum.power[mask]))


def spectral_entropy(spectrum: Spectrum1D) -> float:
    """
    –°–ø–µ–∫—Ç—Ä–∞–ª—å–Ω–∞—è —ç–Ω—Ç—Ä–æ–ø–∏—è: H = - sum(p_i * log(p_i)),
    –≥–¥–µ p_i = –Ω–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –º–æ—â–Ω–æ—Å—Ç—å.
    
    Args:
        spectrum: –°–ø–µ–∫—Ç—Ä –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞.
    
    Returns:
        –ó–Ω–∞—á–µ–Ω–∏–µ —ç–Ω—Ç—Ä–æ–ø–∏–∏.
    """
    total = spectrum.total_power()
    if total == 0:
        return 0.0
    
    # –ù–æ—Ä–º–∏—Ä—É–µ–º –º–æ—â–Ω–æ—Å—Ç—å (–∫–∞–∫ –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å)
    p = spectrum.power / total
    
    # –ò—Å–∫–ª—é—á–∞–µ–º –Ω—É–ª–∏ –¥–ª—è –ª–æ–≥–∞—Ä–∏—Ñ–º–∞
    p = p[p > 0]
    
    return float(-np.sum(p * np.log(p)))


def extract_features(
    spectrum: Spectrum1D,
    bands_hz: list[tuple[float, float]],
) -> np.ndarray:
    """
    –ü–æ—Å—Ç—Ä–æ–∏—Ç—å –≤–µ–∫—Ç–æ—Ä —Ñ–∏—á:
    [ band_power_1, ..., band_power_N, spectral_entropy ]
    
    Args:
        spectrum: –°–ø–µ–∫—Ç—Ä.
        bands_hz: –°–ø–∏—Å–æ–∫ –∫–æ—Ä—Ç–µ–∂–µ–π (min_hz, max_hz).
        
    Returns:
        NumPy –º–∞—Å—Å–∏–≤ —Ñ–∏—á.
    """
    features = []
    for fmin, fmax in bands_hz:
        features.append(spectral_band_power(spectrum, fmin, fmax))
    
    features.append(spectral_entropy(spectrum))
    return np.asarray(features, dtype=float)






================================================================================
–§–ê–ô–õ: src\spectral_physics\geophysics_1d.py
================================================================================

from dataclasses import dataclass
import numpy as np
from .medium_1d import OscillatorChain1D
from .root_finding import symmetric_newton

@dataclass
class Layer:
    thickness: float
    density: float
    stiffness: float

@dataclass
class LayeredMedium1D:
    layers: list[Layer]
    dx: float  # —à–∞–≥ –¥–∏—Å–∫—Ä–µ—Ç–∏–∑–∞—Ü–∏–∏ –ø–æ –≥–ª—É–±–∏–Ω–µ

    def to_oscillator_chain(self) -> OscillatorChain1D:
        """
        –ü–æ—Å—Ç—Ä–æ–∏—Ç—å —Ü–µ–ø–æ—á–∫—É –æ—Å—Ü–∏–ª–ª—è—Ç–æ—Ä–æ–≤, –≥–¥–µ –∫–∞–∂–¥—ã–π —É–∑–µ–ª
        –Ω–∞—Å–ª–µ–¥—É–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Å–ª–æ—è, –≤ –∫–æ—Ç–æ—Ä—ã–π –æ–Ω –ø–æ–ø–∞–¥–∞–µ—Ç.
        """
        total_depth = sum(layer.thickness for layer in self.layers)
        n_nodes = int(np.ceil(total_depth / self.dx))
        
        masses = np.zeros(n_nodes)
        k_springs = np.zeros(n_nodes - 1)
        
        current_depth = 0.0
        
        # –ó–∞–ø–æ–ª–Ω—è–µ–º –º–∞—Å—Å—ã —É–∑–ª–æ–≤
        for i in range(n_nodes):
            depth = i * self.dx
            
            # –ù–∞–π—Ç–∏ —Å–ª–æ–π
            layer_idx = 0
            d_acc = 0.0
            for l_idx, layer in enumerate(self.layers):
                d_acc += layer.thickness
                if depth < d_acc:
                    layer_idx = l_idx
                    break
                # –ï—Å–ª–∏ –≥–ª—É–±–∏–Ω–∞ –±–æ–ª—å—à–µ –ø–æ–ª–Ω–æ–π (–ø–æ—Å–ª–µ–¥–Ω–∏–π —É–∑–µ–ª), –±–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π —Å–ª–æ–π
                layer_idx = len(self.layers) - 1
            
            layer = self.layers[layer_idx]
            
            # –ú–∞—Å—Å–∞ —É–∑–ª–∞ ~ –ø–ª–æ—Ç–Ω–æ—Å—Ç—å * dx (–æ–±—ä–µ–º 1D —ç–ª–µ–º–µ–Ω—Ç–∞)
            masses[i] = layer.density * self.dx
            
        # –ó–∞–ø–æ–ª–Ω—è–µ–º –ø—Ä—É–∂–∏–Ω—ã
        for i in range(n_nodes - 1):
            depth = (i + 0.5) * self.dx
            
            # –ù–∞–π—Ç–∏ —Å–ª–æ–π –¥–ª—è –ø—Ä—É–∂–∏–Ω—ã
            layer_idx = 0
            d_acc = 0.0
            for l_idx, layer in enumerate(self.layers):
                d_acc += layer.thickness
                if depth < d_acc:
                    layer_idx = l_idx
                    break
                layer_idx = len(self.layers) - 1
            
            layer = self.layers[layer_idx]
            
            # –ñ–µ—Å—Ç–∫–æ—Å—Ç—å –ø—Ä—É–∂–∏–Ω—ã ~ stiffness / dx
            k_springs[i] = layer.stiffness / self.dx
            
        return OscillatorChain1D(
            n=n_nodes,
            m=masses,     # –ü–µ—Ä–µ–¥–∞–µ–º –º–∞—Å—Å–∏–≤ –º–∞—Å—Å
            k=k_springs   # –ü–µ—Ä–µ–¥–∞–µ–º –º–∞—Å—Å–∏–≤ –∂–µ—Å—Ç–∫–æ—Å—Ç–µ–π
        )


def simulate_pulse_response(
    medium: LayeredMedium1D,
    t_max: float | None = None,
    dt: float = 0.1,
    n_steps: int | None = None,
) -> tuple[np.ndarray, np.ndarray]:
    """
    –ò–º–∏—Ç–∞—Ü–∏—è –æ—Ç–∫–ª–∏–∫–∞ –Ω–∞ —É–¥–∞—Ä –ø–æ –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏:
    –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç (t, signal) ‚Äî —Å–∏–≥–Ω–∞–ª –Ω–∞ –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏ –≤–æ –≤—Ä–µ–º–µ–Ω–∏.
    """
    chain = medium.to_oscillator_chain()
    
    if n_steps is None:
        if t_max is None:
            raise ValueError("Must provide either t_max or n_steps")
        n_steps = int(np.ceil(t_max / dt))
    
    # t = np.linspace(0, t_max, n_steps) # This was causing issues
    t = np.arange(n_steps) * dt
    
    # –ò–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –≤–æ –≤—Ä–µ–º–µ–Ω–∏
    # M x'' + K x = F
    # F(t) = –∏–º–ø—É–ª—å—Å –≤ t=0 –Ω–∞ —É–∑–ª–µ 0
    
    # –°–æ—Å—Ç–æ—è–Ω–∏–µ: x (—Å–º–µ—â–µ–Ω–∏—è), v (—Å–∫–æ—Ä–æ—Å—Ç–∏)
    x = np.zeros(chain.n)
    v = np.zeros(chain.n)
    
    # –ù–∞—á–∞–ª—å–Ω—ã–π –∏–º–ø—É–ª—å—Å: –º–≥–Ω–æ–≤–µ–Ω–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å —É–∑–ª–∞ 0
    # –ò–º–ø—É–ª—å—Å P -> v[0] = P / m[0]
    # –ü—É—Å—Ç—å P = 1.0
    v[0] = 1.0 / chain.m[0]
    
    surface_signal = np.zeros(n_steps)
    
    # –Ø–≤–Ω–∞—è —Å—Ö–µ–º–∞ –≠–π–ª–µ—Ä–∞-–ö—Ä–æ–º–µ—Ä–∞ (–ø–æ–ª—É–Ω–µ—è–≤–Ω–∞—è) –∏–ª–∏ –í–µ—Ä–ª–µ
    # v(t+dt) = v(t) + a(t)*dt
    # x(t+dt) = x(t) + v(t+dt)*dt
    
    # –î–ª—è —É—Å–∫–æ—Ä–µ–Ω–∏—è –º–æ–∂–Ω–æ —Å–æ–±—Ä–∞—Ç—å K –º–∞—Ç—Ä–∏—Ü—É –æ–¥–∏–Ω —Ä–∞–∑, –Ω–æ –¥–ª—è 1D —Ü–µ–ø–æ—á–∫–∏
    # —Å–∏–ª—ã —Å—á–∏—Ç–∞—é—Ç—Å—è –±—ã—Å—Ç—Ä–æ: F_i = k_i*(x_{i+1}-x_i) - k_{i-1}*(x_i - x_{i-1})
    
    # –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ —Ä–∞—Å–ø–∞—Ä—Å–∏–º k –∏ m –¥–ª—è —Å–∫–æ—Ä–æ—Å—Ç–∏
    k = chain.k
    m_inv = 1.0 / chain.m
    
    # Handle scalar k
    if np.ndim(k) == 0:
        k = np.full(chain.n - 1, float(k))
    
    for step in range(n_steps):
        surface_signal[step] = x[0]
        
        # –†–∞—Å—á–µ—Ç —Å–∏–ª
        # F = -K * x
        # –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ —Å–∏–ª—ã
        forces = np.zeros(chain.n)
        
        # –ü—Ä—É–∂–∏–Ω—ã
        # force on i from i+1: k[i] * (x[i+1] - x[i])
        # force on i+1 from i: -k[i] * (x[i+1] - x[i])
        
        dx_springs = x[1:] - x[:-1] # x[i+1] - x[i]
        f_springs = k * dx_springs
        
        forces[:-1] += f_springs
        forces[1:] -= f_springs
        
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ
        a = forces * m_inv
        v += a * dt
        x += v * dt
        
    return t, surface_signal


def invert_single_layer_thickness(
    target_signal: np.ndarray,
    t: np.ndarray,
    density: float,
    stiffness: float,
    thickness_guess: float,
    fixed_layers_below: list[Layer],
    dx: float = 0.1,
) -> float:
    """
    –ò–≥—Ä—É—à–µ—á–Ω–∞—è –æ–±—Ä–∞—Ç–Ω–∞—è –∑–∞–¥–∞—á–∞:
    –ø–æ–¥–±–∏—Ä–∞–µ–º —Ç–æ–ª—â–∏–Ω—É –ø–µ—Ä–≤–æ–≥–æ —Å–ª–æ—è (—Å –∏–∑–≤–µ—Å—Ç–Ω—ã–º–∏ density/stiffness),
    —á—Ç–æ–±—ã —Å–∏–≥–Ω–∞–ª —Å–æ–≤–ø–∞–ª —Å target.
    
    fixed_layers_below: —Å–ª–æ–∏, –∫–æ—Ç–æ—Ä—ã–µ –∏–¥—É—Ç –ü–û–î –ø–µ—Ä–≤—ã–º —Å–ª–æ–µ–º (–∏–∑–≤–µ—Å—Ç–Ω–∞—è –ø–æ–¥–ª–æ–∂–∫–∞).
    """
    
    dt = t[1] - t[0]
    n_steps = len(target_signal)
    
    def objective(h: float) -> float:
        # –°–æ–±–∏—Ä–∞–µ–º —Å—Ä–µ–¥—É
        layer1 = Layer(thickness=h, density=density, stiffness=stiffness)
        medium = LayeredMedium1D(layers=[layer1] + fixed_layers_below, dx=dx)
        
        # –°–∏–º—É–ª–∏—Ä—É–µ–º
        _, signal = simulate_pulse_response(medium, dt=dt, n_steps=n_steps)
        
        # –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º (L2 norm)
        diff = signal - target_signal
        return float(np.sum(diff**2))

    from scipy.optimize import minimize_scalar
    
    res = minimize_scalar(
        objective, 
        bounds=(0.5 * thickness_guess, 2.0 * thickness_guess), 
        method='bounded'
    )
    
    res = minimize_scalar(
        objective, 
        bounds=(0.5 * thickness_guess, 2.0 * thickness_guess), 
        method='bounded'
    )
    
    return float(res.x)

def build_geo1d_health_profile(signal: np.ndarray) -> "FeatureSignature":
    """
    –ü–æ–¥–ø–∏—Å—å –Ω–æ—Ä–º–∞–ª—å–Ω–æ–≥–æ –æ—Ç–∫–ª–∏–∫–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π —Å–∫–≤–∞–∂–∏–Ω—ã/—É—á–∞—Å—Ç–∫–∞).
    –í–µ–∫—Ç–æ—Ä –ø—Ä–∏–∑–Ω–∞–∫–æ–≤: [energy, max_amplitude, mean_abs, std, zero_crossings]
    """
    from .material import FeatureSignature
    
    # Simple time-domain features
    energy = np.sum(signal**2)
    max_amp = np.max(np.abs(signal))
    mean_abs = np.mean(np.abs(signal))
    std_val = np.std(signal)
    
    # Zero crossings
    zero_crossings = np.sum(np.diff(np.signbit(signal)))
    
    features = np.array([energy, max_amp, mean_abs, std_val, float(zero_crossings)])
    
    return FeatureSignature(reference_features=features)



================================================================================
–§–ê–ô–õ: src\spectral_physics\grav_toy.py
================================================================================

import numpy as np
from .spectrum import Spectrum1D


def spectral_pressure_difference(
    spectrum_bg: Spectrum1D,
    alpha_left: np.ndarray,
    alpha_right: np.ndarray,
) -> float:
    """
    Estimate pressure difference of background field on left and right sides.
    
    This is a toy model of "spectral shadow" and attractive force.
    The idea is that matter with different spectral transparency creates
    an imbalance in the background spectrum, leading to a net force.
    
    Args:
        spectrum_bg: Background spectrum (omega, power).
        alpha_left: Spectral transparency on the left side (same shape as power).
        alpha_right: Spectral transparency on the right side (same shape as power).
    
    Returns:
        Pressure difference: ŒîP = Œ£ power(œâ) * (alpha_right(œâ) - alpha_left(œâ))
        
        Positive ŒîP means net force pushes to the right.
        Negative ŒîP means net force pushes to the left.
    
    Raises:
        ValueError: If alpha arrays have incompatible shapes.
    
    Example:
        If left side has lower transparency (blocks more), then more
        background radiation reaches from the right, creating a net
        force pushing the object leftward (toward the shadow).
    """
    alpha_left = np.asarray(alpha_left, dtype=float)
    alpha_right = np.asarray(alpha_right, dtype=float)
    
    # Validate shapes
    if alpha_left.shape != spectrum_bg.power.shape:
        raise ValueError(
            f"alpha_left shape {alpha_left.shape} doesn't match "
            f"spectrum power shape {spectrum_bg.power.shape}"
        )
    
    if alpha_right.shape != spectrum_bg.power.shape:
        raise ValueError(
            f"alpha_right shape {alpha_right.shape} doesn't match "
            f"spectrum power shape {spectrum_bg.power.shape}"
        )
    
    # Compute pressure difference
    # ŒîP = Œ£ P(œâ) * [Œ±_right(œâ) - Œ±_left(œâ)]
    delta_alpha = alpha_right - alpha_left
    delta_p = np.sum(spectrum_bg.power * delta_alpha)
    
    return float(delta_p)



================================================================================
–§–ê–ô–õ: src\spectral_physics\io.py
================================================================================

import numpy as np
from pathlib import Path
from .spectrum import Spectrum1D


def load_timeseries_csv(
    path: str,
    column: int = 0,
    skip_header: bool = True
) -> np.ndarray:
    """
    –ó–∞–≥—Ä—É–∑–∏—Ç—å –æ–¥–Ω–æ–º–µ—Ä–Ω—ã–π –≤—Ä–µ–º–µ–Ω–Ω–æ–π —Ä—è–¥ –∏–∑ CSV.

    –ü–∞—Ä–∞–º–µ—Ç—Ä—ã:
        path: –ü—É—Ç—å –∫ —Ñ–∞–π–ª—É CSV.
        column: –ò–Ω–¥–µ–∫—Å –∫–æ–ª–æ–Ω–∫–∏ (0-based), –≥–¥–µ –ª–µ–∂–∏—Ç —Å–∏–≥–Ω–∞–ª.
        skip_header: –ï—Å–ª–∏ True, –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å –ø–µ—Ä–≤—É—é —Å—Ç—Ä–æ–∫—É (–∑–∞–≥–æ–ª–æ–≤–æ–∫).

    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç:
        1D np.ndarray —Å –¥–∞–Ω–Ω—ã–º–∏ —Å–∏–≥–Ω–∞–ª–∞.
    
    Raises:
        ValueError: –ï—Å–ª–∏ —Ñ–∞–π–ª –ø—É—Å—Ç–æ–π, –∫–æ–ª–æ–Ω–∫–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∏–ª–∏ —Ñ–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω.
    """
    path_obj = Path(path)
    
    if not path_obj.exists():
        raise ValueError(f"File not found: {path}")
    
    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —á–∏—Å–ª–æ —Å—Ç—Ä–æ–∫ –¥–ª—è –ø—Ä–æ–ø—É—Å–∫–∞
    skiprows = 1 if skip_header else 0
    
    try:
        # –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ
        data = np.loadtxt(path, delimiter=',', skiprows=skiprows, ndmin=2)
    except Exception as e:
        raise ValueError(f"Failed to load CSV file {path}: {e}")
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø—É—Å—Ç–æ–π —Ñ–∞–π–ª
    if data.size == 0:
        raise ValueError(f"File {path} is empty")
    
    # –ï—Å–ª–∏ –¥–∞–Ω–Ω—ã–µ –æ–¥–Ω–æ–º–µ—Ä–Ω—ã–µ, —Å–¥–µ–ª–∞—Ç—å –¥–≤—É–º–µ—Ä–Ω—ã–º–∏
    if data.ndim == 1:
        data = data.reshape(-1, 1)
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç–∏ –∏–Ω–¥–µ–∫—Å–∞ –∫–æ–ª–æ–Ω–∫–∏
    if column >= data.shape[1] or column < 0:
        raise ValueError(
            f"Column index {column} is out of range. "
            f"File has {data.shape[1]} columns (indices 0..{data.shape[1]-1})"
        )
    
    # –ò–∑–≤–ª–µ—á—å –Ω—É–∂–Ω—É—é –∫–æ–ª–æ–Ω–∫—É
    signal = data[:, column]
    
    return signal


def save_spectrum_npz(spectrum: Spectrum1D, path: str) -> None:
    """
    –°–æ—Ö—Ä–∞–Ω–∏—Ç—å Spectrum1D –≤ .npz (omega, power).
    
    Args:
        spectrum: –°–ø–µ–∫—Ç—Ä –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è.
        path: –ü—É—Ç—å –∫ —Ñ–∞–π–ª—É .npz.
    """
    np.savez(path, omega=spectrum.omega, power=spectrum.power)


def load_spectrum_npz(path: str) -> Spectrum1D:
    """
    –ó–∞–≥—Ä—É–∑–∏—Ç—å Spectrum1D –∏–∑ .npz.
    –û–∂–∏–¥–∞–µ—Ç –º–∞—Å—Å–∏–≤—ã 'omega' –∏ 'power'.
    
    Args:
        path: –ü—É—Ç—å –∫ —Ñ–∞–π–ª—É .npz.
    
    Returns:
        –ó–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–π Spectrum1D.
    
    Raises:
        ValueError: –ï—Å–ª–∏ —Ñ–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –æ–∂–∏–¥–∞–µ–º—ã–µ –∫–ª—é—á–∏.
    """
    path_obj = Path(path)
    
    if not path_obj.exists():
        raise ValueError(f"File not found: {path}")
    
    try:
        data = np.load(path)
    except Exception as e:
        raise ValueError(f"Failed to load .npz file {path}: {e}")
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö –∫–ª—é—á–µ–π
    if 'omega' not in data or 'power' not in data:
        raise ValueError(
            f"File {path} missing required keys. "
            f"Expected 'omega' and 'power', found: {list(data.keys())}"
        )
    
    omega = data['omega']
    power = data['power']
    
    return Spectrum1D(omega=omega, power=power)


def save_health_profile(profile: "HealthProfile", path: str) -> None:
    """
    –°–æ—Ö—Ä–∞–Ω–∏—Ç—å HealthProfile –≤ .npz.
    
    Args:
        profile: –ü—Ä–æ—Ñ–∏–ª—å –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è.
        path: –ü—É—Ç—å –∫ —Ñ–∞–π–ª—É .npz.
    """
    data = {}
    channel_names = []
    
    for name, signature in profile.signatures.items():
        channel_names.append(name)
        data[f"{name}_omega"] = signature.reference.omega
        data[f"{name}_power"] = signature.reference.power
        
    np.savez(path, channels=channel_names, **data)


def load_health_profile(path: str) -> "HealthProfile":
    """
    –ó–∞–≥—Ä—É–∑–∏—Ç—å HealthProfile –∏–∑ .npz.
    
    Args:
        path: –ü—É—Ç—å –∫ —Ñ–∞–π–ª—É .npz.
    
    Returns:
        –ó–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–π HealthProfile.
    """
    from .material import HealthProfile, MaterialSignature
    
    path_obj = Path(path)
    if not path_obj.exists():
        raise ValueError(f"File not found: {path}")
        
    try:
        data = np.load(path)
    except Exception as e:
        raise ValueError(f"Failed to load .npz file {path}: {e}")
        
    if 'channels' not in data:
        raise ValueError(f"File {path} is not a valid HealthProfile (missing 'channels')")
        
    signatures = {}
    for name in data['channels']:
        omega_key = f"{name}_omega"
        power_key = f"{name}_power"
        
        if omega_key not in data or power_key not in data:
            raise ValueError(f"Missing data for channel {name}")
            
        spec = Spectrum1D(omega=data[omega_key], power=data[power_key])
        signatures[str(name)] = MaterialSignature(reference=spec)
        
    return HealthProfile(signatures=signatures)




================================================================================
–§–ê–ô–õ: src\spectral_physics\ldos.py
================================================================================

import numpy as np

def ldos_from_modes(
    modes: np.ndarray,
    omegas: np.ndarray,
    freq_window: tuple[float, float],
) -> np.ndarray:
    """
    –û—Ü–µ–Ω–∫–∞ –ª–æ–∫–∞–ª—å–Ω–æ–π —Å–ø–µ–∫—Ç—Ä–∞–ª—å–Ω–æ–π –ø–ª–æ—Ç–Ω–æ—Å—Ç–∏ (LDOS) –Ω–∞ —Ä–µ—à—ë—Ç–∫–µ 2D.

    –ü–∞—Ä–∞–º–µ—Ç—Ä—ã:
        modes: –º–∞—Å—Å–∏–≤ —Ñ–æ—Ä–º—ã (N_points, N_modes),
               –∫–∞–∫ –≤–µ—Ä–Ω—É–ª OscillatorGrid2D.eigenmodes()
        omegas: –º–∞—Å—Å–∏–≤ (N_modes,) ‚Äî —á–∞—Å—Ç–æ—Ç—ã –º–æ–¥
        freq_window: (omega_min, omega_max) ‚Äî —á–∞—Å—Ç–æ—Ç–Ω–æ–µ –æ–∫–Ω–æ

    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç:
        ldos: –º–∞—Å—Å–∏–≤ (N_points,) ‚Äî "—Å–∏–ª–∞" –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Å–ø–µ–∫—Ç—Ä–∞
              –≤ –∑–∞–¥–∞–Ω–Ω–æ–º –æ–∫–Ω–µ —á–∞—Å—Ç–æ—Ç.
    –ò–¥–µ—è:
        —Å—É–º–º–∏—Ä–æ–≤–∞—Ç—å |mode_i|^2 –ø–æ —Ç–µ–º –º–æ–¥–∞–º, —É –∫–æ—Ç–æ—Ä—ã—Ö
        omega_i –ø–æ–ø–∞–¥–∞–µ—Ç –≤ –æ–∫–Ω–æ.
    """
    w_min, w_max = freq_window
    
    # –ú–∞—Å–∫–∞ —á–∞—Å—Ç–æ—Ç, –ø–æ–ø–∞–¥–∞—é—â–∏—Ö –≤ –æ–∫–Ω–æ
    mask = (omegas >= w_min) & (omegas <= w_max)
    
    if not np.any(mask):
        return np.zeros(modes.shape[0])
        
    # –í—ã–±–∏—Ä–∞–µ–º –Ω—É–∂–Ω—ã–µ –º–æ–¥—ã: (N_points, K_selected)
    selected_modes = modes[:, mask]
    
    # –°—É–º–º–∏—Ä—É–µ–º –∫–≤–∞–¥—Ä–∞—Ç—ã –∞–º–ø–ª–∏—Ç—É–¥ –ø–æ –º–æ–¥–∞–º (–≤–¥–æ–ª—å –æ—Å–∏ 1)
    # LDOS(x) = sum_i |psi_i(x)|^2
    ldos = np.sum(selected_modes**2, axis=1)
    
    return ldos



================================================================================
–§–ê–ô–õ: src\spectral_physics\material.py
================================================================================

import numpy as np
from dataclasses import dataclass
from .spectrum import Spectrum1D


@dataclass
class MaterialSignature:
    """
    –°–ø–µ–∫—Ç—Ä–∞–ª—å–Ω–∞—è –ø–æ–¥–ø–∏—Å—å –º–∞—Ç–µ—Ä–∏–∞–ª–∞/—É–∑–ª–∞.
    
    –°–æ–¥–µ—Ä–∂–∏—Ç:
    - –æ–ø–æ—Ä–Ω—ã–π —Å–ø–µ–∫—Ç—Ä (reference) –≤ –Ω–æ—Ä–º–∞–ª—å–Ω–æ–º —Å–æ—Å—Ç–æ—è–Ω–∏–∏,
    - –ø—Ä–æ—Å—Ç—É—é –º–µ—Ç—Ä–∏–∫—É "—Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è" –¥–æ –Ω–æ–≤–æ–≥–æ —Å–ø–µ–∫—Ç—Ä–∞.
    
    –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –¥–µ—Ç–µ–∫—Ü–∏–∏ –¥–µ—Ñ–µ–∫—Ç–æ–≤/–∞–Ω–æ–º–∞–ª–∏–π –ø–æ –∏–∑–º–µ–Ω–µ–Ω–∏—é
    —Å–ø–µ–∫—Ç—Ä–∞–ª—å–Ω—ã—Ö —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫.
    """
    reference: Spectrum1D
    
    def distance_l2(self, other: Spectrum1D) -> float:
        """
        L2-–Ω–æ—Ä–º–∞ –º–µ–∂–¥—É –Ω–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ —Å–ø–µ–∫—Ç—Ä–∞–º–∏.
        
        Args:
            other: –°–ø–µ–∫—Ç—Ä –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è —Å reference.
        
        Returns:
            L2-—Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É –Ω–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ —Å–ø–µ–∫—Ç—Ä–∞–º–∏.
        
        Raises:
            ValueError: –ï—Å–ª–∏ —Å–µ—Ç–∫–∏ –ø–æ —á–∞—Å—Ç–æ—Ç–µ –Ω–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç.
        
        Notes:
            –°–ø–µ–∫—Ç—Ä—ã –Ω–æ—Ä–º–∏—Ä—É—é—Ç—Å—è –ø–µ—Ä–µ–¥ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ–º, —á—Ç–æ–±—ã —Ä–∞–∑–ª–∏—á–∏—è
            –≤ –∞–º–ø–ª–∏—Ç—É–¥–µ –Ω–µ –≤–ª–∏—è–ª–∏ –Ω–∞ –¥–µ—Ç–µ–∫—Ü–∏—é –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ñ–æ—Ä–º—ã —Å–ø–µ–∫—Ç—Ä–∞.
        """
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è —á–∞—Å—Ç–æ—Ç–Ω—ã—Ö —Å–µ—Ç–æ–∫
        if not np.array_equal(self.reference.omega, other.omega):
            raise ValueError(
                "Frequency grids do not match. "
                f"Reference has {len(self.reference.omega)} points, "
                f"other has {len(other.omega)} points. "
                "Cannot compute distance."
            )
        
        # –ù–æ—Ä–º–∏—Ä—É–µ–º –æ–±–∞ —Å–ø–µ–∫—Ç—Ä–∞
        ref_normalized = self.reference.normalize()
        other_normalized = other.normalize()
        
        # –í—ã—á–∏—Å–ª—è–µ–º L2-—Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ
        diff = ref_normalized.power - other_normalized.power
        distance = np.sqrt(np.sum(diff ** 2))
        
        return float(distance)
    
    def distance_cosine(self, other: Spectrum1D) -> float:
        """
        –ö–æ—Å–∏–Ω—É—Å–Ω–∞—è "–¥–∏—Å—Ç–∞–Ω—Ü–∏—è" –º–µ–∂–¥—É –Ω–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ —Å–ø–µ–∫—Ç—Ä–∞–º–∏:
            1 - (‚ü®a,b‚ü© / (||a|| * ||b||))
        
        Args:
            other: –°–ø–µ–∫—Ç—Ä –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è.
        
        Returns:
            –ö–æ—Å–∏–Ω—É—Å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ (0..1 –¥–ª—è –Ω–µ–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã—Ö —Å–ø–µ–∫—Ç—Ä–æ–≤).
        """
        if not np.array_equal(self.reference.omega, other.omega):
            raise ValueError("Frequency grids do not match")
        
        # –†–∞–±–æ—Ç–∞–µ–º —Å –≤–µ–∫—Ç–æ—Ä–∞–º–∏ –º–æ—â–Ω–æ—Å—Ç–∏
        a = self.reference.power
        b = other.power
        
        norm_a = np.linalg.norm(a)
        norm_b = np.linalg.norm(b)
        
        if norm_a == 0 or norm_b == 0:
            # –ï—Å–ª–∏ –æ–¥–∏–Ω –∏–∑ –≤–µ–∫—Ç–æ—Ä–æ–≤ –Ω—É–ª–µ–≤–æ–π, —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –Ω–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ (–∏–ª–∏ –º–∞–∫—Å)
            return 1.0
            
        cosine_similarity = np.dot(a, b) / (norm_a * norm_b)
        
        # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º [0, 1] –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏
        cosine_similarity = np.clip(cosine_similarity, 0.0, 1.0)
        
        return 1.0 - cosine_similarity

    def is_anomalous(self, other: Spectrum1D, threshold: float) -> bool:

        """
        –í–µ—Ä–Ω—É—Ç—å True, –µ—Å–ª–∏ distance_l2(other) > threshold.
        
        Args:
            other: –°–ø–µ–∫—Ç—Ä –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏.
            threshold: –ü–æ—Ä–æ–≥ –∞–Ω–æ–º–∞–ª—å–Ω–æ—Å—Ç–∏.
        
        Returns:
            True –µ—Å–ª–∏ —Å–ø–µ–∫—Ç—Ä –∞–Ω–æ–º–∞–ª–µ–Ω, False –∏–Ω–∞—á–µ.
        
        Raises:
            ValueError: –ï—Å–ª–∏ —Å–µ—Ç–∫–∏ –ø–æ —á–∞—Å—Ç–æ—Ç–µ –Ω–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç.
        
        Example:
            >>> sig = MaterialSignature(reference=normal_spectrum)
            >>> if sig.is_anomalous(test_spectrum, threshold=0.1):
            ...     print("–û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ –∞–Ω–æ–º–∞–ª–∏—è!")
        """
        distance = self.distance_l2(other)
        return distance > threshold


@dataclass
class FeatureSignature:
    """
    –°–ø–µ–∫—Ç—Ä–∞–ª—å–Ω–∞—è —Å–∏–≥–Ω–∞—Ç—É—Ä–∞ –Ω–∞ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ —Ñ–∏—á.
    """
    reference_features: np.ndarray

    def distance_l2(self, other_features: np.ndarray) -> float:
        if other_features.shape != self.reference_features.shape:
            raise ValueError("Feature vector shape mismatch")
        diff = self.reference_features - other_features
        return float(np.sqrt(np.sum(diff**2)))


@dataclass
class HealthProfile:
    """
    –≠—Ç–∞–ª–æ–Ω–Ω—ã–π –ø—Ä–æ—Ñ–∏–ª—å "–∑–¥–æ—Ä–æ–≤–æ–≥–æ" —Å–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –∫–∞–Ω–∞–ª–æ–≤.
    """
    signatures: dict[str, MaterialSignature]  # –∏–º—è –∫–∞–Ω–∞–ª–∞ -> –ø–æ–¥–ø–∏—Å—å
    feature_signatures: dict[str, FeatureSignature] | None = None

    def score(self, current: dict[str, Spectrum1D]) -> dict[str, float]:
        """
        –í–µ—Ä–Ω—É—Ç—å —Å–ª–æ–≤–∞—Ä—å name -> distance_l2 –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–∞–Ω–∞–ª–∞.
        –ö–∞–Ω–∞–ª –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É–µ—Ç –≤ signatures –∏ –≤ current.
        """
        scores = {}
        for name, signature in self.signatures.items():
            if name in current:
                scores[name] = signature.distance_l2(current[name])
        return scores

    def score_features(
        self,
        current: dict[str, Spectrum1D],
        bands_hz: dict[str, list[tuple[float, float]]],
    ) -> dict[str, float]:
        """
        –î–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–∞–Ω–∞–ª–∞:
        - –∏–∑–≤–ª–µ—á—å —Ñ–∏—á–∏,
        - –ø–æ—Å—á–∏—Ç–∞—Ç—å L2-–¥–∏—Å—Ç–∞–Ω—Ü–∏—é –≤ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ —Ñ–∏—á.
        """
        from .diagnostics import extract_features
        
        if self.feature_signatures is None:
            return {}
            
        scores = {}
        for name, feat_sig in self.feature_signatures.items():
            if name in current and name in bands_hz:
                spec = current[name]
                bands = bands_hz[name]
                feats = extract_features(spec, bands)
                scores[name] = feat_sig.distance_l2(feats)
        return scores

    def is_anomalous(
        self,
        current: dict[str, Spectrum1D],
        thresholds: dict[str, float],
    ) -> dict[str, bool]:
        """
        –í–µ—Ä–Ω—É—Ç—å —Å–ª–æ–≤–∞—Ä—å name -> bool (–∞–Ω–æ–º–∞–ª–µ–Ω / –Ω–µ—Ç)
        –ø–æ –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã–º –ø–æ—Ä–æ–≥–∞–º –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–∞–Ω–∞–ª–∞.
        """
        results = {}
        for name, signature in self.signatures.items():
            if name in current and name in thresholds:
                results[name] = signature.is_anomalous(current[name], thresholds[name])
        return results





================================================================================
–§–ê–ô–õ: src\spectral_physics\materials.py
================================================================================

from dataclasses import dataclass
import numpy as np
from .atoms import AtomicResonator
from .spectrum import Spectrum1D

@dataclass
class MaterialPatch:
    """
    –£—á–∞—Å—Ç–æ–∫ –º–∞—Ç–µ—Ä–∏–∞–ª–∞ –∫–∞–∫ "–∞—Ç–æ–º–Ω–∞—è —Å–º–µ—Å—å" –ø–ª—é—Å —Å—Ä–µ–¥–∞.
    """
    atoms: list[AtomicResonator]
    weights: np.ndarray  # –¥–æ–ª–∏ –∫–∞–∂–¥–æ–≥–æ –∞—Ç–æ–º–∞ (—Å—É–º–º–∞ = 1)

    def surface_spectrum(self) -> Spectrum1D:
        """
        –°—É–º–º–∞—Ä–Ω—ã–π —Å–ø–µ–∫—Ç—Ä –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏:
        –≤–∑–≤–µ—à–µ–Ω–Ω–∞—è —Å—É–º–º–∞ —Å–ø–µ–∫—Ç—Ä–æ–≤ –∞—Ç–æ–º–æ–≤.
        """
        if not self.atoms:
            return Spectrum1D(omega=np.array([]), power=np.array([]))
            
        # –î–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã –æ–±—ä–µ–¥–∏–Ω–∏–º –≤—Å–µ —á–∞—Å—Ç–æ—Ç—ã –∏ –ø—Ä–æ—Å—É–º–º–∏—Ä—É–µ–º –º–æ—â–Ω–æ—Å—Ç–∏
        # (–ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º –¥–∏—Å–∫—Ä–µ—Ç–Ω—ã–µ –ª–∏–Ω–∏–∏)
        
        all_freqs = []
        all_powers = []
        
        for atom, w in zip(self.atoms, self.weights):
            spec = atom.spectrum()
            all_freqs.extend(spec.omega)
            all_powers.extend(spec.power * w)
            
        all_freqs = np.array(all_freqs)
        all_powers = np.array(all_powers)
        
        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —á–∞—Å—Ç–æ—Ç–µ
        idx = np.argsort(all_freqs)
        sorted_freqs = all_freqs[idx]
        sorted_powers = all_powers[idx]
        
        # –ú–æ–∂–Ω–æ –æ–±—ä–µ–¥–∏–Ω–∏—Ç—å —Å–æ–≤–ø–∞–¥–∞—é—â–∏–µ —á–∞—Å—Ç–æ—Ç—ã, –Ω–æ Spectrum1D —ç—Ç–æ–≥–æ –Ω–µ —Ç—Ä–µ–±—É–µ—Ç
        return Spectrum1D(omega=sorted_freqs, power=sorted_powers)


def effective_coupling(
    ldos: np.ndarray,
    patch: MaterialPatch,
    freq_window: tuple[float, float],
) -> float:
    """
    –û—Ü–µ–Ω–∫–∞ —Ç–æ–≥–æ, –Ω–∞—Å–∫–æ–ª—å–∫–æ –¥–∞–Ω–Ω—ã–π —É—á–∞—Å—Ç–æ–∫ –º–∞—Ç–µ—Ä–∏–∞–ª–∞ "–∑–≤—É—á–∏—Ç"
    –≤ –¥–∞–Ω–Ω–æ–º —á–∞—Å—Ç–æ—Ç–Ω–æ–º –æ–∫–Ω–µ –°—Ä–µ–¥—ã.

    –ò–¥–µ—è:
      - –∏–∑ patch.surface_spectrum() –≤–∑—è—Ç—å Spectrum1D
      - –æ–≥—Ä–∞–Ω–∏—á–∏—Ç—å –µ–≥–æ freq_window
      - —É–º–Ω–æ–∂–∏—Ç—å –∏–Ω—Ç–µ–≥—Ä–∞–ª—å–Ω—É—é –º–æ—â–Ω–æ—Å—Ç—å –Ω–∞ —Å—Ä–µ–¥–Ω–∏–π —É—Ä–æ–≤–µ–Ω—å LDOS
        (–Ω–∞–ø—Ä–∏–º–µ—Ä, <ldos> –ø–æ –æ–±–ª–∞—Å—Ç–∏ –∏–Ω—Ç–µ—Ä–µ—Å–∞)
    
    Args:
        ldos: –º–∞—Å—Å–∏–≤ LDOS –∑–Ω–∞—á–µ–Ω–∏–π (–Ω–∞–ø—Ä–∏–º–µ—Ä, –∫–∞—Ä—Ç–∞ –∏–ª–∏ —Å—Ä–µ–∑).
        patch: MaterialPatch.
        freq_window: (w_min, w_max).
    """
    spec = patch.surface_spectrum()
    
    # –§–∏–ª—å—Ç—Ä—É–µ–º —Å–ø–µ–∫—Ç—Ä –ø–∞—Ç—á–∞ –ø–æ –æ–∫–Ω—É
    w_min, w_max = freq_window
    mask = (spec.omega >= w_min) & (spec.omega <= w_max)
    
    if not np.any(mask):
        return 0.0
        
    patch_power = np.sum(spec.power[mask])
    
    # –°—Ä–µ–¥–Ω–∏–π LDOS
    avg_ldos = np.mean(ldos)
    
    return float(patch_power * avg_ldos)

def build_material_health_profile(ldos_map: np.ndarray) -> "FeatureSignature":
    """
    –°—Ç—Ä–æ–∏–º "–∑–¥–æ—Ä–æ–≤—ã–π" –ø—Ä–æ—Ñ–∏–ª—å –¥–ª—è –º–∞—Ç–µ—Ä–∏–∞–ª–∞:
    - flatten ldos_map
    - –∏–∑–≤–ª–µ–∫–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ (mean, std, PCA –∏ —Ç.–¥. ‚Äî —Å–º. spectral-health)
    - –ø–æ–ª—É—á–∞–µ–º –∫–æ–º–ø–∞–∫—Ç–Ω—ã–π –≤–µ–∫—Ç–æ—Ä health-–ø–æ–¥–ø–∏—Å–∏.
    
    –î–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã: –≤–µ–∫—Ç–æ—Ä = [mean, std, max, min, median]
    """
    from .material import FeatureSignature
    
    flat = ldos_map.flatten()
    features = np.array([
        np.mean(flat),
        np.std(flat),
        np.max(flat),
        np.min(flat),
        np.median(flat)
    ])
    
    return FeatureSignature(reference_features=features)



================================================================================
–§–ê–ô–õ: src\spectral_physics\medium_1d.py
================================================================================

import numpy as np
import scipy.linalg
from dataclasses import dataclass


@dataclass
class OscillatorChain1D:
    """
    Linear chain of coupled oscillators (toy model of a medium).
    
    Attributes:
        n: Number of oscillators.
        k: Coupling stiffness between neighbors.
        m: Mass of each oscillator.
        gamma: Damping coefficient (optional, default 0.0).
    """
    n: int
    k: float | np.ndarray
    m: float | np.ndarray
    gamma: float = 0.0
    
    def __post_init__(self):
        """Validate parameters."""
        if self.n < 1:
            raise ValueError("Number of oscillators must be >= 1")
            
        # Validate mass
        if np.any(np.asarray(self.m) <= 0):
            raise ValueError("Mass must be positive")
            
        # Validate stiffness
        if np.any(np.asarray(self.k) < 0):
            raise ValueError("Stiffness must be non-negative")
            
        if self.gamma < 0:
            raise ValueError("Damping must be non-negative")
    
    def stiffness_matrix(self) -> np.ndarray:
        """
        Construct the stiffness matrix for the chain with nearest-neighbor coupling.
        
        Boundary conditions: Fixed ends (both ends are anchored).
        
        If k is scalar: uniform stiffness.
        If k is array: k[i] is stiffness between node i and i+1.
        Wait, we have N nodes. We have N+1 springs if fixed walls?
        Or N-1 springs between nodes?
        
        Let's assume:
        - If k is scalar: all springs are k (including walls).
        - If k is array: it must have length N-1 (internal springs) or N+1 (all springs).
        
        For LayeredMedium1D, I passed k of length N-1.
        So let's assume walls have "default" stiffness or same as nearest?
        
        Let's standardize:
        If k is array of length N-1:
           k[i] connects node i and i+1.
           Wall-0 connection: use k[0] (or some default?)
           (N-1)-Wall connection: use k[N-2]
           
        Actually, in LayeredMedium1D, I calculate k_springs for N-1 intervals.
        I didn't specify wall stiffness.
        
        Let's assume for now that if k is array (N-1), we use k[0] for left wall and k[-1] for right wall.
        """
        N = self.n
        K = np.zeros((N, N))
        
        # Helper to get k for interval i (between node i and i+1)
        # i goes from -1 (left wall) to N-1 (right wall)
        
        k_arr = np.asarray(self.k)
        if k_arr.ndim == 0:
            # Scalar
            k_vals = np.full(N + 1, float(k_arr))
        else:
            # Array
            if len(k_arr) == N - 1:
                # Pad with edge values for walls
                k_vals = np.zeros(N + 1)
                k_vals[1:-1] = k_arr
                k_vals[0] = k_arr[0]
                k_vals[-1] = k_arr[-1]
            elif len(k_arr) == N + 1:
                k_vals = k_arr
            else:
                raise ValueError(f"Stiffness array length must be {N-1} or {N+1}")
        
        # k_vals[i] is spring between node i-1 and i?
        # Let's say indices 0..N are springs.
        # Spring 0: Wall -> Node 0
        # Spring 1: Node 0 -> Node 1
        # ...
        # Spring N: Node N-1 -> Wall
        
        # Re-map k_vals to this logic
        # If we had N-1 internal springs (0..N-2), they correspond to indices 1..N-1 in my new list.
        
        # Let's build K
        for i in range(N):
            # Node i
            
            # Spring to left (index i)
            k_left = k_vals[i]
            K[i, i] += k_left
            if i > 0:
                K[i, i-1] = -k_left
                
            # Spring to right (index i+1)
            k_right = k_vals[i+1]
            K[i, i] += k_right
            if i < N - 1:
                K[i, i+1] = -k_right
                
        return K
    
    def eigenmodes(self) -> tuple[np.ndarray, np.ndarray]:
        """
        Compute eigenfrequencies and eigenmodes of the oscillator chain.
        
        Solves the eigenvalue problem: K * v = (m * omega^2) * v
        where K is the stiffness matrix.
        
        Returns:
            omega: Array of eigenfrequencies (sorted, >= 0).
            modes: Matrix of eigenvectors (n, n), each column is a mode.
        
        Note:
            Eigenfrequencies are angular frequencies (rad/s).
            Modes are normalized eigenvectors.
        """
    def eigenmodes(self) -> tuple[np.ndarray, np.ndarray]:
        """
        Compute eigenfrequencies and eigenmodes of the oscillator chain.
        
        Solves the generalized eigenvalue problem: K * v = (omega^2 * M) * v
        where K is stiffness matrix, M is mass matrix (diagonal).
        
        Returns:
            omega: Array of eigenfrequencies (sorted, >= 0).
            modes: Matrix of eigenvectors (n, n), each column is a mode.
        """
        K = self.stiffness_matrix()
        
        # Mass matrix
        m_arr = np.asarray(self.m)
        if m_arr.ndim == 0:
            # Uniform mass
            M = np.diag(np.full(self.n, float(m_arr)))
        else:
            M = np.diag(m_arr)
            
        # Solve generalized eigenvalue problem
        # K * v = lambda * M * v
        # lambda = omega^2
        eigenvalues, eigenvectors = scipy.linalg.eigh(K, b=M)
        
        # Convert eigenvalues to frequencies
        # lambda = omega^2 => omega = sqrt(lambda)
        eigenvalues = np.maximum(eigenvalues, 0.0)
        omega = np.sqrt(eigenvalues)
        
        return omega, eigenvectors



================================================================================
–§–ê–ô–õ: src\spectral_physics\medium_2d.py
================================================================================

import numpy as np
import scipy.linalg
import scipy.sparse
import scipy.sparse.linalg
from dataclasses import dataclass

@dataclass
class OscillatorGrid2D:
    """
    2D —Å–µ—Ç–∫–∞ —Å–≤—è–∑–∞–Ω–Ω—ã—Ö –æ—Å—Ü–∏–ª–ª—è—Ç–æ—Ä–æ–≤ (–∏–≥—Ä—É—à–µ—á–Ω–∞—è –º–æ–¥–µ–ª—å —É–ø—Ä—É–≥–æ–π –ø–ª–∞—Å—Ç–∏–Ω—ã).

    –°—Ö–µ–º–∞:
    - –∫–∞–∂–¥–∞—è —Ç–æ—á–∫–∞ (i, j) —Å–≤—è–∑–∞–Ω–∞ —Å —Å–æ—Å–µ–¥—è–º–∏ –ø–æ x –∏ y
    - –≤–æ–∑–º–æ–∂–Ω—ã —Ä–∞–∑–Ω—ã–µ –∂—ë—Å—Ç–∫–æ—Å—Ç–∏ kx, ky
    - –º–∞—Å—Å–∞ –≤ —É–∑–ª–µ –æ–¥–Ω–∞ –∏ —Ç–∞ –∂–µ
    - –ì—Ä–∞–Ω–∏—á–Ω—ã–µ —É—Å–ª–æ–≤–∏—è: –∑–∞–∫—Ä–µ–ø–ª—ë–Ω–Ω—ã–µ –∫—Ä–∞—è (–Ω—É–ª–µ–≤–æ–µ —Å–º–µ—â–µ–Ω–∏–µ –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ —Å–µ—Ç–∫–∏).
    """
    nx: int
    ny: int
    kx: float
    ky: float
    m: float
    
    # Optional local parameters (defects)
    mass_map: np.ndarray | None = None  # (ny, nx)
    kx_map: np.ndarray | None = None    # (ny, nx) - stiffness to right neighbor?
    # Let's define: kx_map[i, j] is stiffness between (i,j) and (i,j+1)
    # ky_map[i, j] is stiffness between (i,j) and (i+1,j)
    # Or simpler: kx_map[i, j] is "local stiffness coefficient" for node (i,j) in x-direction
    # Let's stick to the simple model: 
    # kx_map[i, j] overrides self.kx for connections involving node (i,j).
    # But connections are shared. Let's say connection (i,j)-(i,j+1) uses average or min?
    # Simpler: kx_map defines the link to the RIGHT (j+1)
    # ky_map defines the link to the DOWN (i+1)
    # This is unambiguous.
    
    ky_map: np.ndarray | None = None

    def stiffness_matrix(self) -> np.ndarray:
        """
        –°–æ–±—Ä–∞—Ç—å –º–∞—Ç—Ä–∏—Ü—É –∂—ë—Å—Ç–∫–æ—Å—Ç–∏ —Ä–∞–∑–º–µ—Ä–∞ (nx*ny, nx*ny).
        –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è 5-—Ç–æ—á–µ—á–Ω—ã–π —à–∞–±–ª–æ–Ω (—Ü–µ–Ω—Ç—Ä, –ª–µ–≤–æ, –ø—Ä–∞–≤–æ, –≤–µ—Ä—Ö, –Ω–∏–∑).
        
        –ò–Ω–¥–µ–∫—Å–∞—Ü–∏—è: k = i * nx + j, –≥–¥–µ i - —Å—Ç—Ä–æ–∫–∞ (0..ny-1), j - —Å—Ç–æ–ª–±–µ—Ü (0..nx-1).
        """
        N = self.nx * self.ny
        K = np.zeros((N, N))
        
        # Helper to get stiffness
        def get_kx(i, j):
            if self.kx_map is not None:
                return self.kx_map[i, j]
            return self.kx
            
        def get_ky(i, j):
            if self.ky_map is not None:
                return self.ky_map[i, j]
            return self.ky
        
        for i in range(self.ny):
            for j in range(self.nx):
                k = i * self.nx + j
                
                diag_val = 0.0
                
                # Link to Right (j+1)
                if j < self.nx - 1:
                    kval = get_kx(i, j)
                    k_right = i * self.nx + (j + 1)
                    
                    K[k, k] += kval
                    K[k_right, k_right] += kval
                    K[k, k_right] = -kval
                    K[k_right, k] = -kval
                else:
                    # Boundary condition: fixed wall on the right?
                    # Original code: 
                    # diag_val += self.kx (always added for left/right)
                    # If we follow original logic: "spring exists always"
                    # For right boundary: spring connects to wall.
                    kval = get_kx(i, j)
                    K[k, k] += kval
                    
                # Link to Left (j-1)
                # Handled by (j-1)'s link to Right?
                # No, we iterate all nodes.
                # Let's be careful not to double count if we iterate all.
                # Standard assembly: iterate elements (springs) or nodes?
                # If iterating nodes, we add contribution of all connected springs.
                pass

        # Re-implementing with clear "spring-based" assembly to avoid confusion
        K = np.zeros((N, N))
        
        # 1. Horizontal springs
        for i in range(self.ny):
            for j in range(self.nx):
                # Spring to the right of (i,j)
                # Connects (i,j) and (i,j+1) OR (i,j) and Wall
                
                k_curr = i * self.nx + j
                kval = get_kx(i, j)
                
                # Add to current node diagonal
                K[k_curr, k_curr] += kval
                
                if j < self.nx - 1:
                    k_right = i * self.nx + (j + 1)
                    K[k_right, k_right] += kval
                    K[k_curr, k_right] = -kval
                    K[k_right, k_curr] = -kval
                # If j == nx-1, it connects to wall (displacement 0), so only diagonal term remains.
                
                # Wait, what about the spring to the LEFT of (i,0)?
                # We need a spring there too if boundaries are fixed.
                # My previous logic: "diag_val += self.kx" implied spring to left and right.
                # So we need to iterate j from -1 to nx-1?
                # Let's assume:
                # Node j has spring to j+1 (defined by kx_map[i,j])
                # Node j has spring to j-1 (defined by kx_map[i,j-1]?)
                # Boundary: Wall -> Node 0. Let's say this is defined by kx_map[i, -1] ?? No.
                
                # Let's assume kx_map has shape (ny, nx+1) to cover all intervals?
                # Or just use kx_map for internal links and kx for boundaries?
                # Or simpler: kx_map[i,j] is the spring to the RIGHT of node j.
                # And we assume default kx for the spring to the LEFT of node 0.
                pass
        
        # Let's stick to the node-based logic but be consistent.
        # Node (i,j) is connected to:
        # Left: (i, j-1). Stiffness? Use get_kx(i, j-1) if j>0. If j=0, use get_kx(i, -1)?
        # Right: (i, j+1). Stiffness? Use get_kx(i, j).
        
        # To make it symmetric and simple:
        # kx_map[i, j] is the stiffness of the link between (i,j) and (i,j+1).
        # For boundary springs (Wall-0 and (N-1)-Wall), let's use self.kx (global).
        
        K = np.zeros((N, N))
        
        for i in range(self.ny):
            for j in range(self.nx):
                k_curr = i * self.nx + j
                
                # --- Horizontal ---
                
                # Link Left: (i, j-1) <-> (i, j)
                if j == 0:
                    k_left_val = self.kx # Wall
                else:
                    k_left_val = get_kx(i, j-1)
                    k_left = i * self.nx + (j - 1)
                    K[k_curr, k_left] = -k_left_val
                
                K[k_curr, k_curr] += k_left_val
                
                # Link Right: (i, j) <-> (i, j+1)
                if j == self.nx - 1:
                    k_right_val = self.kx # Wall
                else:
                    k_right_val = get_kx(i, j)
                    k_right = i * self.nx + (j + 1)
                    K[k_curr, k_right] = -k_right_val
                    
                K[k_curr, k_curr] += k_right_val
                
                # --- Vertical ---
                
                # Link Up: (i-1, j) <-> (i, j)
                if i == 0:
                    k_up_val = self.ky # Wall
                else:
                    k_up_val = get_ky(i-1, j)
                    k_up = (i - 1) * self.nx + j
                    K[k_curr, k_up] = -k_up_val
                    
                K[k_curr, k_curr] += k_up_val
                
                # Link Down: (i, j) <-> (i+1, j)
                if i == self.ny - 1:
                    k_down_val = self.ky # Wall
                else:
                    k_down_val = get_ky(i, j)
                    k_down = (i + 1) * self.nx + j
                    K[k_curr, k_down] = -k_down_val
                    
                K[k_curr, k_curr] += k_down_val
                
        return K

    def eigenmodes(self, n_modes: int | None = None) -> tuple[np.ndarray, np.ndarray]:
        """
        –ù–∞–π—Ç–∏ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ —á–∞—Å—Ç–æ—Ç—ã –∏ –º–æ–¥—ã.
        """
        K = self.stiffness_matrix()
        
        # Mass matrix M
        if self.mass_map is not None:
            m_vec = self.mass_map.flatten()
        else:
            m_vec = np.full(self.nx * self.ny, self.m)
            
        # Generalized eigenvalue problem: K v = lambda M v
        # Since M is diagonal, we can transform to standard EVP:
        # M^(-1/2) K M^(-1/2) u = lambda u, where v = M^(-1/2) u
        # Or just use eigh with b argument (if positive definite)
        
        # Let's use eigh(K, b=M) if possible, but M is diagonal array.
        # scipy.linalg.eigh supports b as matrix.
        M = np.diag(m_vec)
        
        if n_modes is not None and n_modes < len(m_vec):
             eigvals, eigvecs = scipy.linalg.eigh(
                K, b=M,
                subset_by_index=(0, n_modes - 1)
            )
        else:
            eigvals, eigvecs = scipy.linalg.eigh(K, b=M)
            
        eigvals = np.maximum(eigvals, 0.0)
        omega = np.sqrt(eigvals) # lambda = omega^2 (mass is already in M)
        
        return omega, eigvecs
        omega = np.sqrt(eigvals / self.m)
        
        return omega, eigvecs

    def ldos_map(
        self,
        n_modes: int,
        freq_window: tuple[float, float],
    ) -> np.ndarray:
        """
        –í–µ—Ä–Ω—É—Ç—å LDOS-–∫–∞—Ä—Ç—É —Ñ–æ—Ä–º—ã (ny, nx) –≤ –∑–∞–¥–∞–Ω–Ω–æ–º —á–∞—Å—Ç–æ—Ç–Ω–æ–º –æ–∫–Ω–µ.
        –ò—Å–ø–æ–ª—å–∑—É–µ—Ç eigenmodes(...) + ldos_from_modes(...).
        """
        from .ldos import ldos_from_modes
        
        omega, modes = self.eigenmodes(n_modes=n_modes)
        ldos_flat = ldos_from_modes(modes, omega, freq_window)
        
        return ldos_flat.reshape((self.ny, self.nx))



================================================================================
–§–ê–ô–õ: src\spectral_physics\report.py
================================================================================

from typing import Dict
import datetime

def generate_markdown_report(
    scores: Dict[str, float],
    thresholds: Dict[str, float],
    out_path: str,
    title: str = "Spectral Health Report",
) -> None:
    """
    –°–æ—Ö—Ä–∞–Ω–∏—Ç—å markdown-—Ñ–∞–π–ª —Å —Ç–∞–±–ª–∏—Ü–µ–π –ø–æ –∫–∞–Ω–∞–ª–∞–º.
    
    Args:
        scores: –°–ª–æ–≤–∞—Ä—å {–∏–º—è_–∫–∞–Ω–∞–ª–∞: –¥–∏—Å—Ç–∞–Ω—Ü–∏—è}.
        thresholds: –°–ª–æ–≤–∞—Ä—å {–∏–º—è_–∫–∞–Ω–∞–ª–∞: –ø–æ—Ä–æ–≥}.
        out_path: –ü—É—Ç—å –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –æ—Ç—á–µ—Ç–∞.
        title: –ó–∞–≥–æ–ª–æ–≤–æ–∫ –æ—Ç—á–µ—Ç–∞.
    """
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    lines = [
        f"# {title}",
        f"",
        f"**Date:** {timestamp}",
        f"",
        f"## Channel Status",
        f"",
        f"| Channel | Distance | Threshold | Status |",
        f"|---------|----------|-----------|--------|"
    ]
    
    any_anomaly = False
    
    for name, distance in scores.items():
        threshold = thresholds.get(name, 0.0)
        is_anom = distance > threshold
        status = "üî¥ **ANOMALY**" if is_anom else "üü¢ OK"
        
        if is_anom:
            any_anomaly = True
            
        lines.append(
            f"| `{name}` | {distance:.6f} | {threshold:.6f} | {status} |"
        )
        
    lines.append("")
    
    if any_anomaly:
        lines.append("> [!WARNING]")
        lines.append("> Anomalies detected! Please check the affected channels.")
    else:
        lines.append("> [!NOTE]")
        lines.append("> All systems nominal.")
        
    with open(out_path, 'w', encoding='utf-8') as f:
        f.write("\n".join(lines))



================================================================================
–§–ê–ô–õ: src\spectral_physics\root_finding.py
================================================================================

import numpy as np
from typing import Callable, Tuple


def symmetric_newton(
    f: Callable[[float], float],
    x0: float,
    h0: float = 1e-3,
    max_iter: int = 50,
    tol: float = 1e-10,
    tol_step: float = 1e-12,
) -> Tuple[float, int]:
    """
    –ù–∞–π—Ç–∏ –∫–æ—Ä–µ–Ω—å —É—Ä–∞–≤–Ω–µ–Ω–∏—è f(x) = 0 —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω—ã–º –º–µ—Ç–æ–¥–æ–º –ù—å—é—Ç–æ–Ω–∞,
    –Ω–µ –∏—Å–ø–æ–ª—å–∑—É—è –∞–Ω–∞–ª–∏—Ç–∏—á–µ—Å–∫—É—é –ø—Ä–æ–∏–∑–≤–æ–¥–Ω—É—é.

    –ò—Å–ø–æ–ª—å–∑—É–µ—Ç —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω—É—é —Ä–∞–∑–Ω–æ—Å—Ç–Ω—É—é –ø—Ä–æ–∏–∑–≤–æ–¥–Ω—É—é:
        f'(x) ‚âà (f(x + h) - f(x - h)) / (2*h)

    –∏ –∞–¥–∞–ø—Ç–∏–≤–Ω–æ —É–º–µ–Ω—å—à–∞–µ—Ç h, –µ—Å–ª–∏ —à–∞–≥ –ø–æ–ª—É—á–∞–µ—Ç—Å—è —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–∏–º
    –∏–ª–∏ –º–µ—Ç–æ–¥ –Ω–∞—á–∏–Ω–∞–µ—Ç —Ä–∞—Å—Ö–æ–¥–∏—Ç—å—Å—è.

    –ü–∞—Ä–∞–º–µ—Ç—Ä—ã:
        f: –≤—ã–∑—ã–≤–∞–µ–º–∞—è —Ñ—É–Ω–∫—Ü–∏—è f(x) -> float
        x0: –Ω–∞—á–∞–ª—å–Ω–æ–µ –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏–µ
        h0: –Ω–∞—á–∞–ª—å–Ω—ã–π —à–∞–≥ –¥–ª—è —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω–æ–π —Ä–∞–∑–Ω–æ—Å—Ç–∏
        max_iter: –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ —á–∏—Å–ª–æ –∏—Ç–µ—Ä–∞—Ü–∏–π
        tol: –¥–æ–ø—É—Å–∫ –ø–æ |f(x)|
        tol_step: –¥–æ–ø—É—Å–∫ –ø–æ –≤–µ–ª–∏—á–∏–Ω–µ —à–∞–≥–∞ |delta|

    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç:
        x_root: –Ω–∞–π–¥–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ x, –¥–ª—è –∫–æ—Ç–æ—Ä–æ–≥–æ f(x) ‚âà 0
        n_iter: —á–∏—Å–ª–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã—Ö –∏—Ç–µ—Ä–∞—Ü–∏–π
    
    Raises:
        ValueError: –µ—Å–ª–∏ –º–µ—Ç–æ–¥ —Ä–∞—Å—Ö–æ–¥–∏—Ç—Å—è (|x| —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–∏–º)
        
    Notes:
        –§—É–Ω–∫—Ü–∏—è –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç—Å—è, –µ—Å–ª–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ –õ–Æ–ë–û–ï –∏–∑ —É—Å–ª–æ–≤–∏–π:
        - |f(x)| < tol
        - |delta| < tol_step (–ø–æ–ª–µ–∑–Ω–æ –Ω–∞ –ø–ª–æ—Å–∫–∏—Ö —É—á–∞—Å—Ç–∫–∞—Ö)
        - –¥–æ—Å—Ç–∏–≥–Ω—É—Ç–æ max_iter
    """
    x = float(x0)
    h = float(h0)
    
    for i in range(max_iter):
        fx = f(x)
        
        # Check convergence by function value
        if abs(fx) < tol:
            return x, i
        
        # Check for divergence
        if abs(x) > 1e10:
            raise ValueError(f"Method diverged: |x| = {abs(x)} > 1e10")
        
        # Symmetric difference derivative
        # f'(x) ‚âà (f(x + h) - f(x - h)) / (2h)
        try:
            df = (f(x + h) - f(x - h)) / (2 * h)
        except Exception as e:
            raise ValueError(f"Failed to compute derivative at x={x}: {e}")
        
        # Protect against division by near-zero derivative
        if abs(df) < 1e-14:
            # Try reducing h
            h = h / 2
            if h < 1e-15:
                # Give up
                return x, i
            continue
        
        # Newton step
        delta = fx / df
        
        # Check convergence by step size
        if abs(delta) < tol_step:
            return x, i
        
        # Adaptive step: if step is too large, reduce it
        if abs(delta) > 100:
            delta = 100 * np.sign(delta)
            h = h / 2  # Also reduce h for next iteration
        
        x_new = x - delta
        
        # Simple backtracking: if new value is worse, reduce step
        try:
            fx_new = f(x_new)
            if abs(fx_new) > abs(fx) * 2:  # Getting worse
                delta = delta / 2
                x_new = x - delta
        except Exception:
            # If evaluation fails, reduce step
            delta = delta / 2
            x_new = x - delta
        
        x = x_new
    
    # Reached max iterations
    return x, max_iter





================================================================================
–§–ê–ô–õ: src\spectral_physics\spectrum.py
================================================================================

import numpy as np
from dataclasses import dataclass


@dataclass
class Spectrum1D:
    """
    One-dimensional discrete spectrum.
    
    Attributes:
        omega: Angular frequencies (1D array).
        power: Spectral power/energy density at each frequency (1D array).
    """
    omega: np.ndarray
    power: np.ndarray
    
    def __post_init__(self):
        """Validate that omega and power have the same shape."""
        self.omega = np.asarray(self.omega, dtype=float)
        self.power = np.asarray(self.power, dtype=float)
        
        if self.omega.shape != self.power.shape:
            raise ValueError(
                f"Shape mismatch: omega has shape {self.omega.shape}, "
                f"power has shape {self.power.shape}"
            )
    
    def normalize(self) -> "Spectrum1D":
        """
        Return a new Spectrum1D with normalized power (sum(power) = 1).
        
        Returns:
            New Spectrum1D instance with normalized power.
        
        Raises:
            ValueError: If total power is zero.
        """
        total = self.total_power()
        if total == 0:
            raise ValueError("Cannot normalize spectrum with zero total power")
        
        return Spectrum1D(
            omega=self.omega.copy(),
            power=self.power / total
        )
    
    def total_power(self) -> float:
        """
        Compute total power (integral/sum over all frequencies).
        
        Returns:
            Total power as a scalar.
        """
        return float(np.sum(self.power))
    
    def apply_filter(self, alpha: np.ndarray) -> "Spectrum1D":
        """
        Apply frequency-dependent filter/transparency alpha(omega).
        
        Args:
            alpha: Transparency/filter coefficients (same shape as power).
        
        Returns:
            New Spectrum1D with filtered power: new_power = power * alpha.
        
        Raises:
            ValueError: If alpha has incompatible shape.
        """
        alpha = np.asarray(alpha, dtype=float)
        
        if alpha.shape != self.power.shape:
            raise ValueError(
                f"Shape mismatch: alpha has shape {alpha.shape}, "
                f"expected {self.power.shape}"
            )
        
        return Spectrum1D(
            omega=self.omega.copy(),
            power=self.power * alpha
        )
    
    @classmethod
    def from_function(cls, omega: np.ndarray, func):
        """
        –°–æ–∑–¥–∞—Ç—å Spectrum1D –∏–∑ —Ñ—É–Ω–∫—Ü–∏–∏ power(omega).
        
        Args:
            omega: –ú–∞—Å—Å–∏–≤ —á–∞—Å—Ç–æ—Ç.
            func: –§—É–Ω–∫—Ü–∏—è, –ø—Ä–∏–Ω–∏–º–∞—é—â–∞—è omega –∏ –≤–æ–∑–≤—Ä–∞—â–∞—é—â–∞—è power.
        
        Returns:
            –ù–æ–≤—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä Spectrum1D.
        
        Raises:
            ValueError: –ï—Å–ª–∏ func(omega) –≤–µ—Ä–Ω—É–ª–∞ –º–∞—Å—Å–∏–≤ –Ω–µ—Å–æ–≤–º–µ—Å—Ç–∏–º–æ–π —Ñ–æ—Ä–º—ã.
        
        Example:
            >>> omega = np.linspace(0, 10, 100)
            >>> spec = Spectrum1D.from_function(omega, lambda w: np.exp(-w))
        """
        omega = np.asarray(omega, dtype=float)
        power = np.asarray(func(omega), dtype=float)
        
        if power.shape != omega.shape:
            raise ValueError(
                f"func(omega) must return array with same shape as omega. "
                f"Got power shape {power.shape}, expected {omega.shape}"
            )
        
        return cls(omega=omega, power=power)




================================================================================
–§–ê–ô–õ: src\spectral_physics\timeseries.py
================================================================================

import numpy as np
from .spectrum import Spectrum1D


def timeseries_to_spectrum(
    signal: np.ndarray,
    dt: float,
    window: str = "hann",
) -> Spectrum1D:
    """
    –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –æ–¥–Ω–æ–º–µ—Ä–Ω—ã–π –≤—Ä–µ–º–µ–Ω–Ω–æ–π —Å–∏–≥–Ω–∞–ª –≤ –∞–º–ø–ª–∏—Ç—É–¥–Ω—ã–π —Å–ø–µ–∫—Ç—Ä.
    
    –ü–∞—Ä–∞–º–µ—Ç—Ä—ã:
        signal: 1D-–º–∞—Å—Å–∏–≤ –æ—Ç—Å—á—ë—Ç–æ–≤ –≤–æ –≤—Ä–µ–º–µ–Ω–∏.
        dt: —à–∞–≥ –ø–æ –≤—Ä–µ–º–µ–Ω–∏ (—Å–µ–∫—É–Ω–¥—ã).
        window: —Ç–∏–ø –æ–∫–Ω–∞ ("hann" –∏–ª–∏ None).
    
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç:
        Spectrum1D —Å:
            omega: —É–≥–ª–æ–≤—ã–µ —á–∞—Å—Ç–æ—Ç—ã (rad/s) –¥–ª—è –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã—Ö —á–∞—Å—Ç–æ—Ç.
            power: |FFT|^2 / N –∏–ª–∏ –∞–Ω–∞–ª–æ–≥–∏—á–Ω–∞—è –Ω–æ—Ä–º–∏—Ä–æ–≤–∫–∞.
    
    Example:
        >>> t = np.arange(0, 1.0, 0.001)
        >>> signal = np.sin(2 * np.pi * 50 * t)  # 50 Hz
        >>> spectrum = timeseries_to_spectrum(signal, dt=0.001)
    """
    signal = np.asarray(signal, dtype=float)
    
    if signal.ndim != 1:
        raise ValueError(f"Signal must be 1D array, got shape {signal.shape}")
    
    n = len(signal)
    if n == 0:
        raise ValueError("Signal must not be empty")
    
    # –£–¥–∞–ª–µ–Ω–∏–µ DC-–∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞ (–≤—ã—á–∏—Ç–∞–Ω–∏–µ —Å—Ä–µ–¥–Ω–µ–≥–æ)
    signal_ac = signal - np.mean(signal)
    
    # –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –æ–∫–æ–Ω–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏
    if window == "hann":
        window_func = np.hanning(n)
        signal_windowed = signal_ac * window_func
    elif window is None:
        signal_windowed = signal_ac
    else:
        raise ValueError(f"Unknown window type: {window}. Use 'hann' or None.")
    
    # FFT (—Ç–æ–ª—å–∫–æ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–µ —á–∞—Å—Ç–æ—Ç—ã)
    fft_vals = np.fft.rfft(signal_windowed)
    
    # –ß–∞—Å—Ç–æ—Ç—ã –≤ –ì–µ—Ä—Ü–∞—Ö
    freq_hz = np.fft.rfftfreq(n, d=dt)
    
    # –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤ —É–≥–ª–æ–≤—ã–µ —á–∞—Å—Ç–æ—Ç—ã (rad/s)
    omega = 2 * np.pi * freq_hz
    
    # –ú–æ—â–Ω–æ—Å—Ç—å: |FFT|^2, –Ω–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –Ω–∞ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ—á–µ–∫
    # –ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç 2 –¥–ª—è —É—á—ë—Ç–∞ —ç–Ω–µ—Ä–≥–∏–∏ –≤ –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã—Ö —á–∞—Å—Ç–æ—Ç–∞—Ö (–∫—Ä–æ–º–µ DC –∏ Nyquist)
    power = np.abs(fft_vals) ** 2 / n
    
    # –£–¥–≤–æ–∏—Ç—å –º–æ—â–Ω–æ—Å—Ç—å –¥–ª—è –≤—Å–µ—Ö —á–∞—Å—Ç–æ—Ç –∫—Ä–æ–º–µ DC (–∏–Ω–¥–µ–∫—Å 0) –∏ Nyquist (–ø–æ—Å–ª–µ–¥–Ω–∏–π –¥–ª—è —á—ë—Ç–Ω–æ–≥–æ n)
    if n % 2 == 0:
        # –ß—ë—Ç–Ω–æ–µ n: DC –∏ Nyquist –Ω–µ —É–¥–≤–∞–∏–≤–∞—é—Ç—Å—è
        power[1:-1] *= 2
    else:
        # –ù–µ—á—ë—Ç–Ω–æ–µ n: —Ç–æ–ª—å–∫–æ DC –Ω–µ —É–¥–≤–∞–∏–≤–∞–µ—Ç—Å—è
        power[1:] *= 2
    
    return Spectrum1D(omega=omega, power=power)



================================================================================
–§–ê–ô–õ: src\spectral_physics_lab.egg-info\dependency_links.txt
================================================================================





================================================================================
–§–ê–ô–õ: src\spectral_physics_lab.egg-info\entry_points.txt
================================================================================

[console_scripts]
spectral-health = spectral_physics.cli:main



================================================================================
–§–ê–ô–õ: src\spectral_physics_lab.egg-info\requires.txt
================================================================================

numpy>=1.25
scipy>=1.11
matplotlib>=3.7
pyyaml>=6.0



================================================================================
–§–ê–ô–õ: src\spectral_physics_lab.egg-info\SOURCES.txt
================================================================================

README.md
pyproject.toml
src/spectral_physics/__init__.py
src/spectral_physics/atoms.py
src/spectral_physics/cli.py
src/spectral_physics/diagnostics.py
src/spectral_physics/geophysics_1d.py
src/spectral_physics/grav_toy.py
src/spectral_physics/io.py
src/spectral_physics/ldos.py
src/spectral_physics/material.py
src/spectral_physics/materials.py
src/spectral_physics/medium_1d.py
src/spectral_physics/medium_2d.py
src/spectral_physics/report.py
src/spectral_physics/root_finding.py
src/spectral_physics/spectrum.py
src/spectral_physics/timeseries.py
src/spectral_physics_lab.egg-info/PKG-INFO
src/spectral_physics_lab.egg-info/SOURCES.txt
src/spectral_physics_lab.egg-info/dependency_links.txt
src/spectral_physics_lab.egg-info/entry_points.txt
src/spectral_physics_lab.egg-info/requires.txt
src/spectral_physics_lab.egg-info/top_level.txt
tests/test_atoms.py
tests/test_diagnostics.py
tests/test_diagnostics_features.py
tests/test_geophysics_1d.py
tests/test_grav_toy.py
tests/test_io.py
tests/test_ldos.py
tests/test_material.py
tests/test_material_features.py
tests/test_materials.py
tests/test_medium_1d.py
tests/test_medium_2d.py
tests/test_report.py
tests/test_root_finding.py
tests/test_spectrum.py
tests/test_timeseries.py


================================================================================
–§–ê–ô–õ: src\spectral_physics_lab.egg-info\top_level.txt
================================================================================

spectral_physics



================================================================================
–§–ê–ô–õ: tests\test_atoms.py
================================================================================

import pytest
import numpy as np
from spectral_physics.atoms import (
    AtomicResonator, 
    spectral_overlap, 
    can_form_bond,
    H, O, C
)

def test_atomic_resonator_creation():
    atom = AtomicResonator.from_lines("Test", [(10.0, 1.0), (20.0, 0.5)], max_bonds=3)
    assert len(atom.omega) == 2
    assert atom.max_bonds == 3
    assert atom.name == "Test"
    
    spec = atom.spectrum()
    assert np.allclose(spec.omega, [10.0, 20.0])

def test_spectral_overlap_identical():
    # H vs H should have overlap
    # H has line at 1.0
    score = spectral_overlap(H, H, freq_tol=0.1)
    # Both normalized power is 1.0. Min(1,1) = 1.
    assert score > 0.9

def test_spectral_overlap_none():
    # Atom with far frequency
    X = AtomicResonator.from_lines("X", [(100.0, 1.0)], max_bonds=1)
    
    score = spectral_overlap(H, X, freq_tol=0.1)
    assert score == 0.0

def test_can_form_bond_logic():
    # H and O should bond (H=1.0, O has 1.0)
    assert can_form_bond(H, O, freq_tol=0.1, threshold=0.1)
    
    # Inert gas (He)
    He = AtomicResonator.from_lines("He", [(1.0, 1.0)], max_bonds=0)
    
    # Even if frequencies match, max_bonds=0 prevents bonding
    assert not can_form_bond(He, H, freq_tol=0.1, threshold=0.1)

def test_carbon_bonds():
    # C should bond with H
    assert can_form_bond(C, H, freq_tol=0.1, threshold=0.1)
    # C should bond with O
    assert can_form_bond(C, O, freq_tol=0.1, threshold=0.1)



================================================================================
–§–ê–ô–õ: tests\test_diagnostics.py
================================================================================

import numpy as np
import pytest
from spectral_physics.diagnostics import ChannelConfig, SpectralAnalyzer, HealthMonitor
from spectral_physics.spectrum import Spectrum1D


def test_channel_config_creation():
    """Test basic ChannelConfig creation."""
    config = ChannelConfig(
        name="test",
        dt=0.001,
        window="hann",
        freq_min=10.0,
        freq_max=100.0
    )
    
    assert config.name == "test"
    assert config.dt == 0.001
    assert config.window == "hann"
    assert config.freq_min == 10.0
    assert config.freq_max == 100.0


def test_spectral_analyzer_basic():
    """Test SpectralAnalyzer with known sine wave."""
    freq = 50.0  # Hz
    duration = 1.0
    dt = 0.001
    
    t = np.arange(0, duration, dt)
    signal = np.sin(2 * np.pi * freq * t)
    
    config = ChannelConfig(name="test", dt=dt)
    analyzer = SpectralAnalyzer(config)
    spectrum = analyzer.analyze(signal)
    
    # Should have peak near 50 Hz
    freq_hz = spectrum.omega / (2 * np.pi)
    peak_idx = np.argmax(spectrum.power)
    peak_freq = freq_hz[peak_idx]
    
    assert abs(peak_freq - freq) < 5.0  # Within 5 Hz


def test_spectral_analyzer_freq_filter():
    """Test that freq_min/freq_max actually filter frequencies."""
    duration = 1.0
    dt = 0.001
    
    t = np.arange(0, duration, dt)
    # Mix of low and high frequencies
    signal = (
        np.sin(2 * np.pi * 10 * t) +
        np.sin(2 * np.pi * 100 * t)
    )
    
    # Analyze with no filter
    config_all = ChannelConfig(name="all", dt=dt)
    analyzer_all = SpectralAnalyzer(config_all)
    spectrum_all = analyzer_all.analyze(signal)
    
    # Analyze with filter (only 50-150 Hz)
    config_filtered = ChannelConfig(
        name="filtered",
        dt=dt,
        freq_min=50.0,
        freq_max=150.0
    )
    analyzer_filtered = SpectralAnalyzer(config_filtered)
    spectrum_filtered = analyzer_filtered.analyze(signal)
    
    # Filtered spectrum should be smaller
    assert len(spectrum_filtered.omega) < len(spectrum_all.omega)
    
    # All frequencies in filtered spectrum should be in range
    freq_hz = spectrum_filtered.omega / (2 * np.pi)
    assert np.all(freq_hz >= 50.0)
    assert np.all(freq_hz <= 150.0)


def test_health_monitor_score():
    """Test HealthMonitor.score calculation."""
    omega = np.array([1.0, 2.0, 3.0])
    power_ref = np.array([1.0, 2.0, 1.0])
    power_current = np.array([1.0, 2.0, 1.0])  # Identical
    
    ref_spec = Spectrum1D(omega=omega, power=power_ref)
    current_spec = Spectrum1D(omega=omega, power=power_current)
    
    monitor = HealthMonitor(reference=ref_spec, threshold=0.1)
    score = monitor.score(current_spec)
    
    # Score should be zero for identical spectra
    assert abs(score) < 1e-10


def test_health_monitor_is_anomalous_false():
    """Test that  HealthMonitor correctly identifies normal spectrum."""
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([1.0, 2.0, 1.0])
    
    spec = Spectrum1D(omega=omega, power=power)
    monitor = HealthMonitor(reference=spec, threshold=0.1)
    
    is_anom = monitor.is_anomalous(spec)
    
    assert is_anom is False


def test_health_monitor_is_anomalous_true():
    """Test that HealthMonitor correctly identifies anomaly."""
    omega = np.array([1.0, 2.0, 3.0])
    power_ref = np.array([1.0, 2.0, 1.0])
    power_anom = np.array([5.0, 0.5, 3.0])  # Very different
    
    ref_spec = Spectrum1D(omega=omega, power=power_ref)
    anom_spec = Spectrum1D(omega=omega, power=power_anom)
    
    monitor = HealthMonitor(reference=ref_spec, threshold=0.1)
    is_anom = monitor.is_anomalous(anom_spec)
    
    assert is_anom is True


def test_spectral_analyzer_window_none():
    """Test SpectralAnalyzer with no window."""
    freq = 50.0
    duration = 1.0
    dt = 0.001
    
    t = np.arange(0, duration, dt)
    signal = np.sin(2 * np.pi * freq * t)
    
    config = ChannelConfig(name="test", dt=dt, window=None)
    analyzer = SpectralAnalyzer(config)
    spectrum = analyzer.analyze(signal)
    
    # Should still work
    assert len(spectrum.omega) > 0
    assert len(spectrum.power) > 0


def test_average_spectrum_basic():
    """Test averaging two identical spectra."""
    from spectral_physics.diagnostics import average_spectrum
    
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([1.0, 2.0, 1.0])
    
    spec1 = Spectrum1D(omega=omega, power=power)
    spec2 = Spectrum1D(omega=omega, power=power)
    
    avg = average_spectrum([spec1, spec2])
    
    np.testing.assert_array_equal(avg.omega, omega)
    np.testing.assert_array_equal(avg.power, power)


def test_average_spectrum_different_power():
    """Test averaging spectra with different powers."""
    from spectral_physics.diagnostics import average_spectrum
    
    omega = np.array([1.0, 2.0])
    spec1 = Spectrum1D(omega=omega, power=np.array([1.0, 1.0]))
    spec2 = Spectrum1D(omega=omega, power=np.array([3.0, 3.0]))
    
    avg = average_spectrum([spec1, spec2])
    
    # Average of 1 and 3 is 2
    expected = np.array([2.0, 2.0])
    np.testing.assert_array_equal(avg.power, expected)


def test_average_spectrum_mismatch():
    """Test that averaging spectra with different grids raises ValueError."""
    from spectral_physics.diagnostics import average_spectrum
    
    spec1 = Spectrum1D(omega=np.array([1.0]), power=np.array([1.0]))
    spec2 = Spectrum1D(omega=np.array([2.0]), power=np.array([1.0]))
    
    with pytest.raises(ValueError, match="different frequency grid"):
        average_spectrum([spec1, spec2])


def test_build_health_profile_simple():
    """Test building health profile from training data."""
    from spectral_physics.diagnostics import build_health_profile
    
    omega = np.array([1.0, 2.0])
    power = np.array([1.0, 1.0])
    spec = Spectrum1D(omega=omega, power=power)
    
    training_data = {
        "ch1": [spec, spec],
        "ch2": [spec, spec]
    }
    
    profile = build_health_profile(training_data)
    
    assert "ch1" in profile.signatures
    assert "ch2" in profile.signatures
    
    # Check that signatures are correct (distance to original should be 0)
    scores = profile.score({"ch1": spec, "ch2": spec})
    assert scores["ch1"] < 1e-10
    assert scores["ch2"] < 1e-10


def test_spectral_band_power():
    """Test spectral band power calculation."""
    from spectral_physics.diagnostics import spectral_band_power
    
    # 10 Hz and 100 Hz
    omega = np.array([2*np.pi*10, 2*np.pi*100])
    power = np.array([1.0, 2.0])
    spec = Spectrum1D(omega=omega, power=power)
    
    # Band covering only 10 Hz
    p1 = spectral_band_power(spec, freq_min=5, freq_max=15)
    assert abs(p1 - 1.0) < 1e-10
    
    # Band covering only 100 Hz
    p2 = spectral_band_power(spec, freq_min=90, freq_max=110)
    assert abs(p2 - 2.0) < 1e-10
    
    # Band covering both
    p3 = spectral_band_power(spec, freq_min=0, freq_max=200)
    assert abs(p3 - 3.0) < 1e-10


def test_spectral_entropy():
    """Test spectral entropy calculation."""
    from spectral_physics.diagnostics import spectral_entropy
    
    omega = np.array([1.0, 2.0, 3.0])
    
    # Uniform spectrum (max entropy)
    spec_uniform = Spectrum1D(omega=omega, power=np.array([1.0, 1.0, 1.0]))
    h_uniform = spectral_entropy(spec_uniform)
    
    # Peaked spectrum (lower entropy)
    spec_peaked = Spectrum1D(omega=omega, power=np.array([0.0, 10.0, 0.0]))
    h_peaked = spectral_entropy(spec_peaked)
    
    assert h_uniform > h_peaked
    # For single peak, entropy should be 0 (-1*log(1))
    assert abs(h_peaked) < 1e-10


def test_extract_features():
    """Test feature extraction."""
    from spectral_physics.diagnostics import extract_features
    
    # 10 Hz (power 1.0) and 100 Hz (power 2.0)
    omega = np.array([2*np.pi*10, 2*np.pi*100])
    power = np.array([1.0, 2.0])
    spec = Spectrum1D(omega=omega, power=power)
    
    bands = [(5, 15), (90, 110)]
    
    features = extract_features(spec, bands)
    
    assert len(features) == 3  # 2 bands + 1 entropy
    assert abs(features[0] - 1.0) < 1e-10
    assert abs(features[1] - 2.0) < 1e-10
    # Entropy should be > 0 for 2 peaks
    assert features[2] > 0






================================================================================
–§–ê–ô–õ: tests\test_diagnostics_features.py
================================================================================

import numpy as np
import pytest
from spectral_physics.spectrum import Spectrum1D
from spectral_physics.diagnostics import extract_features, spectral_band_power, spectral_entropy

def test_extract_features_structure():
    # Create a dummy spectrum
    omega = np.linspace(0, 100, 101)
    power = np.ones_like(omega)
    spec = Spectrum1D(omega, power)
    
    bands = [(0, 10), (10, 50)]
    features = extract_features(spec, bands)
    
    # Expect len(bands) + 1 (entropy)
    assert len(features) == 3
    assert isinstance(features, np.ndarray)

def test_spectral_band_power():
    # Spectrum with power 1.0 everywhere
    # omega is 0..100 rad/s -> freq is 0..100/(2pi) ~ 15.9 Hz
    # Let's use Hz directly for clarity in construction if possible, 
    # but Spectrum1D takes omega.
    
    # Let's make a simple discrete spectrum
    # 1 Hz = 2pi rad/s
    freq_hz = np.array([1.0, 2.0, 3.0])
    omega = freq_hz * 2 * np.pi
    power = np.array([10.0, 20.0, 30.0])
    
    spec = Spectrum1D(omega, power)
    
    # Band 0.5-1.5 Hz should capture 1.0 Hz (power 10)
    p1 = spectral_band_power(spec, 0.5, 1.5)
    assert p1 == 10.0
    
    # Band 1.5-2.5 Hz should capture 2.0 Hz (power 20)
    p2 = spectral_band_power(spec, 1.5, 2.5)
    assert p2 == 20.0
    
    # Band 0-10 Hz should capture all (60)
    p_all = spectral_band_power(spec, 0.0, 10.0)
    assert p_all == 60.0

def test_spectral_entropy():
    # 1. Flat spectrum (max entropy)
    omega = np.array([1, 2, 3, 4])
    power = np.array([1, 1, 1, 1]) # Normalized: 0.25 each
    spec = Spectrum1D(omega, power)
    
    # H = - sum(0.25 * ln(0.25)) * 4 = - ln(0.25) = ln(4)
    expected = np.log(4)
    assert np.isclose(spectral_entropy(spec), expected)
    
    # 2. Delta function (min entropy)
    power2 = np.array([1, 0, 0, 0])
    spec2 = Spectrum1D(omega, power2)
    # H = - (1*ln(1) + 0) = 0
    assert spectral_entropy(spec2) == 0.0



================================================================================
–§–ê–ô–õ: tests\test_geophysics_1d.py
================================================================================

import numpy as np
import pytest
from spectral_physics.geophysics_1d import (
    Layer, LayeredMedium1D, simulate_pulse_response, invert_single_layer_thickness
)

def test_layered_medium_creation():
    l1 = Layer(thickness=10.0, density=1.0, stiffness=1.0)
    l2 = Layer(thickness=10.0, density=2.0, stiffness=4.0)
    medium = LayeredMedium1D(layers=[l1, l2], dx=1.0)
    
    chain = medium.to_oscillator_chain()
    
    # Total depth 20, dx=1 -> 20 nodes
    assert chain.n == 20
    
    # First 10 nodes (0..9) should have mass ~ 1.0 * 1.0 = 1.0
    assert np.allclose(chain.m[:10], 1.0)
    
    # Next 10 nodes (10..19) should have mass ~ 2.0 * 1.0 = 2.0
    assert np.allclose(chain.m[10:], 2.0)

def test_simulation_runs():
    l1 = Layer(thickness=5.0, density=1.0, stiffness=1.0)
    medium = LayeredMedium1D(layers=[l1], dx=1.0)
    
    t, sig = simulate_pulse_response(medium, t_max=10.0, dt=0.1)
    
    assert len(t) == 100
    assert len(sig) == 100
    # Signal should not be all zeros (pulse happened)
    assert np.max(np.abs(sig)) > 0

def test_inversion_sanity():
    # Create target
    true_h = 5.0
    l1 = Layer(thickness=true_h, density=1.0, stiffness=1.0)
    l_sub = Layer(thickness=10.0, density=10.0, stiffness=10.0) # Hard substrate
    
    medium = LayeredMedium1D(layers=[l1, l_sub], dx=1.0)
    t_max = 20.0
    dt = 0.1
    t, target_sig = simulate_pulse_response(medium, t_max, dt)
    
    # Invert
    # Start guess 4.0
    h_found = invert_single_layer_thickness(
        target_sig, t, 
        density=1.0, stiffness=1.0, 
        thickness_guess=4.0,
        fixed_layers_below=[l_sub],
        dx=1.0
    )
    
    # Should be close to 5.0
    # Note: dx=1.0 makes resolution limited. 5.0 is exactly 5 nodes.
    # 4.0 is 4 nodes.
    # The optimizer should find 5.0 (or close to it if continuous interpretation)
    assert abs(h_found - true_h) < 1.5 # Tolerance due to dx discretization



================================================================================
–§–ê–ô–õ: tests\test_grav_toy.py
================================================================================

import numpy as np
import pytest
from spectral_physics.spectrum import Spectrum1D
from spectral_physics.grav_toy import spectral_pressure_difference


def test_spectral_pressure_equal_transparency():
    """Test that equal transparency gives zero pressure difference."""
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([1.0, 2.0, 1.0])
    spectrum = Spectrum1D(omega=omega, power=power)
    
    alpha = np.array([0.5, 0.5, 0.5])  # Same on both sides
    
    delta_p = spectral_pressure_difference(spectrum, alpha, alpha)
    
    assert abs(delta_p) < 1e-14


def test_spectral_pressure_left_blocks_more():
    """Test that if left blocks more, pressure pushes right (positive ŒîP)."""
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([1.0, 1.0, 1.0])
    spectrum = Spectrum1D(omega=omega, power=power)
    
    alpha_left = np.array([0.2, 0.2, 0.2])   # Blocks more (low transparency)
    alpha_right = np.array([0.8, 0.8, 0.8])  # Blocks less (high transparency)
    
    delta_p = spectral_pressure_difference(spectrum, alpha_left, alpha_right)
    
    # ŒîP = Œ£ power * (alpha_right - alpha_left)
    # = Œ£ 1.0 * (0.8 - 0.2) = 3 * 0.6 = 1.8
    expected = 3 * 0.6
    assert abs(delta_p - expected) < 1e-14


def test_spectral_pressure_right_blocks_more():
    """Test that if right blocks more, pressure pushes left (negative ŒîP)."""
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([2.0, 2.0, 2.0])
    spectrum = Spectrum1D(omega=omega, power=power)
    
    alpha_left = np.array([0.9, 0.9, 0.9])   # Blocks less
    alpha_right = np.array([0.1, 0.1, 0.1])  # Blocks more
    
    delta_p = spectral_pressure_difference(spectrum, alpha_left, alpha_right)
    
    # ŒîP = Œ£ 2.0 * (0.1 - 0.9) = 3 * 2.0 * (-0.8) = -4.8
    expected = 3 * 2.0 * (-0.8)
    assert abs(delta_p - expected) < 1e-14


def test_spectral_pressure_frequency_dependent():
    """Test with frequency-dependent transparency."""
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([1.0, 2.0, 3.0])
    spectrum = Spectrum1D(omega=omega, power=power)
    
    # Left transparent to low freq, blocks high freq
    alpha_left = np.array([1.0, 0.5, 0.0])
    
    # Right blocks low freq, transparent to high freq
    alpha_right = np.array([0.0, 0.5, 1.0])
    
    delta_p = spectral_pressure_difference(spectrum, alpha_left, alpha_right)
    
    # ŒîP = 1.0*(0.0-1.0) + 2.0*(0.5-0.5) + 3.0*(1.0-0.0)
    #    = -1.0 + 0.0 + 3.0 = 2.0
    expected = -1.0 + 0.0 + 3.0
    assert abs(delta_p - expected) < 1e-14


def test_spectral_pressure_shape_mismatch_left():
    """Test that mismatched left alpha shape raises ValueError."""
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([1.0, 2.0, 3.0])
    spectrum = Spectrum1D(omega=omega, power=power)
    
    alpha_left = np.array([0.5, 0.5])  # Wrong size
    alpha_right = np.array([0.5, 0.5, 0.5])
    
    with pytest.raises(ValueError, match="alpha_left"):
        spectral_pressure_difference(spectrum, alpha_left, alpha_right)


def test_spectral_pressure_shape_mismatch_right():
    """Test that mismatched right alpha shape raises ValueError."""
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([1.0, 2.0, 3.0])
    spectrum = Spectrum1D(omega=omega, power=power)
    
    alpha_left = np.array([0.5, 0.5, 0.5])
    alpha_right = np.array([0.5, 0.5])  # Wrong size
    
    with pytest.raises(ValueError, match="alpha_right"):
        spectral_pressure_difference(spectrum, alpha_left, alpha_right)


def test_spectral_pressure_realistic_scenario():
    """Test a more realistic scenario with Gaussian spectrum."""
    # Gaussian spectrum
    omega = np.linspace(0, 10, 100)
    power = np.exp(-(omega - 5)**2 / 2)
    spectrum = Spectrum1D(omega=omega, power=power)
    
    # Material that blocks high frequencies more
    alpha_left = np.exp(-omega / 10)  # Decays with frequency
    alpha_right = np.ones_like(omega) * 0.8  # Uniform transparency
    
    delta_p = spectral_pressure_difference(spectrum, alpha_left, alpha_right)
    
    # Should be positive (because left blocks more at high freq where power is)
    # The exact value depends on the convolution, but it should be positive
    assert delta_p != 0  # Non-trivial result



================================================================================
–§–ê–ô–õ: tests\test_io.py
================================================================================

import numpy as np
import pytest
import tempfile
from pathlib import Path
from spectral_physics.io import (
    load_timeseries_csv,
    save_spectrum_npz,
    load_spectrum_npz
)
from spectral_physics.spectrum import Spectrum1D


def test_load_timeseries_csv_simple():
    """Test loading simple CSV without header."""
    # Create temporary CSV
    with tempfile.NamedTemporaryFile(mode='w', suffix='.csv', delete=False) as f:
        f.write("1.0\n2.0\n3.0\n4.0\n5.0\n")
        temp_path = f.name
    
    try:
        signal = load_timeseries_csv(temp_path, column=0, skip_header=False)
        
        expected = np.array([1.0, 2.0, 3.0, 4.0, 5.0])
        np.testing.assert_array_equal(signal, expected)
    finally:
        Path(temp_path).unlink()


def test_load_timeseries_csv_with_header():
    """Test loading CSV with header."""
    with tempfile.NamedTemporaryFile(mode='w', suffix='.css', delete=False) as f:
        f.write("time,value\n")
        f.write("0.0,1.0\n0.1,2.0\n0.2,3.0\n")
        temp_path = f.name
    
    try:
        signal = load_timeseries_csv(temp_path, column=1, skip_header=True)
        
        expected = np.array([1.0, 2.0, 3.0])
        np.testing.assert_array_equal(signal, expected)
    finally:
        Path(temp_path).unlink()


def test_load_timeseries_csv_multiple_columns():
    """Test loading CSV with multiple columns."""
    with tempfile.NamedTemporaryFile(mode='w', suffix='.csv', delete=False) as f:
        f.write("1.0,10.0,100.0\n2.0,20.0,200.0\n3.0,30.0,300.0\n")
        temp_path = f.name
    
    try:
        # Load column 1
        signal = load_timeseries_csv(temp_path, column=1, skip_header=False)
        expected = np.array([10.0, 20.0, 30.0])
        np.testing.assert_array_equal(signal, expected)
    finally:
        Path(temp_path).unlink()


def test_load_timeseries_csv_file_not_found():
    """Test that missing file raises ValueError."""
    with pytest.raises(ValueError, match="File not found"):
        load_timeseries_csv("nonexistent.csv")


def test_load_timeseries_csv_invalid_column():
    """Test that invalid column index raises ValueError."""
    with tempfile.NamedTemporaryFile(mode='w', suffix='.csv', delete=False) as f:
        f.write("1.0,2.0\n3.0,4.0\n")
        temp_path = f.name
    
    try:
        with pytest.raises(ValueError, match="Column index .* out of range"):
            load_timeseries_csv(temp_path, column=5, skip_header=False)
    finally:
        Path(temp_path).unlink()


def test_save_load_spectrum_npz():
    """Test save and load spectrum roundtrip."""
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([0.5, 1.0, 0.5])
    
    original = Spectrum1D(omega=omega, power=power)
    
    # Save
    with tempfile.NamedTemporaryFile(suffix='.npz', delete=False) as f:
        temp_path = f.name
    
    try:
        save_spectrum_npz(original, temp_path)
        
        # Load
        loaded = load_spectrum_npz(temp_path)
        
        # Verify
        np.testing.assert_array_equal(loaded.omega, omega)
        np.testing.assert_array_equal(loaded.power, power)
    finally:
        Path(temp_path).unlink()


def test_load_spectrum_npz_missing_file():
    """Test that missing file raises ValueError."""
    with pytest.raises(ValueError, match="File not found"):
        load_spectrum_npz("nonexistent.npz")


def test_load_spectrum_npz_missing_keys():
    """Test that file missing required keys raises ValueError."""
    # Create npz with wrong keys
    with tempfile.NamedTemporaryFile(suffix='.npz', delete=False) as f:
        temp_path = f.name
    
    try:
        np.savez(temp_path, wrong_key=np.array([1, 2, 3]))
        
        with pytest.raises(ValueError, match="missing required keys"):
            load_spectrum_npz(temp_path)
    finally:
        Path(temp_path).unlink()


def test_save_load_health_profile_roundtrip():
    """Test save and load health profile roundtrip."""
    from spectral_physics.material import HealthProfile, MaterialSignature
    from spectral_physics.io import save_health_profile, load_health_profile
    
    omega = np.array([1.0, 2.0])
    power = np.array([1.0, 1.0])
    spec = Spectrum1D(omega=omega, power=power)
    sig = MaterialSignature(reference=spec)
    
    profile = HealthProfile(signatures={"ch1": sig, "ch2": sig})
    
    with tempfile.NamedTemporaryFile(suffix='.npz', delete=False) as f:
        temp_path = f.name
        
    try:
        save_health_profile(profile, temp_path)
        
        loaded = load_health_profile(temp_path)
        
        assert "ch1" in loaded.signatures
        assert "ch2" in loaded.signatures
        
        # Check content
        np.testing.assert_array_equal(
            loaded.signatures["ch1"].reference.power,
            power
        )
    finally:
        Path(temp_path).unlink()




================================================================================
–§–ê–ô–õ: tests\test_ldos.py
================================================================================

import numpy as np
import pytest
from spectral_physics.ldos import ldos_from_modes
from spectral_physics.medium_2d import OscillatorGrid2D

def test_ldos_empty_window():
    # 3 points, 2 modes
    modes = np.array([[1, 0], [0, 1], [1, 1]])
    omegas = np.array([1.0, 2.0])
    
    # Window that captures nothing
    ldos = ldos_from_modes(modes, omegas, (3.0, 4.0))
    
    assert np.all(ldos == 0)

def test_ldos_full_window():
    # 2 points, 2 modes
    # Mode 0: [1, 0] at w=1
    # Mode 1: [0, 1] at w=2
    modes = np.array([[1.0, 0.0], [0.0, 1.0]])
    omegas = np.array([1.0, 2.0])
    
    # Capture both
    ldos = ldos_from_modes(modes, omegas, (0.0, 3.0))
    
    # Point 0: 1^2 + 0^2 = 1
    # Point 1: 0^2 + 1^2 = 1
    assert np.allclose(ldos, [1.0, 1.0])

def test_grid_ldos_map_shape():
    grid = OscillatorGrid2D(nx=5, ny=5, kx=1.0, ky=1.0, m=1.0)
    
    # Calculate LDOS
    ldos_map = grid.ldos_map(n_modes=10, freq_window=(0.0, 10.0))
    
    assert ldos_map.shape == (5, 5)
    assert np.all(ldos_map >= 0)



================================================================================
–§–ê–ô–õ: tests\test_material.py
================================================================================

import numpy as np
import pytest
from spectral_physics.material import MaterialSignature
from spectral_physics.spectrum import Spectrum1D


def test_distance_identical_spectra():
    """Test that distance between identical spectra is zero."""
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([1.0, 2.0, 1.0])
    
    spec1 = Spectrum1D(omega=omega, power=power)
    spec2 = Spectrum1D(omega=omega, power=power.copy())
    
    sig = MaterialSignature(reference=spec1)
    distance = sig.distance_l2(spec2)
    
    assert abs(distance) < 1e-10


def test_distance_slightly_different():
    """Test distance for slightly different spectra."""
    omega = np.array([1.0, 2.0, 3.0])
    power1 = np.array([1.0, 2.0, 1.0])
    power2 = np.array([1.0, 2.1, 1.0])  # Slight difference
    
    spec1 = Spectrum1D(omega=omega, power=power1)
    spec2 = Spectrum1D(omega=omega, power=power2)
    
    sig = MaterialSignature(reference=spec1)
    distance = sig.distance_l2(spec2)
    
    # Should be small but non-zero
    assert distance > 0
    assert distance < 1.0


def test_distance_very_different():
    """Test distance for very different spectra."""
    omega = np.array([1.0, 2.0, 3.0])
    power1 = np.array([1.0, 2.0, 1.0])
    power2 = np.array([5.0, 0.5, 3.0])  # Very different shape
    
    spec1 = Spectrum1D(omega=omega, power=power1)
    spec2 = Spectrum1D(omega=omega, power=power2)
    
    sig = MaterialSignature(reference=spec1)
    distance = sig.distance_l2(spec2)
    
    # Should be large
    assert distance > 0.5


def test_distance_mismatched_frequencies():
    """Test that mismatched frequency grids raise ValueError."""
    omega1 = np.array([1.0, 2.0, 3.0])
    omega2 = np.array([1.0, 2.0, 3.0, 4.0])  # Different length
    
    spec1 = Spectrum1D(omega=omega1, power=np.array([1.0, 2.0, 1.0]))
    spec2 = Spectrum1D(omega=omega2, power=np.array([1.0, 2.0, 1.0, 1.0]))
    
    sig = MaterialSignature(reference=spec1)
    
    with pytest.raises(ValueError, match="Frequency grids do not match"):
        sig.distance_l2(spec2)


def test_is_anomalous_normal():
    """Test that identical spectrum is not anomalous."""
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([1.0, 2.0, 1.0])
    
    spec = Spectrum1D(omega=omega, power=power)
    sig = MaterialSignature(reference=spec)
    
    is_anom = sig.is_anomalous(spec, threshold=0.01)
    
    assert is_anom is False


def test_is_anomalous_below_threshold():
    """Test that small difference is not anomalous."""
    omega = np.array([1.0, 2.0, 3.0])
    power1 = np.array([1.0, 2.0, 1.0])
    power2 = np.array([1.0, 2.01, 1.0])  # Tiny difference
    
    spec1 = Spectrum1D(omega=omega, power=power1)
    spec2 = Spectrum1D(omega=omega, power=power2)
    
    sig = MaterialSignature(reference=spec1)
    is_anom = sig.is_anomalous(spec2, threshold=1.0)  # High threshold
    
    assert is_anom is False


def test_is_anomalous_above_threshold():
    """Test that large difference is anomalous."""
    omega = np.array([1.0, 2.0, 3.0])
    power1 = np.array([1.0, 2.0, 1.0])
    power2 = np.array([5.0, 0.5, 3.0])  # Very different
    
    spec1 = Spectrum1D(omega=omega, power=power1)
    spec2 = Spectrum1D(omega=omega, power=power2)
    
    sig = MaterialSignature(reference=spec1)
    is_anom = sig.is_anomalous(spec2, threshold=0.1)  # Low threshold
    
    assert is_anom is True


def test_distance_normalized():
    """Test that distance is based on normalized spectra."""
    omega = np.array([1.0, 2.0, 3.0])
    power1 = np.array([1.0, 2.0, 1.0])
    power2 = np.array([2.0, 4.0, 2.0])  # Same shape, double amplitude
    
    spec1 = Spectrum1D(omega=omega, power=power1)
    spec2 = Spectrum1D(omega=omega, power=power2)
    
    sig = MaterialSignature(reference=spec1)
    distance = sig.distance_l2(spec2)
    
    # Should be zero since normalized shapes are identical
    assert abs(distance) < 1e-10


def test_health_profile_score_identity():
    """Test HealthProfile score with identical spectra."""
    from spectral_physics.material import HealthProfile
    
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([1.0, 2.0, 1.0])
    spec = Spectrum1D(omega=omega, power=power)
    
    sig = MaterialSignature(reference=spec)
    profile = HealthProfile(signatures={"ch1": sig, "ch2": sig})
    
    current = {"ch1": spec, "ch2": spec}
    scores = profile.score(current)
    
    assert scores["ch1"] < 1e-10
    assert scores["ch2"] < 1e-10


def test_health_profile_is_anomalous_mixed():
    """Test HealthProfile with mixed anomalous/normal channels."""
    from spectral_physics.material import HealthProfile
    
    omega = np.array([1.0, 2.0, 3.0])
    power_ref = np.array([1.0, 2.0, 1.0])
    power_anom = np.array([5.0, 0.5, 3.0])
    
    spec_ref = Spectrum1D(omega=omega, power=power_ref)
    spec_anom = Spectrum1D(omega=omega, power=power_anom)
    
    sig = MaterialSignature(reference=spec_ref)
    profile = HealthProfile(signatures={"ch1": sig, "ch2": sig})
    
    current = {"ch1": spec_ref, "ch2": spec_anom}
    thresholds = {"ch1": 0.1, "ch2": 0.1}
    
    results = profile.is_anomalous(current, thresholds)
    
    assert results["ch1"] is False
    assert results["ch2"] is True


def test_distance_cosine_identical():
    """Test cosine distance for identical spectra."""
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([1.0, 2.0, 1.0])
    spec = Spectrum1D(omega=omega, power=power)
    
    sig = MaterialSignature(reference=spec)
    dist = sig.distance_cosine(spec)
    
    assert abs(dist) < 1e-10


def test_distance_cosine_orthogonal():
    """Test cosine distance for orthogonal-like spectra."""
    omega = np.array([1.0, 2.0])
    
    spec1 = Spectrum1D(omega=omega, power=np.array([1.0, 0.0]))
    spec2 = Spectrum1D(omega=omega, power=np.array([0.0, 1.0]))
    
    sig = MaterialSignature(reference=spec1)
    dist = sig.distance_cosine(spec2)
    
    # Cosine similarity is 0, so distance is 1 - 0 = 1
    assert abs(dist - 1.0) < 1e-10


def test_feature_signature_basic():
    """Test FeatureSignature distance."""
    from spectral_physics.material import FeatureSignature
    
    ref = np.array([1.0, 2.0, 3.0])
    sig = FeatureSignature(reference_features=ref)
    
    # Identical
    assert abs(sig.distance_l2(ref)) < 1e-10
    
    # Offset
    other = np.array([2.0, 2.0, 3.0]) # diff is [1, 0, 0]
    assert abs(sig.distance_l2(other) - 1.0) < 1e-10


def test_health_profile_score_features():
    """Test HealthProfile feature scoring."""
    from spectral_physics.material import HealthProfile, FeatureSignature, MaterialSignature
    from spectral_physics.diagnostics import extract_features
    
    # Setup dummy data
    omega = np.array([2*np.pi*10])
    power = np.array([1.0])
    spec = Spectrum1D(omega=omega, power=power)
    
    # Features for this spec: band_power(1.0) + entropy(0.0) = [1.0, 0.0]
    bands = [(5, 15)]
    feats = extract_features(spec, bands)
    
    feat_sig = FeatureSignature(reference_features=feats)
    mat_sig = MaterialSignature(reference=spec)
    
    profile = HealthProfile(
        signatures={"ch1": mat_sig},
        feature_signatures={"ch1": feat_sig}
    )
    
    # Score against itself should be 0
    scores = profile.score_features(
        {"ch1": spec},
        {"ch1": bands}
    )
    
    assert "ch1" in scores
    assert scores["ch1"] < 1e-10






================================================================================
–§–ê–ô–õ: tests\test_material_features.py
================================================================================

import numpy as np
import pytest
from spectral_physics.spectrum import Spectrum1D
from spectral_physics.material import FeatureSignature, HealthProfile, MaterialSignature

def test_feature_signature_distance():
    ref_feats = np.array([1.0, 2.0, 3.0])
    sig = FeatureSignature(reference_features=ref_feats)
    
    # Identical
    assert sig.distance_l2(ref_feats) == 0.0
    
    # Different
    other = np.array([2.0, 2.0, 3.0]) # diff 1.0 in first component
    assert sig.distance_l2(other) == 1.0
    
    # Shape mismatch
    with pytest.raises(ValueError):
        sig.distance_l2(np.array([1.0, 2.0]))

def test_health_profile_score_features(monkeypatch):
    # Mock extract_features to return predictable values
    import spectral_physics.material as mat
    
    # We need to mock it where it is imported inside the method or globally?
    # The method does: from .diagnostics import extract_features
    # So we need to mock spectral_physics.diagnostics.extract_features
    
    # But since it's a local import inside the function, mocking might be tricky if we don't patch the module.
    # Let's just use real objects, it's safer.
    
    # Setup
    omega = np.linspace(0, 10, 11)
    power = np.ones_like(omega)
    spec = Spectrum1D(omega, power)
    
    # Create profile with feature signature
    # Assume extract_features returns [band1, entropy] -> length 2 for 1 band
    # For power=1 everywhere, band power depends on width.
    # Let's just create a dummy FeatureSignature that matches what we expect from "healthy"
    
    # Let's compute expected features for "healthy"
    # Band 0-10 (all points? freq_hz = omega/2pi)
    # omega=10 -> freq ~ 1.59 Hz.
    # Band 0-2 Hz covers everything.
    # Power sum = 11.
    # Entropy = ln(11).
    
    bands = {'ch1': [(0.0, 2.0)]}
    
    # "Healthy" features
    feat_ref = np.array([11.0, np.log(11)])
    
    feat_sig = FeatureSignature(reference_features=feat_ref)
    
    profile = HealthProfile(
        signatures={'ch1': MaterialSignature(reference=spec)},
        feature_signatures={'ch1': feat_sig}
    )
    
    # 1. Test with identical spectrum
    scores = profile.score_features({'ch1': spec}, bands)
    assert 'ch1' in scores
    assert np.isclose(scores['ch1'], 0.0)
    
    # 2. Test with modified spectrum
    # Double the power -> band power doubles (22), entropy stays same (normalized)
    spec2 = Spectrum1D(omega, power * 2)
    scores2 = profile.score_features({'ch1': spec2}, bands)
    
    # Diff: band power 22 vs 11 -> diff 11. Entropy same.
    # Distance = sqrt(11^2 + 0) = 11.
    assert np.isclose(scores2['ch1'], 11.0)



================================================================================
–§–ê–ô–õ: tests\test_materials.py
================================================================================

import numpy as np
import pytest
from spectral_physics.materials import MaterialPatch, effective_coupling
from spectral_physics.atoms import AtomicResonator

def test_material_patch_spectrum():
    # Atom A: line at 1.0, power 1.0
    A = AtomicResonator.from_lines("A", [(1.0, 1.0)], max_bonds=1)
    # Atom B: line at 2.0, power 1.0
    B = AtomicResonator.from_lines("B", [(2.0, 1.0)], max_bonds=1)
    
    # Mix 50/50
    patch = MaterialPatch(atoms=[A, B], weights=np.array([0.5, 0.5]))
    
    spec = patch.surface_spectrum()
    
    assert len(spec.omega) == 2
    assert np.allclose(spec.omega, [1.0, 2.0])
    assert np.allclose(spec.power, [0.5, 0.5])

def test_effective_coupling():
    # Atom A: line at 1.0, power 1.0
    A = AtomicResonator.from_lines("A", [(1.0, 1.0)], max_bonds=1)
    patch = MaterialPatch(atoms=[A], weights=np.array([1.0]))
    
    # LDOS is constant 2.0
    ldos = np.array([2.0, 2.0, 2.0])
    
    # Window covers the line
    coupling = effective_coupling(ldos, patch, freq_window=(0.5, 1.5))
    
    # Power = 1.0. Avg LDOS = 2.0. Result = 2.0
    assert coupling == 2.0
    
    # Window does NOT cover the line
    coupling_zero = effective_coupling(ldos, patch, freq_window=(2.0, 3.0))
    assert coupling_zero == 0.0



================================================================================
–§–ê–ô–õ: tests\test_medium_1d.py
================================================================================

import numpy as np
import pytest
from spectral_physics.medium_1d import OscillatorChain1D


def test_oscillator_chain_creation():
    """Test basic OscillatorChain1D creation."""
    chain = OscillatorChain1D(n=10, k=1.0, m=1.0, gamma=0.0)
    
    assert chain.n == 10
    assert chain.k == 1.0
    assert chain.m == 1.0
    assert chain.gamma == 0.0


def test_oscillator_chain_validation():
    """Test parameter validation."""
    # n must be >= 1
    with pytest.raises(ValueError, match="Number of oscillators"):
        OscillatorChain1D(n=0, k=1.0, m=1.0)
    
    # m must be positive
    with pytest.raises(ValueError, match="Mass must be positive"):
        OscillatorChain1D(n=10, k=1.0, m=0.0)
    
    # k must be non-negative
    with pytest.raises(ValueError, match="Stiffness must be non-negative"):
        OscillatorChain1D(n=10, k=-1.0, m=1.0)
    
    # gamma must be non-negative
    with pytest.raises(ValueError, match="Damping must be non-negative"):
        OscillatorChain1D(n=10, k=1.0, m=1.0, gamma=-0.1)


def test_stiffness_matrix_shape():
    """Test stiffness matrix has correct shape."""
    chain = OscillatorChain1D(n=10, k=1.0, m=1.0)
    K = chain.stiffness_matrix()
    
    assert K.shape == (10, 10)


def test_stiffness_matrix_symmetric():
    """Test that stiffness matrix is symmetric."""
    chain = OscillatorChain1D(n=10, k=1.0, m=1.0)
    K = chain.stiffness_matrix()
    
    np.testing.assert_array_almost_equal(K, K.T)


def test_stiffness_matrix_structure():
    """Test stiffness matrix has correct tridiagonal structure."""
    chain = OscillatorChain1D(n=5, k=2.0, m=1.0)
    K = chain.stiffness_matrix()
    
    # Diagonal should be 2*k
    diagonal = np.diag(K)
    np.testing.assert_array_almost_equal(diagonal, np.full(5, 4.0))
    
    # Off-diagonal should be -k
    off_diag_upper = np.diag(K, k=1)
    np.testing.assert_array_almost_equal(off_diag_upper, np.full(4, -2.0))
    
    off_diag_lower = np.diag(K, k=-1)
    np.testing.assert_array_almost_equal(off_diag_lower, np.full(4, -2.0))


def test_eigenmodes_shape():
    """Test eigenmodes return correct shapes."""
    chain = OscillatorChain1D(n=10, k=1.0, m=1.0)
    omega, modes = chain.eigenmodes()
    
    assert omega.shape == (10,)
    assert modes.shape == (10, 10)


def test_eigenmodes_positive_frequencies():
    """Test that all eigenfrequencies are non-negative."""
    chain = OscillatorChain1D(n=10, k=1.0, m=1.0)
    omega, modes = chain.eigenmodes()
    
    assert np.all(omega >= 0)


def test_eigenmodes_count():
    """Test that number of modes equals n."""
    for n in [1, 5, 10, 20]:
        chain = OscillatorChain1D(n=n, k=1.0, m=1.0)
        omega, modes = chain.eigenmodes()
        
        assert len(omega) == n
        assert modes.shape[1] == n


def test_eigenmodes_sorted():
    """Test that eigenfrequencies are sorted."""
    chain = OscillatorChain1D(n=10, k=1.0, m=1.0)
    omega, modes = chain.eigenmodes()
    
    # eigh returns sorted eigenvalues
    assert np.all(omega[:-1] <= omega[1:])


def test_eigenmodes_orthogonal():
    """Test that eigenmodes are orthogonal."""
    chain = OscillatorChain1D(n=10, k=1.0, m=1.0)
    omega, modes = chain.eigenmodes()
    
    # Eigenvectors should be orthogonal: V^T V = I
    identity = modes.T @ modes
    np.testing.assert_array_almost_equal(identity, np.eye(10), decimal=10)


def test_different_parameters():
    """Test oscillator chain with different parameters."""
    chain1 = OscillatorChain1D(n=10, k=1.0, m=1.0)
    chain2 = OscillatorChain1D(n=10, k=2.0, m=1.0)  # Stiffer
    chain3 = OscillatorChain1D(n=10, k=1.0, m=2.0)  # Heavier
    
    omega1, _ = chain1.eigenmodes()
    omega2, _ = chain2.eigenmodes()
    omega3, _ = chain3.eigenmodes()
    
    # Stiffer chain should have higher frequencies
    assert np.all(omega2 > omega1)
    
    # Heavier chain should have lower frequencies
    assert np.all(omega3 < omega1)



================================================================================
–§–ê–ô–õ: tests\test_medium_2d.py
================================================================================

import numpy as np
import pytest
from spectral_physics.medium_2d import OscillatorGrid2D

def test_grid_2x2_stiffness():
    # 2x2 grid
    # Indices:
    # 0 1
    # 2 3
    #
    # Neighbors:
    # 0: 1(x), 2(y) + walls
    # 1: 0(x), 3(y) + walls
    # ...
    
    grid = OscillatorGrid2D(nx=2, ny=2, kx=1.0, ky=2.0, m=1.0)
    K = grid.stiffness_matrix()
    
    assert K.shape == (4, 4)
    
    # Check symmetry
    assert np.allclose(K, K.T)
    
    # Check diagonal elements
    # Each node has 2 neighbors in x (one might be wall) and 2 in y (one might be wall)
    # With fixed boundaries, every node is connected to 2 neighbors in X (k=1) and 2 in Y (k=2)
    # Total stiffness = 2*kx + 2*ky = 2*1 + 2*2 = 6
    expected_diag = 6.0
    assert np.allclose(np.diag(K), expected_diag)
    
    # Check off-diagonals
    # 0-1 (horizontal): -kx = -1
    assert K[0, 1] == -1.0
    # 0-2 (vertical): -ky = -2
    assert K[0, 2] == -2.0
    # 0-3 (diagonal): 0
    assert K[0, 3] == 0.0

def test_eigenmodes_positive():
    grid = OscillatorGrid2D(nx=3, ny=3, kx=1.0, ky=1.0, m=1.0)
    omega, modes = grid.eigenmodes()
    
    assert len(omega) == 9
    assert modes.shape == (9, 9)
    
    # Frequencies should be positive (stable system)
    assert np.all(omega >= 0)
    
    # First mode should be > 0 (no zero modes for fixed boundaries)
    assert omega[0] > 0

def test_eigenmodes_subset():
    grid = OscillatorGrid2D(nx=5, ny=5, kx=1.0, ky=1.0, m=1.0)
    n_modes = 5
    omega, modes = grid.eigenmodes(n_modes=n_modes)
    
    assert len(omega) == n_modes
    assert modes.shape == (25, n_modes)
    
    # Check sorted
    assert np.all(np.diff(omega) >= 0)



================================================================================
–§–ê–ô–õ: tests\test_report.py
================================================================================

import tempfile
import pytest
from pathlib import Path
from spectral_physics.report import generate_markdown_report

def test_generate_markdown_report_basic():
    """Test basic report generation."""
    scores = {"ch1": 0.05, "ch2": 0.25}
    thresholds = {"ch1": 0.1, "ch2": 0.2}
    
    with tempfile.NamedTemporaryFile(suffix='.md', delete=False) as f:
        temp_path = f.name
        
    try:
        generate_markdown_report(scores, thresholds, temp_path)
        
        with open(temp_path, 'r', encoding='utf-8') as f:
            content = f.read()
            
        assert "# Spectral Health Report" in content
        assert "| `ch1` | 0.050000 | 0.100000 | üü¢ OK |" in content
        assert "| `ch2` | 0.250000 | 0.200000 | üî¥ **ANOMALY** |" in content
        assert "Anomalies detected!" in content
        
    finally:
        Path(temp_path).unlink()

def test_generate_markdown_report_all_ok():
    """Test report generation when everything is OK."""
    scores = {"ch1": 0.05}
    thresholds = {"ch1": 0.1}
    
    with tempfile.NamedTemporaryFile(suffix='.md', delete=False) as f:
        temp_path = f.name
        
    try:
        generate_markdown_report(scores, thresholds, temp_path)
        
        with open(temp_path, 'r', encoding='utf-8') as f:
            content = f.read()
            
        assert "All systems nominal" in content
        assert "Anomalies detected!" not in content
        
    finally:
        Path(temp_path).unlink()



================================================================================
–§–ê–ô–õ: tests\test_root_finding.py
================================================================================

import numpy as np
import pytest
from spectral_physics.root_finding import symmetric_newton


def test_simple_quadratic():
    """Test f(x) = x^2 - 2, root should be sqrt(2)."""
    def f(x):
        return x**2 - 2
    
    x_root, n_iter = symmetric_newton(f, x0=1.0)
    
    expected = np.sqrt(2)
    assert abs(x_root - expected) < 1e-8
    assert n_iter < 50


def test_cubic_at_zero():
    """Test f(x) = x^3, root at 0 with flat minimum."""
    def f(x):
        return x**3
    
    x_root, n_iter = symmetric_newton(f, x0=0.1, tol=1e-6)
    
    assert abs(x_root) < 1e-4
    assert n_iter < 50


def test_with_kink():
    """Test function with kink: f(x) = abs(x) - 1e-3."""
    def f(x):
        return abs(x) - 1e-3
    
    # Start from positive side
    x_root, n_iter = symmetric_newton(f, x0=1.0, tol=1e-6)
    
    # Should converge to one of the roots (¬±1e-3)
    assert abs(abs(x_root) - 1e-3) < 1e-5


def test_cubic_polynomial():
    """Test f(x) = x^3 - x - 1."""
    def f(x):
        return x**3 - x - 1
    
    x_root, n_iter = symmetric_newton(f, x0=1.5)
    
    # Check that it's actually a root
    assert abs(f(x_root)) < 1e-8
    assert n_iter < 50


def test_return_type():
    """Test that function returns tuple of (float, int)."""
    def f(x):
        return x - 5
    
    result = symmetric_newton(f, x0=1.0)
    
    assert isinstance(result, tuple)
    assert len(result) == 2
    assert isinstance(result[0], float)
    assert isinstance(result[1], int)


def test_convergence_count():
    """Test that iteration count is reasonable."""
    def f(x):
        return x - 10  # Linear, should converge in 1 iteration
    
    x_root, n_iter = symmetric_newton(f, x0=0.0)
    
    assert abs(x_root - 10) < 1e-8
    assert n_iter <= 5  # Should be very fast for linear


def test_exponential_function():
    """Test f(x) = exp(x) - 2."""
    def f(x):
        return np.exp(x) - 2
    
    x_root, n_iter = symmetric_newton(f, x0=0.0)
    
    expected = np.log(2)
    assert abs(x_root - expected) < 1e-8


def test_trigonometric_function():
    """Test f(x) = sin(x)."""
    def f(x):
        return np.sin(x)
    
    x_root, n_iter = symmetric_newton(f, x0=3.0)
    
    # Should converge to pi
    assert abs(x_root - np.pi) < 1e-6


def test_max_iterations():
    """Test that max_iter limit is respected."""
    def f(x):
        return x**2 + 1  # No real root
    
    x_root, n_iter = symmetric_newton(f, x0=1.0, max_iter=10)
    
    assert n_iter == 10


def test_initial_guess_is_root():
    """Test when initial guess is already the root."""
    def f(x):
        return x - 5
    
    x_root, n_iter = symmetric_newton(f, x0=5.0)
    
    assert abs(x_root - 5.0) < 1e-8
    assert n_iter == 0  # Should converge immediately


def test_tol_step_stops_on_flat_region():
    """Test that tol_step criterion stops iteration on flat regions."""
    def f(x):
        return x**3
    
    # With very tight tol, we'd wait forever
    # But tol_step should kick in and stop earlier
    x_root, n_iter = symmetric_newton(f, x0=1.0, tol=1e-20, tol_step=1e-6)
    
    # Should stop due to small step, not small function value
    assert n_iter < 50
    # Result should still be close to zero
    assert abs(x_root) < 0.1




================================================================================
–§–ê–ô–õ: tests\test_spectrum.py
================================================================================

import numpy as np
import pytest
from spectral_physics.spectrum import Spectrum1D


def test_spectrum_creation():
    """Test basic Spectrum1D creation."""
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([0.5, 1.0, 0.5])
    
    spec = Spectrum1D(omega=omega, power=power)
    
    assert spec.omega.shape == (3,)
    assert spec.power.shape == (3,)
    np.testing.assert_array_equal(spec.omega, omega)
    np.testing.assert_array_equal(spec.power, power)


def test_spectrum_shape_mismatch():
    """Test that mismatched shapes raise ValueError."""
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([0.5, 1.0])  # Wrong size
    
    with pytest.raises(ValueError, match="Shape mismatch"):
        Spectrum1D(omega=omega, power=power)


def test_total_power():
    """Test total_power calculation."""
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([1.0, 2.0, 3.0])
    
    spec = Spectrum1D(omega=omega, power=power)
    total = spec.total_power()
    
    assert total == 6.0


def test_normalize():
    """Test spectrum normalization."""
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([1.0, 2.0, 3.0])
    
    spec = Spectrum1D(omega=omega, power=power)
    normalized = spec.normalize()
    
    # Check that sum is 1
    assert abs(normalized.total_power() - 1.0) < 1e-10
    
    # Check that relative proportions are preserved
    np.testing.assert_allclose(
        normalized.power,
        power / 6.0,
        rtol=1e-10
    )
    
    # Original should be unchanged
    assert spec.total_power() == 6.0


def test_normalize_zero_power():
    """Test that normalizing zero power raises ValueError."""
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([0.0, 0.0, 0.0])
    
    spec = Spectrum1D(omega=omega, power=power)
    
    with pytest.raises(ValueError, match="zero total power"):
        spec.normalize()


def test_apply_filter():
    """Test applying frequency-dependent filter."""
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([1.0, 2.0, 3.0])
    alpha = np.array([1.0, 0.5, 0.0])  # Pass first, attenuate second, block third
    
    spec = Spectrum1D(omega=omega, power=power)
    filtered = spec.apply_filter(alpha)
    
    expected_power = power * alpha
    np.testing.assert_array_equal(filtered.power, expected_power)
    np.testing.assert_array_equal(filtered.omega, omega)
    
    # Original should be unchanged
    np.testing.assert_array_equal(spec.power, power)


def test_apply_filter_shape_mismatch():
    """Test that mismatched filter shape raises ValueError."""
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([1.0, 2.0, 3.0])
    alpha = np.array([1.0, 0.5])  # Wrong size
    
    spec = Spectrum1D(omega=omega, power=power)
    
    with pytest.raises(ValueError, match="Shape mismatch"):
        spec.apply_filter(alpha)


def test_total_power_with_trapz():
    """Test that total_power matches np.trapz for uniform grid."""
    # Uniform frequency grid
    omega = np.linspace(0, 10, 100)
    power = np.exp(-omega)  # Exponential decay
    
    spec = Spectrum1D(omega=omega, power=power)
    
    # For sum, we just add all values
    total_sum = spec.total_power()
    
    # For trapz integration
    total_trapz = np.trapz(power, omega)
    
    # They should be different (sum vs integral)
    # but both should be reasonable
    assert total_sum > 0
    assert total_trapz > 0
    
    # The integral should be smaller than the sum for this case
    # because trapz accounts for spacing
    assert total_trapz < total_sum


def test_from_function():
    """Test creating Spectrum1D from a function."""
    omega = np.linspace(0, 1, 5)
    spec = Spectrum1D.from_function(omega, lambda w: 2*w)
    
    np.testing.assert_array_equal(spec.omega, omega)
    np.testing.assert_array_equal(spec.power, 2*omega)


def test_from_function_exponential():
    """Test from_function with exponential decay."""
    omega = np.linspace(0, 5, 50)
    spec = Spectrum1D.from_function(omega, np.exp)
    
    expected_power = np.exp(omega)
    np.testing.assert_array_almost_equal(spec.power, expected_power)


def test_from_function_shape_mismatch():
    """Test that from_function raises error for wrong return shape."""
    omega = np.linspace(0, 1, 5)
    
    def bad_func(w):
        return np.array([1.0, 2.0])  # Wrong shape
    
    with pytest.raises(ValueError, match="same shape"):
        Spectrum1D.from_function(omega, bad_func)





================================================================================
–§–ê–ô–õ: tests\test_timeseries.py
================================================================================

import numpy as np
import pytest
from spectral_physics.timeseries import timeseries_to_spectrum


def test_single_sine_wave():
    """Test that single sine wave produces peak at correct frequency."""
    # Generate 50 Hz sine wave
    freq = 50.0  # Hz
    duration = 1.0  # seconds
    dt = 0.001  # 1 ms sampling
    
    t = np.arange(0, duration, dt)
    signal = np.sin(2 * np.pi * freq * t)
    
    spectrum = timeseries_to_spectrum(signal, dt=dt)
    
    # Find peak frequency
    peak_idx = np.argmax(spectrum.power)
    peak_omega = spectrum.omega[peak_idx]
    peak_freq_hz = peak_omega / (2 * np.pi)
    
    # Should be close to 50 Hz
    assert abs(peak_freq_hz - freq) < 2.0  # Within 2 Hz


def test_two_sine_waves():
    """Test that sum of two sines produces two peaks."""
    freq1 = 50.0  # Hz
    freq2 = 120.0  # Hz
    duration = 1.0
    dt = 0.001
    
    t = np.arange(0, duration, dt)
    signal = np.sin(2 * np.pi * freq1 * t) + 0.5 * np.sin(2 * np.pi * freq2 * t)
    
    spectrum = timeseries_to_spectrum(signal, dt=dt)
    
    # Convert omega to Hz
    freq_hz = spectrum.omega / (2 * np.pi)
    
    # Find two largest peaks
    peak_indices = np.argsort(spectrum.power)[-2:]
    peak_freqs = sorted(freq_hz[peak_indices])
    
    # Should have peaks near 50 and 120 Hz
    assert abs(peak_freqs[0] - freq1) < 5.0
    assert abs(peak_freqs[1] - freq2) < 5.0


def test_constant_signal():
    """Test that constant signal has maximum only near zero frequency."""
    duration = 1.0
    dt = 0.001
    
    t = np.arange(0, duration, dt)
    signal = np.ones_like(t) * 5.0  # Constant
    
    spectrum = timeseries_to_spectrum(signal, dt=dt)
    
    # Peak should be at or very close to zero frequency
    peak_idx = np.argmax(spectrum.power)
    peak_omega = spectrum.omega[peak_idx]
    
    assert peak_omega < 10.0  # Very low frequency


def test_window_none():
    """Test that window=None works."""
    freq = 50.0
    duration = 1.0
    dt = 0.001
    
    t = np.arange(0, duration, dt)
    signal = np.sin(2 * np.pi * freq * t)
    
    spectrum = timeseries_to_spectrum(signal, dt=dt, window=None)
    
    # Should still produce spectrum
    assert len(spectrum.omega) > 0
    assert len(spectrum.power) > 0


def test_window_hann():
    """Test that window='hann' works."""
    freq = 50.0
    duration = 1.0
    dt = 0.001
    
    t = np.arange(0, duration, dt)
    signal = np.sin(2 * np.pi * freq * t)
    
    spectrum = timeseries_to_spectrum(signal, dt=dt, window="hann")
    
    # Should still produce spectrum
    assert len(spectrum.omega) > 0
    assert len(spectrum.power) > 0


def test_invalid_window():
    """Test that invalid window raises ValueError."""
    signal = np.array([1.0, 2.0, 3.0])
    dt = 0.1
    
    with pytest.raises(ValueError, match="Unknown window type"):
        timeseries_to_spectrum(signal, dt=dt, window="invalid")


def test_empty_signal():
    """Test that empty signal raises ValueError."""
    signal = np.array([])
    dt = 0.1
    
    with pytest.raises(ValueError, match="must not be empty"):
        timeseries_to_spectrum(signal, dt=dt)


def test_multidimensional_signal():
    """Test that 2D signal raises ValueError."""
    signal = np.array([[1.0, 2.0], [3.0, 4.0]])
    dt = 0.1
    
    with pytest.raises(ValueError, match="must be 1D array"):
        timeseries_to_spectrum(signal, dt=dt)


def test_dc_removal():
    """Test that DC component is removed."""
    duration = 1.0
    dt = 0.001
    
    t = np.arange(0, duration, dt)
    signal = 10.0 + np.sin(2 * np.pi * 50 * t)  # DC offset + sine
    
    spectrum = timeseries_to_spectrum(signal, dt=dt)
    
    # DC component (first element) should be small after DC removal
    # Note: won't be exactly zero due to window, but should be reduced
    assert spectrum.power[0] < np.max(spectrum.power)


def test_positive_frequencies_only():
    """Test that only positive frequencies are returned."""
    signal = np.random.randn(100)
    dt = 0.01
    
    spectrum = timeseries_to_spectrum(signal, dt=dt)
    
    # All frequencies should be >= 0
    assert np.all(spectrum.omega >= 0)





================================================================================
–§–ê–ô–õ: pyproject.toml
================================================================================

[build-system]
requires = ["setuptools>=61.0"]
build-backend = "setuptools.build_meta"

[project]
name = "spectral-physics-lab"
version = "0.1.0"
description = "Experimental spectral physics toolkit for diagnostics and anomaly detection"
readme = "README.md"
requires-python = ">=3.11"
authors = [
  { name = "Robert Paulig" },
]
dependencies = [
  "numpy>=1.25",
  "scipy>=1.11",
  "matplotlib>=3.7",
  "pyyaml>=6.0",
]

[project.scripts]
spectral-health = "spectral_physics.cli:main"

[tool.setuptools.packages.find]
where = ["src"]

[tool.setuptools.package-data]
spectral_physics = ["py.typed"]



================================================================================
–§–ê–ô–õ: README.md
================================================================================

# SpectralPhysics-Lab

**SpectralPhysics-Lab** ‚Äî —ç—Ç–æ —ç–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç–∞–ª—å–Ω—ã–π –∫–æ–¥–æ–≤—ã–π —Å—Ç–µ–Ω–¥ –¥–ª—è –Ω–æ–≤–æ–π "—Å–ø–µ–∫—Ç—Ä–∞–ª—å–Ω–æ–π —Ñ–∏–∑–∏–∫–∏":

- –í–º–µ—Å—Ç–æ —à–∞—Ä–∏–∫–æ–≤ –∏ —Å–∏–ª: **–°—Ä–µ–¥–∞** –∏ **–∫–æ–ª–µ–±–∞—Ç–µ–ª—å–Ω—ã–µ —Ä–µ–∂–∏–º—ã** (–º–æ–¥—ã).
- –í–º–µ—Å—Ç–æ "–º–∞—Å—Å–∞ —Ç—è–Ω–µ—Ç –º–∞—Å—Å—É": **—Å–ø–µ–∫—Ç—Ä–∞–ª—å–Ω–∞—è —Ç–µ–Ω—å** –∏ **–¥–∞–≤–ª–µ–Ω–∏–µ —Ñ–æ–Ω–æ–≤–æ–≥–æ –ø–æ–ª—è**.
- –í–º–µ—Å—Ç–æ –º–∞–≥–∏–∏ –∫–≤–∞–Ω—Ç–æ–≤–æ–π –º–µ—Ö–∞–Ω–∏–∫–∏: **—É—Å—Ç–æ–π—á–∏–≤—ã–µ —Ä–µ–∑–æ–Ω–∞—Ç–æ—Ä—ã** (—Å–æ–ª–∏—Ç–æ–Ω—ã) –≤ –µ–¥–∏–Ω–æ–π –°—Ä–µ–¥–µ.

–¶–µ–ª—å —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è ‚Äî —Å–æ–±—Ä–∞—Ç—å **—Ä–∞–±–æ—á–∏–π –Ω–∞–±–æ—Ä –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤**, —Å –∫–æ—Ç–æ—Ä—ã–º –º–æ–∂–Ω–æ:

- –º–æ–¥–µ–ª–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–æ—Å—Ç–µ–π—à–∏–µ "—Å—Ä–µ–¥—ã" –∏ —Å–æ–ª–∏—Ç–æ–Ω—ã;
- —Å—á–∏—Ç–∞—Ç—å —Å–ø–µ–∫—Ç—Ä—ã (—á–∞—Å—Ç–æ—Ç–Ω—ã–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è, –ª–æ–∫–∞–ª—å–Ω—É—é –ø–ª–æ—Ç–Ω–æ—Å—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–π);
- –∏–≥—Ä–∞—Ç—å—Å—è —Å "–º–∞—Å–∫–æ–π" (—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–∞—è –º–∞—Å—Å–∞, –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏—è, –≤–∞–ª–µ–Ω—Ç–Ω–æ—Å—Ç—å) –∫–∞–∫ —Å **—Å–ø–µ–∫—Ç—Ä–∞–ª—å–Ω—ã–º–∏ –æ–±—ä–µ–∫—Ç–∞–º–∏**;
- –≥–æ—Ç–æ–≤–∏—Ç—å –æ—Å–Ω–æ–≤—É –¥–ª—è –ø—Ä–∏–∫–ª–∞–¥–Ω—ã—Ö –∑–∞–¥–∞—á (–¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ –º–∞—à–∏–Ω, –≥–µ–æ—Ñ–∏–∑–∏–∫–∞, —Ç.–¥.).

> –í–∞–∂–Ω–æ: —ç—Ç–æ –Ω–µ "–∫—Ä–∞—Å–∏–≤–∞—è —Ç–µ–æ—Ä–∏—è –Ω–∞ –±—É–º–∞–≥–µ", –∞ –ø–µ—Å–æ—á–Ω–∏—Ü–∞,
> –≥–¥–µ –ª—é–±–∞—è –∏–¥–µ—è –¥–æ–ª–∂–Ω–∞ –¥–æ–ø–æ–ª–∑—Ç–∏ –¥–æ **—Ä–∞–±–æ—Ç–∞—é—â–µ–≥–æ –∫–æ–¥–∞ / —ç–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç–∞**.

---

## Installation

```bash
pip install -e .
spectral-health --help
```

---

## Quick start: Pump health demo

```bash
# 1. –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ
python examples/generate_synthetic_pump_data.py

# 2. –û–±—É—á–∏—Ç—å –ø—Ä–æ—Ñ–∏–ª—å "–∑–¥–æ—Ä–æ–≤–æ–≥–æ" —Å–æ—Å—Ç–æ—è–Ω–∏—è
spectral-health train \
  --config configs/pump_train.yaml \
  --out data/pump/profile.npz

# 3. –û—Ü–µ–Ω–∏—Ç—å —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏ –ø–æ–ª—É—á–∏—Ç—å –æ—Ç—á—ë—Ç
spectral-health score \
  --config configs/pump_score.yaml \
  --profile data/pump/profile.npz \
  --thresholds configs/pump_thresholds.yaml \
  --report data/pump/report.md
```

## 2D medium demo

–°–º–æ—Ç—Ä–∏—Ç–µ `examples/medium_2d_modes_demo.ipynb` ‚Äî —Ç–∞–º –≤–∏–¥–Ω–æ,
–∫–∞–∫ —É –ø–ª–∞—Å—Ç–∏–Ω—ã –ø–æ—è–≤–ª—è—é—Ç—Å—è –º–æ–¥—ã –∫–æ–ª–µ–±–∞–Ω–∏–π (—Å—Ç–æ—è—á–∏–µ –≤–æ–ª–Ω—ã).

## Atomic valence as surface resonances (toy model)

–°–º–æ—Ç—Ä–∏—Ç–µ `examples/atomic_valence_demo.ipynb`: —Ç–∞–º –ø–æ–∫–∞–∑–∞–Ω–æ,
–∫–∞–∫ –º–æ–∂–Ω–æ –¥—É–º–∞—Ç—å –ø—Ä–æ –≤–∞–ª–µ–Ω—Ç–Ω–æ—Å—Ç—å –∫–∞–∫ –ø—Ä–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–æ–≤–ø–∞–¥–∞—é—â–∏—Ö
—Ä–µ–∑–æ–Ω–∞–Ω—Å–Ω—ã—Ö —á–∞—Å—Ç–æ—Ç –º–µ–∂–¥—É "–∞—Ç–æ–º–∞–º–∏"-—Ä–µ–∑–æ–Ω–∞—Ç–æ—Ä–∞–º–∏.

---

## –¢–µ–∫—É—â–∏–π —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–π —Ñ–æ–∫—É—Å

1. **–ë–∞–∑–æ–≤–∞—è –º–∞—Ç–µ–º–∞—Ç–∏–∫–∞**  
   - –†–µ–∞–ª–∏–∑–∞—Ü–∏—è *—Å–∏–º–º–µ—Ç—Ä–∏—á–Ω–æ–≥–æ –º–µ—Ç–æ–¥–∞ –ù—å—é—Ç–æ–Ω–∞* –¥–ª—è –ø–æ–∏—Å–∫–∞ –∫–æ—Ä–Ω–µ–π –Ω–µ–ª–∏–Ω–µ–π–Ω—ã—Ö —É—Ä–∞–≤–Ω–µ–Ω–∏–π –∏ —Å–∏—Å—Ç–µ–º **–±–µ–∑ —è–≤–Ω—ã—Ö –ø—Ä–æ–∏–∑–≤–æ–¥–Ω—ã—Ö**.
   - –û–±—ë—Ä—Ç–∫–∏ –¥–ª—è —É—Å—Ç–æ–π—á–∏–≤–æ–≥–æ —Ä–µ—à–µ–Ω–∏—è –∑–∞–¥–∞—á "–ø–æ–¥–±–æ—Ä –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –º–æ–¥–µ–ª–∏ –ø–æ–¥ –¥–∞–Ω–Ω—ã–µ".

2. **–°–ø–µ–∫—Ç—Ä–∞–ª—å–Ω—ã–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏—è**
   - –ö–ª–∞—Å—Å—ã –¥–ª—è –æ–ø–∏—Å–∞–Ω–∏—è 1D-—Å–ø–µ–∫—Ç—Ä–æ–≤ (—á–∞—Å—Ç–æ—Ç—ã, –∞–º–ø–ª–∏—Ç—É–¥—ã, —Ñ–∞–∑—ã).
   - –ü—Ä–æ—Å—Ç–µ–π—à–∞—è –º–æ–¥–µ–ª—å *–ª–æ–∫–∞–ª—å–Ω–æ–π —Å–ø–µ–∫—Ç—Ä–∞–ª—å–Ω–æ–π –ø–ª–æ—Ç–Ω–æ—Å—Ç–∏* `rho_spec(x, œâ)` –≤ –¥–∏—Å–∫—Ä–µ—Ç–Ω–æ–º –≤–∏–¥–µ (—Å–µ—Ç–∫–∞ –ø–æ x –∏ –ø–æ —á–∞—Å—Ç–æ—Ç–µ).

3. **–ü—Ä–æ—Å—Ç—ã–µ —Ñ–∏–∑–∏—á–µ—Å–∫–∏–µ –∏–≥—Ä—É—à–∫–∏ (toy models)**
   - 1D-—Ü–µ–ø–æ—á–∫–∞ –æ—Å—Ü–∏–ª–ª—è—Ç–æ—Ä–æ–≤ (—É–ø—Ä—É–≥–∞—è –°—Ä–µ–¥–∞).
   - –°–ø–µ–∫—Ç—Ä–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –Ω–æ—Ä–º–∞–ª—å–Ω—ã—Ö –º–æ–¥ (–º–æ–¥—ã –∫–æ–ª–µ–±–∞–Ω–∏–π —Ü–µ–ø–æ—á–∫–∏).
   - –ü—Ä–æ—Å—Ç–µ–π—à–∞—è "–≥—Ä–∞–≤–∏—Ç–∞—Ü–∏–æ–Ω–Ω–∞—è" –º–æ–¥–µ–ª—å –∫–∞–∫ **–¥–∏—Å–±–∞–ª–∞–Ω—Å —Å–ø–µ–∫—Ç—Ä–∞**: –≤–ª–∏—è–Ω–∏–µ "–ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏" –º–∞—Ç–µ—Ä–∏–∞–ª–∞ –Ω–∞ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–µ "—É—Å–∫–æ—Ä–µ–Ω–∏–µ".

---

## –ü–ª–∞–Ω–∏—Ä—É–µ–º–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è

```text
SpectralPhysics-Lab/
‚îú‚îÄ README.md                # —ç—Ç–æ—Ç —Ñ–∞–π–ª
‚îú‚îÄ AI_TASKS.md              # –∑–∞–¥–∞–Ω–∏—è –¥–ª—è –ò–ò-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞
‚îú‚îÄ pyproject.toml           # —É–ø–∞–∫–æ–≤–∫–∞ –ø—Ä–æ–µ–∫—Ç–∞ –∫–∞–∫ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏
‚îú‚îÄ src/
‚îÇ  ‚îî‚îÄ spectral_physics/
‚îÇ     ‚îú‚îÄ __init__.py
‚îÇ     ‚îú‚îÄ root_finding.py    # —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω—ã–π –ù—å—é—Ç–æ–Ω –∏ –æ–±—ë—Ä—Ç–∫–∏
‚îÇ     ‚îú‚îÄ spectrum.py        # –∫–ª–∞—Å—Å—ã —Å–ø–µ–∫—Ç—Ä–æ–≤ –∏ —Å–ø–µ–∫—Ç—Ä–∞–ª—å–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
‚îÇ     ‚îú‚îÄ cli.py             # CLI spectral-health
‚îÇ     ‚îî‚îÄ ...
```



================================================================================
–§–ê–ô–õ: src\spectral_physics\__init__.py
================================================================================

"""
SpectralPhysics-Lab: –±–∞–∑–æ–≤—ã–µ —á–∏—Å–ª–µ–Ω–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã
–¥–ª—è —Å–ø–µ–∫—Ç—Ä–∞–ª—å–Ω–æ–π —Ñ–∏–∑–∏–∫–∏.
"""

from .root_finding import symmetric_newton
from .spectrum import Spectrum1D
from .medium_1d import OscillatorChain1D
from .grav_toy import spectral_pressure_difference
from .material import MaterialSignature
from .timeseries import timeseries_to_spectrum
from .diagnostics import (
    ChannelConfig, 
    MultiChannelConfig,
    SpectralAnalyzer, 
    HealthMonitor, 
    build_health_profile,
    average_spectrum,
    spectral_band_power,
    spectral_entropy
)
from .io import (
    load_timeseries_csv, 
    save_spectrum_npz, 
    load_spectrum_npz,
    save_health_profile,
    load_health_profile
)
from .report import generate_markdown_report

__all__ = [
    "symmetric_newton",
    "Spectrum1D",
    "OscillatorChain1D",
    "spectral_pressure_difference",
    "MaterialSignature",
    "timeseries_to_spectrum",
    "ChannelConfig",
    "MultiChannelConfig",
    "SpectralAnalyzer",
    "HealthMonitor",
    "build_health_profile",
    "average_spectrum",
    "spectral_band_power",
    "spectral_entropy",
    "load_timeseries_csv",
    "save_spectrum_npz",
    "load_spectrum_npz",
    "save_health_profile",
    "load_health_profile",
    "generate_markdown_report",
]





================================================================================
–§–ê–ô–õ: src\spectral_physics\atoms.py
================================================================================

import numpy as np
from dataclasses import dataclass
from .spectrum import Spectrum1D

@dataclass
class AtomicResonator:
    """
    –ò–≥—Ä—É—à–µ—á–Ω–∞—è –º–æ–¥–µ–ª—å –∞—Ç–æ–º–∞ –∫–∞–∫ –Ω–∞–±–æ—Ä–∞ —Ä–µ–∑–æ–Ω–∞–Ω—Å–Ω—ã—Ö —á–∞—Å—Ç–æ—Ç –Ω–∞ –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏.
    """
    name: str
    omega: np.ndarray        # —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ —á–∞—Å—Ç–æ—Ç—ã (—Ä–∞–¥/—Å –∏–ª–∏ —É—Å–ª–æ–≤–Ω—ã–µ –µ–¥–∏–Ω–∏—Ü—ã)
    power: np.ndarray        # "–∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å" / –≤–µ—Å–∞ –ª–∏–Ω–∏–π
    max_bonds: int           # —Å–∫–æ–ª—å–∫–æ —Å–≤—è–∑–µ–π –∞—Ç–æ–º "–≤—ã–¥–µ—Ä–∂–∏–≤–∞–µ—Ç"
    core_modes: list[tuple[float, float]] = None    # –¥–∏–∞–ø–∞–∑–æ–Ω—ã —á–∞—Å—Ç–æ—Ç —è–¥—Ä–∞ (—Å—Ç–∞–±–∏–ª—å–Ω—ã–µ)
    valence_modes: list[tuple[float, float]] = None # –¥–∏–∞–ø–∞–∑–æ–Ω—ã —á–∞—Å—Ç–æ—Ç –≤–∞–ª–µ–Ω—Ç–Ω–æ—Å—Ç–∏ (–∞–∫—Ç–∏–≤–Ω—ã–µ)

    def __post_init__(self):
        if self.core_modes is None:
            self.core_modes = []
        if self.valence_modes is None:
            self.valence_modes = []

    @classmethod
    def from_lines(
        cls,
        name: str,
        lines: list[tuple[float, float]],
        max_bonds: int,
        core_modes: list[tuple[float, float]] = None,
        valence_modes: list[tuple[float, float]] = None,
    ) -> "AtomicResonator":
        """
        lines: —Å–ø–∏—Å–æ–∫ (—á–∞—Å—Ç–æ—Ç–∞, –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å)
        """
        if not lines:
            return cls(name=name, omega=np.array([]), power=np.array([]), max_bonds=max_bonds,
                       core_modes=core_modes, valence_modes=valence_modes)
            
        omega = np.array([f for f, a in lines], dtype=float)
        power = np.array([a for f, a in lines], dtype=float)
        return cls(name=name, omega=omega, power=power, max_bonds=max_bonds,
                   core_modes=core_modes, valence_modes=valence_modes)

    def spectrum(self) -> Spectrum1D:
        """
        –í–µ—Ä–Ω—É—Ç—å Spectrum1D —Å –∑–∞–¥–∞–Ω–Ω—ã–º–∏ –ª–∏–Ω–∏—è–º–∏.
        """
        return Spectrum1D(omega=self.omega, power=self.power)

    def normalized_spectrum(self) -> Spectrum1D:
        """
        –ù–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Å–ø–µ–∫—Ç—Ä (—Å—É–º–º–∞ power = 1).
        """
        return self.spectrum().normalize()


def spectral_overlap(
    atom_a: AtomicResonator,
    atom_b: AtomicResonator,
    freq_tol: float = 0.05,
) -> float:
    """
    –û—Ü–µ–Ω–∫–∞ "—Ä–µ–∑–æ–Ω–∞–Ω—Å–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏" –¥–≤—É—Ö –∞—Ç–æ–º–æ–≤.

    –ò–¥–µ—è:
    - –±–µ—Ä—ë–º –ª–∏–Ω–∏–∏ –∏–∑ A –∏ B
    - –µ—Å–ª–∏ —Ä–∞–∑–Ω–æ—Å—Ç—å —á–∞—Å—Ç–æ—Ç |œâ_a - œâ_b| < freq_tol * œâ_avg,
      —Å—á–∏—Ç–∞–µ–º, —á—Ç–æ —ç—Ç–∏ –ª–∏–Ω–∏–∏ –º–æ–≥—É—Ç "—Å—Ü–µ–ø–∏—Ç—å—Å—è"
    - —Å—É–º–º–∞–µ–º –≤–µ—Å–∞ —Å–æ–≤–ø–∞–¥–∞—é—â–∏—Ö –ª–∏–Ω–∏–π –∫–∞–∫ –º–µ—Ä—É —Å–∏–ª—ã —Å–≤—è–∑–∏.

    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —á–∏—Å–ª–æ [0..1] –ø—Ä–∏–º–µ—Ä–Ω–æ: —á–µ–º –±–æ–ª—å—à–µ, —Ç–µ–º "–ª—É—á—à–µ" —Å–≤—è–∑—å.
    """
    if len(atom_a.omega) == 0 or len(atom_b.omega) == 0:
        return 0.0
        
    overlap_score = 0.0
    
    # –ù–æ—Ä–º–∏—Ä—É–µ–º –≤–µ—Å–∞, —á—Ç–æ–±—ã –æ—Ü–µ–Ω–∫–∞ –Ω–µ –∑–∞–≤–∏—Å–µ–ª–∞ –æ—Ç –∞–±—Å–æ–ª—é—Ç–Ω–æ–π –∞–º–ø–ª–∏—Ç—É–¥—ã
    # (–∏–ª–∏ —Å—á–∏—Ç–∞–µ–º, —á—Ç–æ power —É–∂–µ –æ—Ç—Ä–∞–∂–∞–µ—Ç "–≤–∞–∂–Ω–æ—Å—Ç—å")
    # –î–∞–≤–∞–π—Ç–µ —Ä–∞–±–æ—Ç–∞—Ç—å —Å –Ω–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ —Å–ø–µ–∫—Ç—Ä–∞–º–∏ –¥–ª—è —á–µ—Å—Ç–Ω–æ—Å—Ç–∏
    spec_a = atom_a.normalized_spectrum()
    spec_b = atom_b.normalized_spectrum()
    
    # –ü—Ä–æ—Å—Ç–æ–π –ø–µ—Ä–µ–±–æ—Ä –≤—Å–µ—Ö –ø–∞—Ä –ª–∏–Ω–∏–π (O(Na * Nb)) - –¥–ª—è –∞—Ç–æ–º–æ–≤ —ç—Ç–æ –º–∞–ª–æ
    for i, wa in enumerate(spec_a.omega):
        pa = spec_a.power[i]
        
        for j, wb in enumerate(spec_b.omega):
            pb = spec_b.power[j]
            
            w_avg = (wa + wb) / 2.0
            if w_avg == 0:
                continue
                
            diff = abs(wa - wb)
            
            if diff < freq_tol * w_avg:
                # –†–µ–∑–æ–Ω–∞–Ω—Å!
                # –í–∫–ª–∞–¥ –≤ —Å–≤—è–∑—å –ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª–µ–Ω –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—é –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç–µ–π (–∏–ª–∏ –º–∏–Ω–∏–º—É–º—É?)
                # –ü—É—Å—Ç—å –±—É–¥–µ—Ç –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ, –∫–∞–∫ –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è
                # –ò–ª–∏ —Å—É–º–º–∞?
                # –¢–ó: "—Å—É–º–º–∞–µ–º –≤–µ—Å–∞ —Å–æ–≤–ø–∞–¥–∞—é—â–∏—Ö –ª–∏–Ω–∏–π"
                # –í–æ–∑—å–º–µ–º min(pa, pb) –∫–∞–∫ "–æ–±—â–∞—è —ç–Ω–µ—Ä–≥–∏—è —Ä–µ–∑–æ–Ω–∞–Ω—Å–∞"
                overlap_score += min(pa, pb)
                
    # –û–≥—Ä–∞–Ω–∏—á–∏–º 1.0 (—Ö–æ—Ç—è –º–æ–∂–µ—Ç –±—ã—Ç—å –∏ –±–æ–ª—å—à–µ, –µ—Å–ª–∏ –º–Ω–æ–≥–æ –ª–∏–Ω–∏–π —Å–æ–≤–ø–∞–¥–∞—é—Ç —Å –æ–¥–Ω–æ–π)
    return min(overlap_score, 1.0)


def can_form_bond(
    atom_a: AtomicResonator,
    atom_b: AtomicResonator,
    freq_tol: float,
    threshold: float,
) -> bool:
    """
    –†–µ—à–∞–µ–º, –≤–æ–∑–º–æ–∂–Ω–∞ –ª–∏ —É—Å—Ç–æ–π—á–∏–≤–æ–µ "—Å—Ü–µ–ø–ª–µ–Ω–∏–µ":
    overlap >= threshold –∏ –Ω–µ –ø—Ä–µ–≤—ã—à–µ–Ω—ã max_bonds —É –æ–±–æ–∏—Ö.
    """
    if atom_a.max_bonds <= 0 or atom_b.max_bonds <= 0:
        return False
        
    score = spectral_overlap(atom_a, atom_b, freq_tol)
    return score >= threshold


def load_default_atom_db() -> dict[str, AtomicResonator]:
    """
    Load a 'toy' database of atoms with spectral properties.
    """
    db = {}
    
    # Hydrogen: Simple, one valence mode
    db['H'] = AtomicResonator.from_lines(
        name="H",
        lines=[(1.0, 1.0)],
        max_bonds=1,
        valence_modes=[(0.9, 1.1)]
    )
    
    # Carbon: Complex, core modes + valence
    db['C'] = AtomicResonator.from_lines(
        name="C",
        lines=[(0.5, 0.4), (1.0, 0.8), (1.5, 0.6)], # 0.5 core, 1.0/1.5 valence
        max_bonds=4,
        core_modes=[(0.4, 0.6)],
        valence_modes=[(0.9, 1.6)]
    )
    
    # Oxygen: Electronegative, distinct modes
    db['O'] = AtomicResonator.from_lines(
        name="O",
        lines=[(0.8, 0.6), (1.2, 0.9)],
        max_bonds=2,
        core_modes=[(0.7, 0.9)],
        valence_modes=[(1.1, 1.3)]
    )
    
    # Iron: Heavy, low frequency core, many lines
    db['Fe'] = AtomicResonator.from_lines(
        name="Fe",
        lines=[(0.2, 0.8), (0.3, 0.7), (0.8, 0.5)],
        max_bonds=6,
        core_modes=[(0.1, 0.4)],
        valence_modes=[(0.7, 0.9)]
    )
    
    # Silicon: Like Carbon but heavier (lower freq)
    db['Si'] = AtomicResonator.from_lines(
        name="Si",
        lines=[(0.3, 0.5), (0.7, 0.8), (1.1, 0.5)],
        max_bonds=4,
        core_modes=[(0.2, 0.4)],
        valence_modes=[(0.6, 1.2)]
    )
    
    return db



================================================================================
–§–ê–ô–õ: src\spectral_physics\cli.py
================================================================================

import argparse
import sys
import yaml
from pathlib import Path
from typing import Dict, List, Any

from .io import (
    load_timeseries_csv, 
    save_health_profile, 
    load_health_profile,
    save_ndt_profile,
    load_ndt_profile
)
from .diagnostics import (
    ChannelConfig, 
    SpectralAnalyzer, 
    build_health_profile,
)
from .material import HealthProfile
from .ndt import build_ndt_profile, score_ndt_state, ndt_defect_mask
from .medium_2d import OscillatorGrid2D
from .geophysics_2d import GeoGrid2D

from .spectrum import Spectrum1D


def load_config(path: str) -> Dict[str, Any]:
    """Load YAML configuration."""
    with open(path, 'r') as f:
        return yaml.safe_load(f)


def train_command(args):
    """Execute training command."""
    print(f"Loading config from {args.config}...")
    config = load_config(args.config)
    
    dt = config.get('dt')
    window = config.get('window', 'hann')
    channels_conf = config.get('channels', {})
    
    if not channels_conf:
        print("Error: No channels defined in config.")
        return 1
        
    training_data: Dict[str, List[Spectrum1D]] = {}
    
    print(f"Processing {len(channels_conf)} channels...")
    
    for name, ch_data in channels_conf.items():
        print(f"  Channel '{name}':")
        column = ch_data.get('column', 0)
        files = ch_data.get('files', [])
        
        # Create analyzer for this channel
        ch_config = ChannelConfig(
            name=name,
            dt=dt,
            window=window,
            freq_min=ch_data.get('freq_min'),
            freq_max=ch_data.get('freq_max')
        )
        analyzer = SpectralAnalyzer(ch_config)
        
        spectra = []
        for file_path in files:
            try:
                print(f"    Loading {file_path}...", end='', flush=True)
                signal = load_timeseries_csv(file_path, column=column)
                spec = analyzer.analyze(signal)
                spectra.append(spec)
                print(" OK")
            except Exception as e:
                print(f" FAIL: {e}")
        
        if spectra:
            training_data[name] = spectra
        else:
            print(f"    Warning: No valid data for channel '{name}'")

    if not training_data:
        print("Error: No training data collected.")
        return 1
        
    print("Building health profile...")
    profile = build_health_profile(training_data)
    
    print(f"Saving profile to {args.out}...")
    save_health_profile(profile, args.out)
    print("Done.")
    return 0


def score_command(args):
    """Execute scoring command."""
    print(f"Loading profile from {args.profile}...")
    try:
        profile = load_health_profile(args.profile)
    except Exception as e:
        print(f"Error loading profile: {e}")
        return 2

    print(f"Loading config from {args.config}...")
    config = load_config(args.config)
    
    print(f"Loading thresholds from {args.thresholds}...")
    thresholds = load_config(args.thresholds)
    
    dt = config.get('dt')
    window = config.get('window', 'hann')
    channels_conf = config.get('channels', {})
    
    current_spectra: Dict[str, Spectrum1D] = {}
    
    # Process current data (take first file from list or 'current' key)
    for name, ch_data in channels_conf.items():
        if name not in profile.signatures:
            continue
            
        files = ch_data.get('files', [])
        if not files:
            continue
            
        # Use the last file as "current" state
        file_path = files[-1]
        column = ch_data.get('column', 0)
        
        ch_config = ChannelConfig(
            name=name,
            dt=dt,
            window=window,
            freq_min=ch_data.get('freq_min'),
            freq_max=ch_data.get('freq_max')
        )
        analyzer = SpectralAnalyzer(ch_config)
        
        try:
            signal = load_timeseries_csv(file_path, column=column)
            spec = analyzer.analyze(signal)
            current_spectra[name] = spec
        except Exception as e:
            print(f"Error processing channel {name}: {e}")

    if not current_spectra:
        print("Error: No current data to analyze.")
        return 1

    # Calculate scores
    scores = profile.score(current_spectra)
    anomalies = profile.is_anomalous(current_spectra, thresholds)
    
    # Generate report
    print("\n" + "=" * 60)
    print(f"{'Channel':<15} {'Distance':<12} {'Threshold':<12} {'Status':<10}")
    print("-" * 60)
    
    any_anomaly = False
    
    for name in scores:
        dist = scores[name]
        thresh = thresholds.get(name, 0.0)
        is_anom = anomalies.get(name, False)
        status = "ANOMALY" if is_anom else "OK"
        
        if is_anom:
            any_anomaly = True
            
        print(f"{name:<15} {dist:.6f}     {thresh:.6f}     {status:<10}")
        
    print("=" * 60)
    
    if args.report:
        from .report import generate_markdown_report
        print(f"Generating report: {args.report}")
        generate_markdown_report(scores, thresholds, args.report)

    return 1 if any_anomaly else 0


def ndt_train_command(args):
    """Execute NDT training command."""
    print(f"Loading grid config from {args.grid_config}...")
    config = load_config(args.grid_config)
    
    # Extract grid parameters
    nx = config.get('nx', 20)
    ny = config.get('ny', 20)
    kx = config.get('kx', 1.0)
    ky = config.get('ky', 1.0)
    m = config.get('m', 1.0)
    
    print(f"Building OscillatorGrid2D ({nx}x{ny})...")
    grid = OscillatorGrid2D(nx=nx, ny=ny, kx=kx, ky=ky, m=m)
    
    # NDT parameters
    n_modes = config.get('n_modes', 50)
    freq_window = tuple(config.get('freq_window', [0.0, 1.5]))
    n_samples = config.get('n_samples', 1)
    noise_level = config.get('noise_level', 0.0)
    
    print(f"Building NDT profile (modes={n_modes}, window={freq_window})...")
    profile = build_ndt_profile(
        grid=grid,
        n_modes=n_modes,
        freq_window=freq_window,
        n_samples=n_samples,
        noise_level=noise_level
    )
    
    print(f"Saving profile to {args.profile_out}...")
    save_ndt_profile(profile, args.profile_out)
    print("Done.")
    return 0


def ndt_score_command(args):
    """Execute NDT scoring command."""
    print(f"Loading profile from {args.profile}...")
    try:
        profile = load_ndt_profile(args.profile)
    except Exception as e:
        print(f"Error loading profile: {e}")
        return 2
        
    print(f"Loading grid config from {args.grid_config}...")
    config = load_config(args.grid_config)
    
    # Extract grid parameters
    nx = config.get('nx', 20)
    ny = config.get('ny', 20)
    kx = config.get('kx', 1.0)
    ky = config.get('ky', 1.0)
    m = config.get('m', 1.0)
    
    mass_map = None
    
    if args.data:
        print(f"Loading data from {args.data}...")
        try:
            data = np.load(args.data)
            if data.shape == (ny, nx):
                mass_map = data
            else:
                print(f"Data shape {data.shape} does not match grid {ny}x{nx}")
                return 1
        except Exception as e:
            print(f"Error loading data: {e}")
            return 1
            
    # Build grid
    grid = OscillatorGrid2D(
        nx=nx, ny=ny, kx=kx, ky=ky, m=m,
        mass_map=mass_map
    )
    
    # Calculate LDOS
    print("Calculating current LDOS...")
    n_modes = config.get('n_modes', 50)
    ldos_current = grid.ldos_map(n_modes=n_modes, freq_window=profile.freq_window)
    
    # Score
    print("Scoring state...")
    scores = score_ndt_state(profile, ldos_current)
    
    # Threshold
    threshold = config.get('threshold', 3.0)
    mask = ndt_defect_mask(scores, threshold)
    
    n_defects = np.sum(mask)
    print(f"Defects detected: {n_defects} pixels (Threshold={threshold})")
    
    if args.report:
        from .report import generate_ndt_report
        print(f"Generating report: {args.report}")
        generate_ndt_report(
            profile_ldos=profile.ldos_mean,
            current_ldos=ldos_current,
            scores=scores,
            mask=mask,
            out_path=args.report
        )
        
    return 1 if n_defects > 0 else 0


def geo2d_train_command(args):
    """Execute Geo2D training command."""
    print(f"Loading geo config from {args.geo_config}...")
    config = load_config(args.geo_config)
    
    nx = config.get('nx', 30)
    ny = config.get('ny', 30)
    depth_scale = config.get('depth_scale', 1.0)
    
    # Simple homogeneous model for training
    stiffness = config.get('stiffness', 10.0)
    density = config.get('density', 3.0)
    
    stiffness_map = np.full((ny, nx), stiffness)
    density_map = np.full((ny, nx), density)
    
    print(f"Building GeoGrid2D ({nx}x{ny})...")
    geo_grid = GeoGrid2D(
        nx=nx, ny=ny, depth_scale=depth_scale,
        stiffness_map=stiffness_map,
        density_map=density_map
    )
    
    # Calculate surface response (profile)
    freq_window = tuple(config.get('freq_window', [0.0, 2.0]))
    n_modes = config.get('n_modes', 50)
    
    print("Calculating surface response...")
    response = geo_grid.forward_response(freq_window=freq_window, n_modes=n_modes)
    
    print(f"Saving profile to {args.out}...")
    np.savez(args.out, response=response, freq_window=freq_window)
    print("Done.")
    return 0


def geo2d_scan_command(args):
    """Execute Geo2D scan command."""
    print("Geo2D Scan: Not fully implemented yet.")
    print("Use examples/geophysics_2d_toy_demo.py for demonstration.")
    return 0


def main():
    parser = argparse.ArgumentParser(
        description="Spectral Health: Multi-channel diagnostics engine"
    )
    subparsers = parser.add_subparsers(dest='command', required=True)
    
    # Train command
    parser_train = subparsers.add_parser('train', help='Train health profile')
    parser_train.add_argument('--config', required=True, help='Path to config.yaml')
    parser_train.add_argument('--out', required=True, help='Output path for profile.npz')
    parser_train.set_defaults(func=train_command)
    
    # Score command
    parser_score = subparsers.add_parser('score', help='Score current data against profile')
    parser_score.add_argument('--config', required=True, help='Path to config.yaml')
    parser_score.add_argument('--profile', required=True, help='Path to profile.npz')
    parser_score.add_argument('--thresholds', required=True, help='Path to thresholds.yaml')
    parser_score.add_argument('--report', help='Path to output markdown report')
    parser_score.set_defaults(func=score_command)
    
    # NDT Train
    parser_ndt_train = subparsers.add_parser('ndt-train', help='Train NDT profile')
    parser_ndt_train.add_argument('--grid-config', required=True, help='Path to grid config.yaml')
    parser_ndt_train.add_argument('--profile-out', required=True, help='Output path for profile.npz')
    parser_ndt_train.set_defaults(func=ndt_train_command)
    
    # NDT Score
    parser_ndt_score = subparsers.add_parser('ndt-score', help='Score NDT state')
    parser_ndt_score.add_argument('--grid-config', required=True, help='Path to grid config.yaml')
    parser_ndt_score.add_argument('--profile', required=True, help='Path to profile.npz')
    parser_ndt_score.add_argument('--data', help='Path to data.npy (mass map)')
    parser_ndt_score.add_argument('--report', help='Path to output report')
    parser_ndt_score.set_defaults(func=ndt_score_command)

    # Geo2D Train
    parser_geo_train = subparsers.add_parser('geo2d-train', help='Train Geo2D profile')
    parser_geo_train.add_argument('--geo-config', required=True, help='Path to geo config.yaml')
    parser_geo_train.add_argument('--out', required=True, help='Output path for profile.npz')
    parser_geo_train.set_defaults(func=geo2d_train_command)
    
    # Geo2D Scan
    parser_geo_scan = subparsers.add_parser('geo2d-scan', help='Scan Geo2D')
    parser_geo_scan.set_defaults(func=geo2d_scan_command)
    
    args = parser.parse_args()
    sys.exit(args.func(args))


if __name__ == "__main__":
    main()



================================================================================
–§–ê–ô–õ: src\spectral_physics\diagnostics.py
================================================================================

import numpy as np
from dataclasses import dataclass
from .timeseries import timeseries_to_spectrum
from .spectrum import Spectrum1D
from .material import MaterialSignature


@dataclass
class ChannelConfig:
    """
    –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –æ–¥–Ω–æ–≥–æ –∫–∞–Ω–∞–ª–∞ –∏–∑–º–µ—Ä–µ–Ω–∏–π.

    Attributes:
        name: –ò–º—è –∫–∞–Ω–∞–ª–∞ (—Å—Ç—Ä–æ–∫–∞ –¥–ª—è –æ—Ç—á—ë—Ç–æ–≤).
        dt: –®–∞–≥ –ø–æ –≤—Ä–µ–º–µ–Ω–∏ (—Å–µ–∫—É–Ω–¥—ã).
        window: –¢–∏–ø –æ–∫–Ω–∞ –¥–ª—è FFT ("hann" –∏–ª–∏ None).
        freq_min: –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —á–∞—Å—Ç–æ—Ç–∞ –∞–Ω–∞–ª–∏–∑–∞ (–ì—Ü).
        freq_max: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —á–∞—Å—Ç–æ—Ç–∞ –∞–Ω–∞–ª–∏–∑–∞ (–ì—Ü).
    """
    name: str
    dt: float
    window: str = "hann"
    freq_min: float | None = None
    freq_max: float | None = None


@dataclass
class MultiChannelConfig:
    """
    –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã —Å –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ –∫–∞–Ω–∞–ª–∞–º–∏.
    """
    channels: dict[str, ChannelConfig]



class SpectralAnalyzer:
    """
    –ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç: –≤—Ä–µ–º–µ–Ω–Ω–æ–π —Ä—è–¥ -> —Å–ø–µ–∫—Ç—Ä -> –æ–±—Ä–µ–∑–∫–∞ –ø–æ –¥–∏–∞–ø–∞–∑–æ–Ω—É —á–∞—Å—Ç–æ—Ç.
    """

    def __init__(self, config: ChannelConfig):
        """
        Args:
            config: –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∫–∞–Ω–∞–ª–∞.
        """
        self.config = config

    def analyze(self, signal: np.ndarray) -> Spectrum1D:
        """
        –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å —Å–∏–≥–Ω–∞–ª –≤–æ –≤—Ä–µ–º–µ–Ω–∏ –≤ Spectrum1D —Å —É—á—ë—Ç–æ–º:
        - —É–¥–∞–ª–µ–Ω–∏—è DC,
        - –æ–∫–Ω–∞,
        - –≤—ã—Ä–µ–∑–∞–Ω–∏—è –¥–∏–∞–ø–∞–∑–æ–Ω–∞ —á–∞—Å—Ç–æ—Ç [freq_min, freq_max] (–µ—Å–ª–∏ –∑–∞–¥–∞–Ω—ã).

        Args:
            signal: –í—Ä–µ–º–µ–Ω–Ω–æ–π —Ä—è–¥ (1D array).

        Returns:
            Spectrum1D —Ç–æ–ª—å–∫–æ –ø–æ –≤—ã–±—Ä–∞–Ω–Ω–æ–º—É –¥–∏–∞–ø–∞–∑–æ–Ω—É —á–∞—Å—Ç–æ—Ç.
        """
        # –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤ —Å–ø–µ–∫—Ç—Ä
        spectrum = timeseries_to_spectrum(
            signal,
            dt=self.config.dt,
            window=self.config.window
        )
        
        # –ï—Å–ª–∏ –Ω–µ –∑–∞–¥–∞–Ω—ã –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è —á–∞—Å—Ç–æ—Ç, –≤–µ—Ä–Ω—É—Ç—å –≤–µ—Å—å —Å–ø–µ–∫—Ç—Ä
        if self.config.freq_min is None and self.config.freq_max is None:
            return spectrum
        
        # –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å omega –≤ –ì–µ—Ä—Ü—ã
        freq_hz = spectrum.omega / (2 * np.pi)
        
        # –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å –º–∞—Å–∫—É –¥–ª—è –¥–∏–∞–ø–∞–∑–æ–Ω–∞ —á–∞—Å—Ç–æ—Ç
        mask = np.ones(len(freq_hz), dtype=bool)
        
        if self.config.freq_min is not None:
            mask &= (freq_hz >= self.config.freq_min)
        
        if self.config.freq_max is not None:
            mask &= (freq_hz <= self.config.freq_max)
        
        # –í—ã—Ä–µ–∑–∞—Ç—å –¥–∏–∞–ø–∞–∑–æ–Ω
        omega_filtered = spectrum.omega[mask]
        power_filtered = spectrum.power[mask]
        
        return Spectrum1D(omega=omega_filtered, power=power_filtered)


class HealthMonitor:
    """
    –ú–æ–Ω–∏—Ç–æ—Ä "–∑–¥–æ—Ä–æ–≤—å—è" –∫–∞–Ω–∞–ª–∞ –ø–æ —Å–ø–µ–∫—Ç—Ä—É.
    """

    def __init__(self, reference: Spectrum1D, threshold: float):
        """
        Args:
            reference: –≠—Ç–∞–ª–æ–Ω–Ω—ã–π —Å–ø–µ–∫—Ç—Ä "–∑–¥–æ—Ä–æ–≤–æ–≥–æ" —Å–æ—Å—Ç–æ—è–Ω–∏—è.
            threshold: –ü–æ—Ä–æ–≥ –∞–Ω–æ–º–∞–ª—å–Ω–æ—Å—Ç–∏ –ø–æ L2-–¥–∏—Å—Ç–∞–Ω—Ü–∏–∏.
        """
        self.signature = MaterialSignature(reference=reference)
        self.threshold = float(threshold)

    def score(self, current: Spectrum1D) -> float:
        """
        –í–µ—Ä–Ω—É—Ç—å L2-–¥–∏—Å—Ç–∞–Ω—Ü–∏—é –º–µ–∂–¥—É —Ç–µ–∫—É—â–∏–º —Å–ø–µ–∫—Ç—Ä–æ–º –∏ —ç—Ç–∞–ª–æ–Ω–Ω—ã–º.
        
        Args:
            current: –¢–µ–∫—É—â–∏–π —Å–ø–µ–∫—Ç—Ä.
        
        Returns:
            L2-—Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ (—Å–∫–∞–ª—è—Ä).
        """
        return self.signature.distance_l2(current)

    def is_anomalous(self, current: Spectrum1D) -> bool:
        """
        True, –µ—Å–ª–∏ —Ç–µ–∫—É—â–∏–π —Å–ø–µ–∫—Ç—Ä –∞–Ω–æ–º–∞–ª–µ–Ω (distance > threshold).
        
        Args:
            current: –¢–µ–∫—É—â–∏–π —Å–ø–µ–∫—Ç—Ä.
        
        Returns:
            True –µ—Å–ª–∏ –∞–Ω–æ–º–∞–ª–µ–Ω, False –∏–Ω–∞—á–µ.
        """
        return self.signature.is_anomalous(current, self.threshold)


def average_spectrum(spectra: list[Spectrum1D]) -> Spectrum1D:
    """
    –£—Å—Ä–µ–¥–Ω–∏—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–ø–µ–∫—Ç—Ä–æ–≤ —Å –æ–¥–∏–Ω–∞–∫–æ–≤–æ–π —á–∞—Å—Ç–æ—Ç–Ω–æ–π —Å–µ—Ç–∫–æ–π.

    Args:
        spectra: –°–ø–∏—Å–æ–∫ —Å–ø–µ–∫—Ç—Ä–æ–≤.

    Returns:
        –ù–æ–≤—ã–π Spectrum1D —Å —É—Å—Ä–µ–¥–Ω–µ–Ω–Ω–æ–π –º–æ—â–Ω–æ—Å—Ç—å—é.
    
    Raises:
        ValueError: –ï—Å–ª–∏ —Å–ø–∏—Å–æ–∫ –ø—É—Å—Ç –∏–ª–∏ —Å–µ—Ç–∫–∏ —á–∞—Å—Ç–æ—Ç –Ω–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç.
    """
    if not spectra:
        raise ValueError("Cannot average empty list of spectra")
    
    # –ë–µ—Ä–µ–º –ø–µ—Ä–≤—ã–π —Å–ø–µ–∫—Ç—Ä –∫–∞–∫ —ç—Ç–∞–ª–æ–Ω —Å–µ—Ç–∫–∏
    omega_ref = spectra[0].omega
    n_points = len(omega_ref)
    
    sum_power = np.zeros_like(spectra[0].power)
    
    for i, spec in enumerate(spectra):
        if len(spec.omega) != n_points or not np.allclose(spec.omega, omega_ref):
            raise ValueError(
                f"Spectrum at index {i} has different frequency grid"
            )
        sum_power += spec.power
        
    avg_power = sum_power / len(spectra)
    
    return Spectrum1D(omega=omega_ref.copy(), power=avg_power)


def build_health_profile(
    training_data: dict[str, list[Spectrum1D]]
) -> "HealthProfile":
    """
    –ü–æ—Å—Ç—Ä–æ–∏—Ç—å HealthProfile –ø–æ –æ–±—É—á–∞—é—â–∏–º –¥–∞–Ω–Ω—ã–º.

    Args:
        training_data: –°–ª–æ–≤–∞—Ä—å {–∏–º—è_–∫–∞–Ω–∞–ª–∞: —Å–ø–∏—Å–æ–∫_—Å–ø–µ–∫—Ç—Ä–æ–≤}.

    Returns:
        HealthProfile —Å —É—Å—Ä–µ–¥–Ω–µ–Ω–Ω—ã–º–∏ —Å–∏–≥–Ω–∞—Ç—É—Ä–∞–º–∏.
    """
    from .material import HealthProfile, MaterialSignature
    
    signatures = {}
    
    for channel_name, spectra_list in training_data.items():
        if not spectra_list:
            continue
            
        # 1. –£—Å—Ä–µ–¥–Ω—è–µ–º —Å–ø–µ–∫—Ç—Ä—ã
        avg_spec = average_spectrum(spectra_list)
        
        # 2. –°–æ–∑–¥–∞–µ–º —Å–∏–≥–Ω–∞—Ç—É—Ä—É
        signature = MaterialSignature(reference=avg_spec)
        
        # 3. –°–æ—Ö—Ä–∞–Ω—è–µ–º
        signatures[channel_name] = signature
        
    return HealthProfile(signatures=signatures)


def spectral_band_power(
    spectrum: Spectrum1D,
    freq_min: float,
    freq_max: float,
) -> float:
    """
    –≠–Ω–µ—Ä–≥–∏—è —Å–ø–µ–∫—Ç—Ä–∞ –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ [freq_min, freq_max] (–ì—Ü).
    
    Args:
        spectrum: –°–ø–µ–∫—Ç—Ä –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞.
        freq_min: –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —á–∞—Å—Ç–æ—Ç–∞ (–ì—Ü).
        freq_max: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —á–∞—Å—Ç–æ—Ç–∞ (–ì—Ü).
    
    Returns:
        –°—É–º–º–∞—Ä–Ω–∞—è –º–æ—â–Ω–æ—Å—Ç—å –≤ –ø–æ–ª–æ—Å–µ.
    """
    freq_hz = spectrum.omega / (2 * np.pi)
    mask = (freq_hz >= freq_min) & (freq_hz <= freq_max)
    return float(np.sum(spectrum.power[mask]))


def spectral_entropy(spectrum: Spectrum1D) -> float:
    """
    –°–ø–µ–∫—Ç—Ä–∞–ª—å–Ω–∞—è —ç–Ω—Ç—Ä–æ–ø–∏—è: H = - sum(p_i * log(p_i)),
    –≥–¥–µ p_i = –Ω–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –º–æ—â–Ω–æ—Å—Ç—å.
    
    Args:
        spectrum: –°–ø–µ–∫—Ç—Ä –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞.
    
    Returns:
        –ó–Ω–∞—á–µ–Ω–∏–µ —ç–Ω—Ç—Ä–æ–ø–∏–∏.
    """
    total = spectrum.total_power()
    if total == 0:
        return 0.0
    
    # –ù–æ—Ä–º–∏—Ä—É–µ–º –º–æ—â–Ω–æ—Å—Ç—å (–∫–∞–∫ –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å)
    p = spectrum.power / total
    
    # –ò—Å–∫–ª—é—á–∞–µ–º –Ω—É–ª–∏ –¥–ª—è –ª–æ–≥–∞—Ä–∏—Ñ–º–∞
    p = p[p > 0]
    
    return float(-np.sum(p * np.log(p)))


def extract_features(
    spectrum: Spectrum1D,
    bands_hz: list[tuple[float, float]],
) -> np.ndarray:
    """
    –ü–æ—Å—Ç—Ä–æ–∏—Ç—å –≤–µ–∫—Ç–æ—Ä —Ñ–∏—á:
    [ band_power_1, ..., band_power_N, spectral_entropy ]
    
    Args:
        spectrum: –°–ø–µ–∫—Ç—Ä.
        bands_hz: –°–ø–∏—Å–æ–∫ –∫–æ—Ä—Ç–µ–∂–µ–π (min_hz, max_hz).
        
    Returns:
        NumPy –º–∞—Å—Å–∏–≤ —Ñ–∏—á.
    """
    features = []
    for fmin, fmax in bands_hz:
        features.append(spectral_band_power(spectrum, fmin, fmax))
    
    features.append(spectral_entropy(spectrum))
    return np.asarray(features, dtype=float)






================================================================================
–§–ê–ô–õ: src\spectral_physics\geophysics_1d.py
================================================================================

from dataclasses import dataclass
import numpy as np
from .medium_1d import OscillatorChain1D
from .root_finding import symmetric_newton

@dataclass
class Layer:
    thickness: float
    density: float
    stiffness: float

@dataclass
class LayeredMedium1D:
    layers: list[Layer]
    dx: float  # —à–∞–≥ –¥–∏—Å–∫—Ä–µ—Ç–∏–∑–∞—Ü–∏–∏ –ø–æ –≥–ª—É–±–∏–Ω–µ

    def to_oscillator_chain(self) -> OscillatorChain1D:
        """
        –ü–æ—Å—Ç—Ä–æ–∏—Ç—å —Ü–µ–ø–æ—á–∫—É –æ—Å—Ü–∏–ª–ª—è—Ç–æ—Ä–æ–≤, –≥–¥–µ –∫–∞–∂–¥—ã–π —É–∑–µ–ª
        –Ω–∞—Å–ª–µ–¥—É–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Å–ª–æ—è, –≤ –∫–æ—Ç–æ—Ä—ã–π –æ–Ω –ø–æ–ø–∞–¥–∞–µ—Ç.
        """
        total_depth = sum(layer.thickness for layer in self.layers)
        n_nodes = int(np.ceil(total_depth / self.dx))
        
        masses = np.zeros(n_nodes)
        k_springs = np.zeros(n_nodes - 1)
        
        current_depth = 0.0
        
        # –ó–∞–ø–æ–ª–Ω—è–µ–º –º–∞—Å—Å—ã —É–∑–ª–æ–≤
        for i in range(n_nodes):
            depth = i * self.dx
            
            # –ù–∞–π—Ç–∏ —Å–ª–æ–π
            layer_idx = 0
            d_acc = 0.0
            for l_idx, layer in enumerate(self.layers):
                d_acc += layer.thickness
                if depth < d_acc:
                    layer_idx = l_idx
                    break
                # –ï—Å–ª–∏ –≥–ª—É–±–∏–Ω–∞ –±–æ–ª—å—à–µ –ø–æ–ª–Ω–æ–π (–ø–æ—Å–ª–µ–¥–Ω–∏–π —É–∑–µ–ª), –±–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π —Å–ª–æ–π
                layer_idx = len(self.layers) - 1
            
            layer = self.layers[layer_idx]
            
            # –ú–∞—Å—Å–∞ —É–∑–ª–∞ ~ –ø–ª–æ—Ç–Ω–æ—Å—Ç—å * dx (–æ–±—ä–µ–º 1D —ç–ª–µ–º–µ–Ω—Ç–∞)
            masses[i] = layer.density * self.dx
            
        # –ó–∞–ø–æ–ª–Ω—è–µ–º –ø—Ä—É–∂–∏–Ω—ã
        for i in range(n_nodes - 1):
            depth = (i + 0.5) * self.dx
            
            # –ù–∞–π—Ç–∏ —Å–ª–æ–π –¥–ª—è –ø—Ä—É–∂–∏–Ω—ã
            layer_idx = 0
            d_acc = 0.0
            for l_idx, layer in enumerate(self.layers):
                d_acc += layer.thickness
                if depth < d_acc:
                    layer_idx = l_idx
                    break
                layer_idx = len(self.layers) - 1
            
            layer = self.layers[layer_idx]
            
            # –ñ–µ—Å—Ç–∫–æ—Å—Ç—å –ø—Ä—É–∂–∏–Ω—ã ~ stiffness / dx
            k_springs[i] = layer.stiffness / self.dx
            
        return OscillatorChain1D(
            n=n_nodes,
            m=masses,     # –ü–µ—Ä–µ–¥–∞–µ–º –º–∞—Å—Å–∏–≤ –º–∞—Å—Å
            k=k_springs   # –ü–µ—Ä–µ–¥–∞–µ–º –º–∞—Å—Å–∏–≤ –∂–µ—Å—Ç–∫–æ—Å—Ç–µ–π
        )


def simulate_pulse_response(
    medium: LayeredMedium1D,
    t_max: float | None = None,
    dt: float = 0.1,
    n_steps: int | None = None,
) -> tuple[np.ndarray, np.ndarray]:
    """
    –ò–º–∏—Ç–∞—Ü–∏—è –æ—Ç–∫–ª–∏–∫–∞ –Ω–∞ —É–¥–∞—Ä –ø–æ –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏:
    –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç (t, signal) ‚Äî —Å–∏–≥–Ω–∞–ª –Ω–∞ –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏ –≤–æ –≤—Ä–µ–º–µ–Ω–∏.
    """
    chain = medium.to_oscillator_chain()
    
    if n_steps is None:
        if t_max is None:
            raise ValueError("Must provide either t_max or n_steps")
        n_steps = int(np.ceil(t_max / dt))
    
    # t = np.linspace(0, t_max, n_steps) # This was causing issues
    t = np.arange(n_steps) * dt
    
    # –ò–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –≤–æ –≤—Ä–µ–º–µ–Ω–∏
    # M x'' + K x = F
    # F(t) = –∏–º–ø—É–ª—å—Å –≤ t=0 –Ω–∞ —É–∑–ª–µ 0
    
    # –°–æ—Å—Ç–æ—è–Ω–∏–µ: x (—Å–º–µ—â–µ–Ω–∏—è), v (—Å–∫–æ—Ä–æ—Å—Ç–∏)
    x = np.zeros(chain.n)
    v = np.zeros(chain.n)
    
    # –ù–∞—á–∞–ª—å–Ω—ã–π –∏–º–ø—É–ª—å—Å: –º–≥–Ω–æ–≤–µ–Ω–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å —É–∑–ª–∞ 0
    # –ò–º–ø—É–ª—å—Å P -> v[0] = P / m[0]
    # –ü—É—Å—Ç—å P = 1.0
    v[0] = 1.0 / chain.m[0]
    
    surface_signal = np.zeros(n_steps)
    
    # –Ø–≤–Ω–∞—è —Å—Ö–µ–º–∞ –≠–π–ª–µ—Ä–∞-–ö—Ä–æ–º–µ—Ä–∞ (–ø–æ–ª—É–Ω–µ—è–≤–Ω–∞—è) –∏–ª–∏ –í–µ—Ä–ª–µ
    # v(t+dt) = v(t) + a(t)*dt
    # x(t+dt) = x(t) + v(t+dt)*dt
    
    # –î–ª—è —É—Å–∫–æ—Ä–µ–Ω–∏—è –º–æ–∂–Ω–æ —Å–æ–±—Ä–∞—Ç—å K –º–∞—Ç—Ä–∏—Ü—É –æ–¥–∏–Ω —Ä–∞–∑, –Ω–æ –¥–ª—è 1D —Ü–µ–ø–æ—á–∫–∏
    # —Å–∏–ª—ã —Å—á–∏—Ç–∞—é—Ç—Å—è –±—ã—Å—Ç—Ä–æ: F_i = k_i*(x_{i+1}-x_i) - k_{i-1}*(x_i - x_{i-1})
    
    # –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ —Ä–∞—Å–ø–∞—Ä—Å–∏–º k –∏ m –¥–ª—è —Å–∫–æ—Ä–æ—Å—Ç–∏
    k = chain.k
    m_inv = 1.0 / chain.m
    
    # Handle scalar k
    if np.ndim(k) == 0:
        k = np.full(chain.n - 1, float(k))
    
    for step in range(n_steps):
        surface_signal[step] = x[0]
        
        # –†–∞—Å—á–µ—Ç —Å–∏–ª
        # F = -K * x
        # –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ —Å–∏–ª—ã
        forces = np.zeros(chain.n)
        
        # –ü—Ä—É–∂–∏–Ω—ã
        # force on i from i+1: k[i] * (x[i+1] - x[i])
        # force on i+1 from i: -k[i] * (x[i+1] - x[i])
        
        dx_springs = x[1:] - x[:-1] # x[i+1] - x[i]
        f_springs = k * dx_springs
        
        forces[:-1] += f_springs
        forces[1:] -= f_springs
        
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ
        a = forces * m_inv
        v += a * dt
        x += v * dt
        
    return t, surface_signal


def invert_single_layer_thickness(
    target_signal: np.ndarray,
    t: np.ndarray,
    density: float,
    stiffness: float,
    thickness_guess: float,
    fixed_layers_below: list[Layer],
    dx: float = 0.1,
) -> float:
    """
    –ò–≥—Ä—É—à–µ—á–Ω–∞—è –æ–±—Ä–∞—Ç–Ω–∞—è –∑–∞–¥–∞—á–∞:
    –ø–æ–¥–±–∏—Ä–∞–µ–º —Ç–æ–ª—â–∏–Ω—É –ø–µ—Ä–≤–æ–≥–æ —Å–ª–æ—è (—Å –∏–∑–≤–µ—Å—Ç–Ω—ã–º–∏ density/stiffness),
    —á—Ç–æ–±—ã —Å–∏–≥–Ω–∞–ª —Å–æ–≤–ø–∞–ª —Å target.
    
    fixed_layers_below: —Å–ª–æ–∏, –∫–æ—Ç–æ—Ä—ã–µ –∏–¥—É—Ç –ü–û–î –ø–µ—Ä–≤—ã–º —Å–ª–æ–µ–º (–∏–∑–≤–µ—Å—Ç–Ω–∞—è –ø–æ–¥–ª–æ–∂–∫–∞).
    """
    
    dt = t[1] - t[0]
    n_steps = len(target_signal)
    
    def objective(h: float) -> float:
        # –°–æ–±–∏—Ä–∞–µ–º —Å—Ä–µ–¥—É
        layer1 = Layer(thickness=h, density=density, stiffness=stiffness)
        medium = LayeredMedium1D(layers=[layer1] + fixed_layers_below, dx=dx)
        
        # –°–∏–º—É–ª–∏—Ä—É–µ–º
        _, signal = simulate_pulse_response(medium, dt=dt, n_steps=n_steps)
        
        # –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º (L2 norm)
        diff = signal - target_signal
        return float(np.sum(diff**2))

    from scipy.optimize import minimize_scalar
    
    res = minimize_scalar(
        objective, 
        bounds=(0.5 * thickness_guess, 2.0 * thickness_guess), 
        method='bounded'
    )
    
    res = minimize_scalar(
        objective, 
        bounds=(0.5 * thickness_guess, 2.0 * thickness_guess), 
        method='bounded'
    )
    
    return float(res.x)

def build_geo1d_health_profile(signal: np.ndarray) -> "FeatureSignature":
    """
    –ü–æ–¥–ø–∏—Å—å –Ω–æ—Ä–º–∞–ª—å–Ω–æ–≥–æ –æ—Ç–∫–ª–∏–∫–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π —Å–∫–≤–∞–∂–∏–Ω—ã/—É—á–∞—Å—Ç–∫–∞).
    –í–µ–∫—Ç–æ—Ä –ø—Ä–∏–∑–Ω–∞–∫–æ–≤: [energy, max_amplitude, mean_abs, std, zero_crossings]
    """
    from .material import FeatureSignature
    
    # Simple time-domain features
    energy = np.sum(signal**2)
    max_amp = np.max(np.abs(signal))
    mean_abs = np.mean(np.abs(signal))
    std_val = np.std(signal)
    
    # Zero crossings
    zero_crossings = np.sum(np.diff(np.signbit(signal)))
    
    features = np.array([energy, max_amp, mean_abs, std_val, float(zero_crossings)])
    
    return FeatureSignature(reference_features=features)



================================================================================
–§–ê–ô–õ: src\spectral_physics\geophysics_2d.py
================================================================================

import numpy as np
from dataclasses import dataclass
from .medium_2d import OscillatorGrid2D

@dataclass
class GeoGrid2D:
    """
    2D Geophysical Model (Cross-section of Earth).
    
    Wraps OscillatorGrid2D to provide geophysical context:
    - stiffness_map represents shear modulus or bulk modulus.
    - density_map represents rock density.
    - depth_scale (meters per pixel).
    """
    nx: int
    ny: int
    depth_scale: float  # meters per grid unit
    stiffness_map: np.ndarray  # (ny, nx)
    density_map: np.ndarray    # (ny, nx)
    
    def __post_init__(self):
        if self.stiffness_map.shape != (self.ny, self.nx):
            raise ValueError("stiffness_map shape mismatch")
        if self.density_map.shape != (self.ny, self.nx):
            raise ValueError("density_map shape mismatch")
            
    def to_oscillator_grid(self) -> OscillatorGrid2D:
        """
        Convert to OscillatorGrid2D for simulation.
        We assume isotropic stiffness (kx = ky = stiffness).
        Mass = density * volume (assuming unit thickness and dx=dy=depth_scale).
        Actually, in the toy model:
        m ~ density
        k ~ stiffness
        """
        # Create grid with maps
        # We use mean values for base kx, ky, m to satisfy init, 
        # but maps will override.
        
        return OscillatorGrid2D(
            nx=self.nx,
            ny=self.ny,
            kx=1.0, # Placeholder
            ky=1.0, # Placeholder
            m=1.0,  # Placeholder
            mass_map=self.density_map,
            kx_map=self.stiffness_map,
            ky_map=self.stiffness_map
        )

    def forward_response(
        self,
        freq_window: tuple[float, float],
        n_modes: int = 50
    ) -> np.ndarray:
        """
        Calculate surface response (LDOS at top row).
        
        Returns:
            1D array of LDOS values along the surface (x-axis).
        """
        grid = self.to_oscillator_grid()
        
        # Calculate full LDOS map
        ldos_map = grid.ldos_map(n_modes=n_modes, freq_window=freq_window)
        
        # Return only the top row (surface)
        # Assuming y=0 is bottom and y=ny-1 is top? 
        # In imshow origin='lower', index 0 is bottom.
        # Let's assume index -1 (last row) is surface.
        return ldos_map[-1, :]


def invert_stiffness(
    surface_ldos: np.ndarray,
    prior_model: GeoGrid2D,
    iterations: int = 10
) -> np.ndarray:
    """
    Toy inversion: try to adjust stiffness map to match surface LDOS.
    
    This is a placeholder for a real inversion. 
    Real inversion would require gradients.
    
    Here we just return a 'reconstructed' map that is a smoothed version 
    of the prior, maybe slightly adjusted by surface residuals?
    
    For the demo, we might just return the prior's stiffness map 
    or a simple modification to show "we tried".
    """
    # Placeholder logic
    reconstructed = prior_model.stiffness_map.copy()
    
    # In a real scenario, we would iterate:
    # 1. Forward(model) -> predicted_surface
    # 2. Diff = predicted - observed
    # 3. Update model to minimize Diff
    
    return reconstructed



================================================================================
–§–ê–ô–õ: src\spectral_physics\grav_toy.py
================================================================================

import numpy as np
from .spectrum import Spectrum1D


def spectral_pressure_difference(
    spectrum_bg: Spectrum1D,
    alpha_left: np.ndarray,
    alpha_right: np.ndarray,
) -> float:
    """
    Estimate pressure difference of background field on left and right sides.
    
    This is a toy model of "spectral shadow" and attractive force.
    The idea is that matter with different spectral transparency creates
    an imbalance in the background spectrum, leading to a net force.
    
    Args:
        spectrum_bg: Background spectrum (omega, power).
        alpha_left: Spectral transparency on the left side (same shape as power).
        alpha_right: Spectral transparency on the right side (same shape as power).
    
    Returns:
        Pressure difference: ŒîP = Œ£ power(œâ) * (alpha_right(œâ) - alpha_left(œâ))
        
        Positive ŒîP means net force pushes to the right.
        Negative ŒîP means net force pushes to the left.
    
    Raises:
        ValueError: If alpha arrays have incompatible shapes.
    
    Example:
        If left side has lower transparency (blocks more), then more
        background radiation reaches from the right, creating a net
        force pushing the object leftward (toward the shadow).
    """
    alpha_left = np.asarray(alpha_left, dtype=float)
    alpha_right = np.asarray(alpha_right, dtype=float)
    
    # Validate shapes
    if alpha_left.shape != spectrum_bg.power.shape:
        raise ValueError(
            f"alpha_left shape {alpha_left.shape} doesn't match "
            f"spectrum power shape {spectrum_bg.power.shape}"
        )
    
    if alpha_right.shape != spectrum_bg.power.shape:
        raise ValueError(
            f"alpha_right shape {alpha_right.shape} doesn't match "
            f"spectrum power shape {spectrum_bg.power.shape}"
        )
    
    # Compute pressure difference
    # ŒîP = Œ£ P(œâ) * [Œ±_right(œâ) - Œ±_left(œâ)]
    delta_alpha = alpha_right - alpha_left
    delta_p = np.sum(spectrum_bg.power * delta_alpha)
    
    return float(delta_p)



================================================================================
–§–ê–ô–õ: src\spectral_physics\io.py
================================================================================

import numpy as np
from pathlib import Path
from .spectrum import Spectrum1D


def load_timeseries_csv(
    path: str,
    column: int = 0,
    skip_header: bool = True
) -> np.ndarray:
    """
    –ó–∞–≥—Ä—É–∑–∏—Ç—å –æ–¥–Ω–æ–º–µ—Ä–Ω—ã–π –≤—Ä–µ–º–µ–Ω–Ω–æ–π —Ä—è–¥ –∏–∑ CSV.

    –ü–∞—Ä–∞–º–µ—Ç—Ä—ã:
        path: –ü—É—Ç—å –∫ —Ñ–∞–π–ª—É CSV.
        column: –ò–Ω–¥–µ–∫—Å –∫–æ–ª–æ–Ω–∫–∏ (0-based), –≥–¥–µ –ª–µ–∂–∏—Ç —Å–∏–≥–Ω–∞–ª.
        skip_header: –ï—Å–ª–∏ True, –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å –ø–µ—Ä–≤—É—é —Å—Ç—Ä–æ–∫—É (–∑–∞–≥–æ–ª–æ–≤–æ–∫).

    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç:
        1D np.ndarray —Å –¥–∞–Ω–Ω—ã–º–∏ —Å–∏–≥–Ω–∞–ª–∞.
    
    Raises:
        ValueError: –ï—Å–ª–∏ —Ñ–∞–π–ª –ø—É—Å—Ç–æ–π, –∫–æ–ª–æ–Ω–∫–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∏–ª–∏ —Ñ–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω.
    """
    path_obj = Path(path)
    
    if not path_obj.exists():
        raise ValueError(f"File not found: {path}")
    
    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —á–∏—Å–ª–æ —Å—Ç—Ä–æ–∫ –¥–ª—è –ø—Ä–æ–ø—É—Å–∫–∞
    skiprows = 1 if skip_header else 0
    
    try:
        # –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ
        data = np.loadtxt(path, delimiter=',', skiprows=skiprows, ndmin=2)
    except Exception as e:
        raise ValueError(f"Failed to load CSV file {path}: {e}")
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø—É—Å—Ç–æ–π —Ñ–∞–π–ª
    if data.size == 0:
        raise ValueError(f"File {path} is empty")
    
    # –ï—Å–ª–∏ –¥–∞–Ω–Ω—ã–µ –æ–¥–Ω–æ–º–µ—Ä–Ω—ã–µ, —Å–¥–µ–ª–∞—Ç—å –¥–≤—É–º–µ—Ä–Ω—ã–º–∏
    if data.ndim == 1:
        data = data.reshape(-1, 1)
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç–∏ –∏–Ω–¥–µ–∫—Å–∞ –∫–æ–ª–æ–Ω–∫–∏
    if column >= data.shape[1] or column < 0:
        raise ValueError(
            f"Column index {column} is out of range. "
            f"File has {data.shape[1]} columns (indices 0..{data.shape[1]-1})"
        )
    
    # –ò–∑–≤–ª–µ—á—å –Ω—É–∂–Ω—É—é –∫–æ–ª–æ–Ω–∫—É
    signal = data[:, column]
    
    return signal


def save_spectrum_npz(spectrum: Spectrum1D, path: str) -> None:
    """
    –°–æ—Ö—Ä–∞–Ω–∏—Ç—å Spectrum1D –≤ .npz (omega, power).
    
    Args:
        spectrum: –°–ø–µ–∫—Ç—Ä –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è.
        path: –ü—É—Ç—å –∫ —Ñ–∞–π–ª—É .npz.
    """
    np.savez(path, omega=spectrum.omega, power=spectrum.power)


def load_spectrum_npz(path: str) -> Spectrum1D:
    """
    –ó–∞–≥—Ä—É–∑–∏—Ç—å Spectrum1D –∏–∑ .npz.
    –û–∂–∏–¥–∞–µ—Ç –º–∞—Å—Å–∏–≤—ã 'omega' –∏ 'power'.
    
    Args:
        path: –ü—É—Ç—å –∫ —Ñ–∞–π–ª—É .npz.
    
    Returns:
        –ó–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–π Spectrum1D.
    
    Raises:
        ValueError: –ï—Å–ª–∏ —Ñ–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –æ–∂–∏–¥–∞–µ–º—ã–µ –∫–ª—é—á–∏.
    """
    path_obj = Path(path)
    
    if not path_obj.exists():
        raise ValueError(f"File not found: {path}")
    
    try:
        data = np.load(path)
    except Exception as e:
        raise ValueError(f"Failed to load .npz file {path}: {e}")
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö –∫–ª—é—á–µ–π
    if 'omega' not in data or 'power' not in data:
        raise ValueError(
            f"File {path} missing required keys. "
            f"Expected 'omega' and 'power', found: {list(data.keys())}"
        )
    
    omega = data['omega']
    power = data['power']
    
    return Spectrum1D(omega=omega, power=power)


def save_health_profile(profile: "HealthProfile", path: str) -> None:
    """
    –°–æ—Ö—Ä–∞–Ω–∏—Ç—å HealthProfile –≤ .npz.
    
    Args:
        profile: –ü—Ä–æ—Ñ–∏–ª—å –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è.
        path: –ü—É—Ç—å –∫ —Ñ–∞–π–ª—É .npz.
    """
    data = {}
    channel_names = []
    
    for name, signature in profile.signatures.items():
        channel_names.append(name)
        data[f"{name}_omega"] = signature.reference.omega
        data[f"{name}_power"] = signature.reference.power
        
    np.savez(path, channels=channel_names, **data)


def load_health_profile(path: str) -> "HealthProfile":
    """
    –ó–∞–≥—Ä—É–∑–∏—Ç—å HealthProfile –∏–∑ .npz.
    
    Args:
        path: –ü—É—Ç—å –∫ —Ñ–∞–π–ª—É .npz.
    
    Returns:
        –ó–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–π HealthProfile.
    """
    from .material import HealthProfile, MaterialSignature
    
    path_obj = Path(path)
    if not path_obj.exists():
        raise ValueError(f"File not found: {path}")
        
    try:
        data = np.load(path)
    except Exception as e:
        raise ValueError(f"Failed to load .npz file {path}: {e}")
        
    if 'channels' not in data:
        raise ValueError(f"File {path} is not a valid HealthProfile (missing 'channels')")
        
    signatures = {}
    for name in data['channels']:
        omega_key = f"{name}_omega"
        power_key = f"{name}_power"
        
        if omega_key not in data or power_key not in data:
            raise ValueError(f"Missing data for channel {name}")
            
        spec = Spectrum1D(omega=data[omega_key], power=data[power_key])
        signatures[str(name)] = MaterialSignature(reference=spec)
        
    return HealthProfile(signatures=signatures)


def save_ndt_profile(profile, path: str) -> None:
    """
    Save NDTProfile to .npz.
    
    Args:
        profile: NDTProfile instance.
        path: Path to .npz file.
    """
    np.savez(
        path,
        freq_window=np.array(profile.freq_window),
        ldos_mean=profile.ldos_mean,
        ldos_std=profile.ldos_std
    )


def load_ndt_profile(path: str):
    """
    Load NDTProfile from .npz.
    
    Args:
        path: Path to .npz file.
        
    Returns:
        NDTProfile instance.
    """
    from .ndt import NDTProfile
    
    path_obj = Path(path)
    if not path_obj.exists():
        raise ValueError(f"File not found: {path}")
        
    try:
        data = np.load(path)
    except Exception as e:
        raise ValueError(f"Failed to load .npz file {path}: {e}")
        
    if 'freq_window' not in data or 'ldos_mean' not in data:
        raise ValueError(f"File {path} is not a valid NDTProfile")
        
    return NDTProfile(
        freq_window=tuple(data['freq_window']),
        ldos_mean=data['ldos_mean'],
        ldos_std=data['ldos_std']
    )





================================================================================
–§–ê–ô–õ: src\spectral_physics\ldos.py
================================================================================

import numpy as np

def ldos_from_modes(
    modes: np.ndarray,
    omegas: np.ndarray,
    freq_window: tuple[float, float],
) -> np.ndarray:
    """
    –û—Ü–µ–Ω–∫–∞ –ª–æ–∫–∞–ª—å–Ω–æ–π —Å–ø–µ–∫—Ç—Ä–∞–ª—å–Ω–æ–π –ø–ª–æ—Ç–Ω–æ—Å—Ç–∏ (LDOS) –Ω–∞ —Ä–µ—à—ë—Ç–∫–µ 2D.

    –ü–∞—Ä–∞–º–µ—Ç—Ä—ã:
        modes: –º–∞—Å—Å–∏–≤ —Ñ–æ—Ä–º—ã (N_points, N_modes),
               –∫–∞–∫ –≤–µ—Ä–Ω—É–ª OscillatorGrid2D.eigenmodes()
        omegas: –º–∞—Å—Å–∏–≤ (N_modes,) ‚Äî —á–∞—Å—Ç–æ—Ç—ã –º–æ–¥
        freq_window: (omega_min, omega_max) ‚Äî —á–∞—Å—Ç–æ—Ç–Ω–æ–µ –æ–∫–Ω–æ

    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç:
        ldos: –º–∞—Å—Å–∏–≤ (N_points,) ‚Äî "—Å–∏–ª–∞" –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Å–ø–µ–∫—Ç—Ä–∞
              –≤ –∑–∞–¥–∞–Ω–Ω–æ–º –æ–∫–Ω–µ —á–∞—Å—Ç–æ—Ç.
    –ò–¥–µ—è:
        —Å—É–º–º–∏—Ä–æ–≤–∞—Ç—å |mode_i|^2 –ø–æ —Ç–µ–º –º–æ–¥–∞–º, —É –∫–æ—Ç–æ—Ä—ã—Ö
        omega_i –ø–æ–ø–∞–¥–∞–µ—Ç –≤ –æ–∫–Ω–æ.
    """
    w_min, w_max = freq_window
    
    # –ú–∞—Å–∫–∞ —á–∞—Å—Ç–æ—Ç, –ø–æ–ø–∞–¥–∞—é—â–∏—Ö –≤ –æ–∫–Ω–æ
    mask = (omegas >= w_min) & (omegas <= w_max)
    
    if not np.any(mask):
        return np.zeros(modes.shape[0])
        
    # –í—ã–±–∏—Ä–∞–µ–º –Ω—É–∂–Ω—ã–µ –º–æ–¥—ã: (N_points, K_selected)
    selected_modes = modes[:, mask]
    
    # –°—É–º–º–∏—Ä—É–µ–º –∫–≤–∞–¥—Ä–∞—Ç—ã –∞–º–ø–ª–∏—Ç—É–¥ –ø–æ –º–æ–¥–∞–º (–≤–¥–æ–ª—å –æ—Å–∏ 1)
    # LDOS(x) = sum_i |psi_i(x)|^2
    ldos = np.sum(selected_modes**2, axis=1)
    
    return ldos



================================================================================
–§–ê–ô–õ: src\spectral_physics\material.py
================================================================================

import numpy as np
from dataclasses import dataclass
from .spectrum import Spectrum1D


@dataclass
class MaterialSignature:
    """
    –°–ø–µ–∫—Ç—Ä–∞–ª—å–Ω–∞—è –ø–æ–¥–ø–∏—Å—å –º–∞—Ç–µ—Ä–∏–∞–ª–∞/—É–∑–ª–∞.
    
    –°–æ–¥–µ—Ä–∂–∏—Ç:
    - –æ–ø–æ—Ä–Ω—ã–π —Å–ø–µ–∫—Ç—Ä (reference) –≤ –Ω–æ—Ä–º–∞–ª—å–Ω–æ–º —Å–æ—Å—Ç–æ—è–Ω–∏–∏,
    - –ø—Ä–æ—Å—Ç—É—é –º–µ—Ç—Ä–∏–∫—É "—Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è" –¥–æ –Ω–æ–≤–æ–≥–æ —Å–ø–µ–∫—Ç—Ä–∞.
    
    –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –¥–µ—Ç–µ–∫—Ü–∏–∏ –¥–µ—Ñ–µ–∫—Ç–æ–≤/–∞–Ω–æ–º–∞–ª–∏–π –ø–æ –∏–∑–º–µ–Ω–µ–Ω–∏—é
    —Å–ø–µ–∫—Ç—Ä–∞–ª—å–Ω—ã—Ö —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫.
    """
    reference: Spectrum1D
    
    def distance_l2(self, other: Spectrum1D) -> float:
        """
        L2-–Ω–æ—Ä–º–∞ –º–µ–∂–¥—É –Ω–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ —Å–ø–µ–∫—Ç—Ä–∞–º–∏.
        
        Args:
            other: –°–ø–µ–∫—Ç—Ä –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è —Å reference.
        
        Returns:
            L2-—Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É –Ω–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ —Å–ø–µ–∫—Ç—Ä–∞–º–∏.
        
        Raises:
            ValueError: –ï—Å–ª–∏ —Å–µ—Ç–∫–∏ –ø–æ —á–∞—Å—Ç–æ—Ç–µ –Ω–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç.
        
        Notes:
            –°–ø–µ–∫—Ç—Ä—ã –Ω–æ—Ä–º–∏—Ä—É—é—Ç—Å—è –ø–µ—Ä–µ–¥ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ–º, —á—Ç–æ–±—ã —Ä–∞–∑–ª–∏—á–∏—è
            –≤ –∞–º–ø–ª–∏—Ç—É–¥–µ –Ω–µ –≤–ª–∏—è–ª–∏ –Ω–∞ –¥–µ—Ç–µ–∫—Ü–∏—é –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ñ–æ—Ä–º—ã —Å–ø–µ–∫—Ç—Ä–∞.
        """
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è —á–∞—Å—Ç–æ—Ç–Ω—ã—Ö —Å–µ—Ç–æ–∫
        if not np.array_equal(self.reference.omega, other.omega):
            raise ValueError(
                "Frequency grids do not match. "
                f"Reference has {len(self.reference.omega)} points, "
                f"other has {len(other.omega)} points. "
                "Cannot compute distance."
            )
        
        # –ù–æ—Ä–º–∏—Ä—É–µ–º –æ–±–∞ —Å–ø–µ–∫—Ç—Ä–∞
        ref_normalized = self.reference.normalize()
        other_normalized = other.normalize()
        
        # –í—ã—á–∏—Å–ª—è–µ–º L2-—Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ
        diff = ref_normalized.power - other_normalized.power
        distance = np.sqrt(np.sum(diff ** 2))
        
        return float(distance)
    
    def distance_cosine(self, other: Spectrum1D) -> float:
        """
        –ö–æ—Å–∏–Ω—É—Å–Ω–∞—è "–¥–∏—Å—Ç–∞–Ω—Ü–∏—è" –º–µ–∂–¥—É –Ω–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ —Å–ø–µ–∫—Ç—Ä–∞–º–∏:
            1 - (‚ü®a,b‚ü© / (||a|| * ||b||))
        
        Args:
            other: –°–ø–µ–∫—Ç—Ä –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è.
        
        Returns:
            –ö–æ—Å–∏–Ω—É—Å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ (0..1 –¥–ª—è –Ω–µ–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã—Ö —Å–ø–µ–∫—Ç—Ä–æ–≤).
        """
        if not np.array_equal(self.reference.omega, other.omega):
            raise ValueError("Frequency grids do not match")
        
        # –†–∞–±–æ—Ç–∞–µ–º —Å –≤–µ–∫—Ç–æ—Ä–∞–º–∏ –º–æ—â–Ω–æ—Å—Ç–∏
        a = self.reference.power
        b = other.power
        
        norm_a = np.linalg.norm(a)
        norm_b = np.linalg.norm(b)
        
        if norm_a == 0 or norm_b == 0:
            # –ï—Å–ª–∏ –æ–¥–∏–Ω –∏–∑ –≤–µ–∫—Ç–æ—Ä–æ–≤ –Ω—É–ª–µ–≤–æ–π, —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –Ω–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ (–∏–ª–∏ –º–∞–∫—Å)
            return 1.0
            
        cosine_similarity = np.dot(a, b) / (norm_a * norm_b)
        
        # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º [0, 1] –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏
        cosine_similarity = np.clip(cosine_similarity, 0.0, 1.0)
        
        return 1.0 - cosine_similarity

    def is_anomalous(self, other: Spectrum1D, threshold: float) -> bool:

        """
        –í–µ—Ä–Ω—É—Ç—å True, –µ—Å–ª–∏ distance_l2(other) > threshold.
        
        Args:
            other: –°–ø–µ–∫—Ç—Ä –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏.
            threshold: –ü–æ—Ä–æ–≥ –∞–Ω–æ–º–∞–ª—å–Ω–æ—Å—Ç–∏.
        
        Returns:
            True –µ—Å–ª–∏ —Å–ø–µ–∫—Ç—Ä –∞–Ω–æ–º–∞–ª–µ–Ω, False –∏–Ω–∞—á–µ.
        
        Raises:
            ValueError: –ï—Å–ª–∏ —Å–µ—Ç–∫–∏ –ø–æ —á–∞—Å—Ç–æ—Ç–µ –Ω–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç.
        
        Example:
            >>> sig = MaterialSignature(reference=normal_spectrum)
            >>> if sig.is_anomalous(test_spectrum, threshold=0.1):
            ...     print("–û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ –∞–Ω–æ–º–∞–ª–∏—è!")
        """
        distance = self.distance_l2(other)
        return distance > threshold


@dataclass
class FeatureSignature:
    """
    –°–ø–µ–∫—Ç—Ä–∞–ª—å–Ω–∞—è —Å–∏–≥–Ω–∞—Ç—É—Ä–∞ –Ω–∞ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ —Ñ–∏—á.
    """
    reference_features: np.ndarray

    def distance_l2(self, other_features: np.ndarray) -> float:
        if other_features.shape != self.reference_features.shape:
            raise ValueError("Feature vector shape mismatch")
        diff = self.reference_features - other_features
        return float(np.sqrt(np.sum(diff**2)))


@dataclass
class HealthProfile:
    """
    –≠—Ç–∞–ª–æ–Ω–Ω—ã–π –ø—Ä–æ—Ñ–∏–ª—å "–∑–¥–æ—Ä–æ–≤–æ–≥–æ" —Å–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –∫–∞–Ω–∞–ª–æ–≤.
    """
    signatures: dict[str, MaterialSignature]  # –∏–º—è –∫–∞–Ω–∞–ª–∞ -> –ø–æ–¥–ø–∏—Å—å
    feature_signatures: dict[str, FeatureSignature] | None = None

    def score(self, current: dict[str, Spectrum1D]) -> dict[str, float]:
        """
        –í–µ—Ä–Ω—É—Ç—å —Å–ª–æ–≤–∞—Ä—å name -> distance_l2 –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–∞–Ω–∞–ª–∞.
        –ö–∞–Ω–∞–ª –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É–µ—Ç –≤ signatures –∏ –≤ current.
        """
        scores = {}
        for name, signature in self.signatures.items():
            if name in current:
                scores[name] = signature.distance_l2(current[name])
        return scores

    def score_features(
        self,
        current: dict[str, Spectrum1D],
        bands_hz: dict[str, list[tuple[float, float]]],
    ) -> dict[str, float]:
        """
        –î–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–∞–Ω–∞–ª–∞:
        - –∏–∑–≤–ª–µ—á—å —Ñ–∏—á–∏,
        - –ø–æ—Å—á–∏—Ç–∞—Ç—å L2-–¥–∏—Å—Ç–∞–Ω—Ü–∏—é –≤ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ —Ñ–∏—á.
        """
        from .diagnostics import extract_features
        
        if self.feature_signatures is None:
            return {}
            
        scores = {}
        for name, feat_sig in self.feature_signatures.items():
            if name in current and name in bands_hz:
                spec = current[name]
                bands = bands_hz[name]
                feats = extract_features(spec, bands)
                scores[name] = feat_sig.distance_l2(feats)
        return scores

    def is_anomalous(
        self,
        current: dict[str, Spectrum1D],
        thresholds: dict[str, float],
    ) -> dict[str, bool]:
        """
        –í–µ—Ä–Ω—É—Ç—å —Å–ª–æ–≤–∞—Ä—å name -> bool (–∞–Ω–æ–º–∞–ª–µ–Ω / –Ω–µ—Ç)
        –ø–æ –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã–º –ø–æ—Ä–æ–≥–∞–º –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–∞–Ω–∞–ª–∞.
        """
        results = {}
        for name, signature in self.signatures.items():
            if name in current and name in thresholds:
                results[name] = signature.is_anomalous(current[name], thresholds[name])
        return results





================================================================================
–§–ê–ô–õ: src\spectral_physics\materials.py
================================================================================

from dataclasses import dataclass
import numpy as np
from .atoms import AtomicResonator
from .spectrum import Spectrum1D

@dataclass
class MaterialPatch:
    """
    –£—á–∞—Å—Ç–æ–∫ –º–∞—Ç–µ—Ä–∏–∞–ª–∞ –∫–∞–∫ "–∞—Ç–æ–º–Ω–∞—è —Å–º–µ—Å—å" –ø–ª—é—Å —Å—Ä–µ–¥–∞.
    """
    atoms: list[AtomicResonator]
    weights: np.ndarray  # –¥–æ–ª–∏ –∫–∞–∂–¥–æ–≥–æ –∞—Ç–æ–º–∞ (—Å—É–º–º–∞ = 1)

    def surface_spectrum(self) -> Spectrum1D:
        """
        –°—É–º–º–∞—Ä–Ω—ã–π —Å–ø–µ–∫—Ç—Ä –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏:
        –≤–∑–≤–µ—à–µ–Ω–Ω–∞—è —Å—É–º–º–∞ —Å–ø–µ–∫—Ç—Ä–æ–≤ –∞—Ç–æ–º–æ–≤.
        """
        if not self.atoms:
            return Spectrum1D(omega=np.array([]), power=np.array([]))
            
        # –î–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã –æ–±—ä–µ–¥–∏–Ω–∏–º –≤—Å–µ —á–∞—Å—Ç–æ—Ç—ã –∏ –ø—Ä–æ—Å—É–º–º–∏—Ä—É–µ–º –º–æ—â–Ω–æ—Å—Ç–∏
        # (–ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º –¥–∏—Å–∫—Ä–µ—Ç–Ω—ã–µ –ª–∏–Ω–∏–∏)
        
        all_freqs = []
        all_powers = []
        
        for atom, w in zip(self.atoms, self.weights):
            spec = atom.spectrum()
            all_freqs.extend(spec.omega)
            all_powers.extend(spec.power * w)
            
        all_freqs = np.array(all_freqs)
        all_powers = np.array(all_powers)
        
        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —á–∞—Å—Ç–æ—Ç–µ
        idx = np.argsort(all_freqs)
        sorted_freqs = all_freqs[idx]
        sorted_powers = all_powers[idx]
        
        # –ú–æ–∂–Ω–æ –æ–±—ä–µ–¥–∏–Ω–∏—Ç—å —Å–æ–≤–ø–∞–¥–∞—é—â–∏–µ —á–∞—Å—Ç–æ—Ç—ã, –Ω–æ Spectrum1D —ç—Ç–æ–≥–æ –Ω–µ —Ç—Ä–µ–±—É–µ—Ç
        return Spectrum1D(omega=sorted_freqs, power=sorted_powers)


def effective_coupling(
    ldos: np.ndarray,
    patch: MaterialPatch,
    freq_window: tuple[float, float],
) -> float:
    """
    –û—Ü–µ–Ω–∫–∞ —Ç–æ–≥–æ, –Ω–∞—Å–∫–æ–ª—å–∫–æ –¥–∞–Ω–Ω—ã–π —É—á–∞—Å—Ç–æ–∫ –º–∞—Ç–µ—Ä–∏–∞–ª–∞ "–∑–≤—É—á–∏—Ç"
    –≤ –¥–∞–Ω–Ω–æ–º —á–∞—Å—Ç–æ—Ç–Ω–æ–º –æ–∫–Ω–µ –°—Ä–µ–¥—ã.

    –ò–¥–µ—è:
      - –∏–∑ patch.surface_spectrum() –≤–∑—è—Ç—å Spectrum1D
      - –æ–≥—Ä–∞–Ω–∏—á–∏—Ç—å –µ–≥–æ freq_window
      - —É–º–Ω–æ–∂–∏—Ç—å –∏–Ω—Ç–µ–≥—Ä–∞–ª—å–Ω—É—é –º–æ—â–Ω–æ—Å—Ç—å –Ω–∞ —Å—Ä–µ–¥–Ω–∏–π —É—Ä–æ–≤–µ–Ω—å LDOS
        (–Ω–∞–ø—Ä–∏–º–µ—Ä, <ldos> –ø–æ –æ–±–ª–∞—Å—Ç–∏ –∏–Ω—Ç–µ—Ä–µ—Å–∞)
    
    Args:
        ldos: –º–∞—Å—Å–∏–≤ LDOS –∑–Ω–∞—á–µ–Ω–∏–π (–Ω–∞–ø—Ä–∏–º–µ—Ä, –∫–∞—Ä—Ç–∞ –∏–ª–∏ —Å—Ä–µ–∑).
        patch: MaterialPatch.
        freq_window: (w_min, w_max).
    """
    spec = patch.surface_spectrum()
    
    # –§–∏–ª—å—Ç—Ä—É–µ–º —Å–ø–µ–∫—Ç—Ä –ø–∞—Ç—á–∞ –ø–æ –æ–∫–Ω—É
    w_min, w_max = freq_window
    mask = (spec.omega >= w_min) & (spec.omega <= w_max)
    
    if not np.any(mask):
        return 0.0
        
    patch_power = np.sum(spec.power[mask])
    
    # –°—Ä–µ–¥–Ω–∏–π LDOS
    avg_ldos = np.mean(ldos)
    
    return float(patch_power * avg_ldos)

def build_material_health_profile(ldos_map: np.ndarray) -> "FeatureSignature":
    """
    –°—Ç—Ä–æ–∏–º "–∑–¥–æ—Ä–æ–≤—ã–π" –ø—Ä–æ—Ñ–∏–ª—å –¥–ª—è –º–∞—Ç–µ—Ä–∏–∞–ª–∞:
    - flatten ldos_map
    - –∏–∑–≤–ª–µ–∫–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ (mean, std, PCA –∏ —Ç.–¥. ‚Äî —Å–º. spectral-health)
    - –ø–æ–ª—É—á–∞–µ–º –∫–æ–º–ø–∞–∫—Ç–Ω—ã–π –≤–µ–∫—Ç–æ—Ä health-–ø–æ–¥–ø–∏—Å–∏.
    
    –î–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã: –≤–µ–∫—Ç–æ—Ä = [mean, std, max, min, median]
    """
    from .material import FeatureSignature
    
    flat = ldos_map.flatten()
    features = np.array([
        np.mean(flat),
        np.std(flat),
        np.max(flat),
        np.min(flat),
        np.median(flat)
    ])
    
    return FeatureSignature(reference_features=features)


@dataclass
class MoleculeGraph:
    """
    Graph representation of a molecule.
    Nodes are AtomicResonators, Edges are bonds.
    """
    atoms: list[AtomicResonator]
    bonds: list[tuple[int, int, str]] # (atom_idx1, atom_idx2, bond_type)
    
    def combined_valence_spectrum(self) -> Spectrum1D:
        """
        Compute the spectrum of the molecule based on its atoms and bonds.
        Simple model: sum of atomic spectra, perhaps modified by bonds.
        """
        all_freqs = []
        all_powers = []
        
        # Base atomic spectra
        for atom in self.atoms:
            spec = atom.spectrum()
            all_freqs.extend(spec.omega)
            all_powers.extend(spec.power)
            
        # Bond effects (toy model):
        # Bonds might shift frequencies or add new modes.
        # Here we just add a "bond mode" for each bond
        for idx1, idx2, btype in self.bonds:
            # Bond frequency depends on bond type
            if btype == 'single':
                freq = 1.0
            elif btype == 'double':
                freq = 1.5
            else:
                freq = 0.5
                
            all_freqs.append(freq)
            all_powers.append(0.5) # Arbitrary bond strength
            
        return Spectrum1D(
            omega=np.array(all_freqs),
            power=np.array(all_powers)
        )

@dataclass
class CandidateMaterial:
    name: str
    confidence: float
    predicted_properties: dict

def infer_material_from_ldos(
    ldos_map: np.ndarray,
    atom_db: dict[str, AtomicResonator]
) -> list[CandidateMaterial]:
    """
    Infer potential material composition from LDOS map features.
    
    This is a 'toy' inference engine.
    Real logic would involve matching spectral peaks to atomic/molecular signatures.
    """
    # Extract features from LDOS
    mean_val = np.mean(ldos_map)
    std_val = np.std(ldos_map)
    
    candidates = []
    
    # Toy logic:
    # High mean -> Light atoms (H, C) - higher activity?
    # Low mean -> Heavy atoms (Fe) - lower activity?
    
    # Check against known "materials" (hardcoded for demo)
    
    # 1. "Steel" (Iron-based)
    # Expect low mean (heavy), specific variance
    score_steel = 0.0
    if mean_val < 0.05:
        score_steel += 0.8
    elif mean_val < 0.1:
        score_steel += 0.4
        
    candidates.append(CandidateMaterial(
        name="Steel (Fe-C)",
        confidence=score_steel,
        predicted_properties={"density": "high", "stiffness": "high"}
    ))
    
    # 2. "Water" (H2O)
    # Expect high mean (light atoms), high variance
    score_water = 0.0
    if mean_val > 0.1:
        score_water += 0.7
    if std_val > 0.02:
        score_water += 0.2
        
    candidates.append(CandidateMaterial(
        name="Water (H2O)",
        confidence=score_water,
        predicted_properties={"density": "low", "stiffness": "low"}
    ))
    
    # 3. "Concrete" (Si-O based)
    # Medium mean
    score_concrete = 0.0
    if 0.05 <= mean_val <= 0.15:
        score_concrete += 0.6
        
    candidates.append(CandidateMaterial(
        name="Concrete (Si-O)",
        confidence=score_concrete,
        predicted_properties={"density": "medium", "stiffness": "high"}
    ))
    
    # Sort by confidence
    candidates.sort(key=lambda x: x.confidence, reverse=True)
    
    return candidates




================================================================================
–§–ê–ô–õ: src\spectral_physics\medium_1d.py
================================================================================

import numpy as np
import scipy.linalg
from dataclasses import dataclass


@dataclass
class OscillatorChain1D:
    """
    Linear chain of coupled oscillators (toy model of a medium).
    
    Attributes:
        n: Number of oscillators.
        k: Coupling stiffness between neighbors.
        m: Mass of each oscillator.
        gamma: Damping coefficient (optional, default 0.0).
    """
    n: int
    k: float | np.ndarray
    m: float | np.ndarray
    gamma: float = 0.0
    
    def __post_init__(self):
        """Validate parameters."""
        if self.n < 1:
            raise ValueError("Number of oscillators must be >= 1")
            
        # Validate mass
        if np.any(np.asarray(self.m) <= 0):
            raise ValueError("Mass must be positive")
            
        # Validate stiffness
        if np.any(np.asarray(self.k) < 0):
            raise ValueError("Stiffness must be non-negative")
            
        if self.gamma < 0:
            raise ValueError("Damping must be non-negative")
    
    def stiffness_matrix(self) -> np.ndarray:
        """
        Construct the stiffness matrix for the chain with nearest-neighbor coupling.
        
        Boundary conditions: Fixed ends (both ends are anchored).
        
        If k is scalar: uniform stiffness.
        If k is array: k[i] is stiffness between node i and i+1.
        Wait, we have N nodes. We have N+1 springs if fixed walls?
        Or N-1 springs between nodes?
        
        Let's assume:
        - If k is scalar: all springs are k (including walls).
        - If k is array: it must have length N-1 (internal springs) or N+1 (all springs).
        
        For LayeredMedium1D, I passed k of length N-1.
        So let's assume walls have "default" stiffness or same as nearest?
        
        Let's standardize:
        If k is array of length N-1:
           k[i] connects node i and i+1.
           Wall-0 connection: use k[0] (or some default?)
           (N-1)-Wall connection: use k[N-2]
           
        Actually, in LayeredMedium1D, I calculate k_springs for N-1 intervals.
        I didn't specify wall stiffness.
        
        Let's assume for now that if k is array (N-1), we use k[0] for left wall and k[-1] for right wall.
        """
        N = self.n
        K = np.zeros((N, N))
        
        # Helper to get k for interval i (between node i and i+1)
        # i goes from -1 (left wall) to N-1 (right wall)
        
        k_arr = np.asarray(self.k)
        if k_arr.ndim == 0:
            # Scalar
            k_vals = np.full(N + 1, float(k_arr))
        else:
            # Array
            if len(k_arr) == N - 1:
                # Pad with edge values for walls
                k_vals = np.zeros(N + 1)
                k_vals[1:-1] = k_arr
                k_vals[0] = k_arr[0]
                k_vals[-1] = k_arr[-1]
            elif len(k_arr) == N + 1:
                k_vals = k_arr
            else:
                raise ValueError(f"Stiffness array length must be {N-1} or {N+1}")
        
        # k_vals[i] is spring between node i-1 and i?
        # Let's say indices 0..N are springs.
        # Spring 0: Wall -> Node 0
        # Spring 1: Node 0 -> Node 1
        # ...
        # Spring N: Node N-1 -> Wall
        
        # Re-map k_vals to this logic
        # If we had N-1 internal springs (0..N-2), they correspond to indices 1..N-1 in my new list.
        
        # Let's build K
        for i in range(N):
            # Node i
            
            # Spring to left (index i)
            k_left = k_vals[i]
            K[i, i] += k_left
            if i > 0:
                K[i, i-1] = -k_left
                
            # Spring to right (index i+1)
            k_right = k_vals[i+1]
            K[i, i] += k_right
            if i < N - 1:
                K[i, i+1] = -k_right
                
        return K
    
    def eigenmodes(self) -> tuple[np.ndarray, np.ndarray]:
        """
        Compute eigenfrequencies and eigenmodes of the oscillator chain.
        
        Solves the eigenvalue problem: K * v = (m * omega^2) * v
        where K is the stiffness matrix.
        
        Returns:
            omega: Array of eigenfrequencies (sorted, >= 0).
            modes: Matrix of eigenvectors (n, n), each column is a mode.
        
        Note:
            Eigenfrequencies are angular frequencies (rad/s).
            Modes are normalized eigenvectors.
        """
    def eigenmodes(self) -> tuple[np.ndarray, np.ndarray]:
        """
        Compute eigenfrequencies and eigenmodes of the oscillator chain.
        
        Solves the generalized eigenvalue problem: K * v = (omega^2 * M) * v
        where K is stiffness matrix, M is mass matrix (diagonal).
        
        Returns:
            omega: Array of eigenfrequencies (sorted, >= 0).
            modes: Matrix of eigenvectors (n, n), each column is a mode.
        """
        K = self.stiffness_matrix()
        
        # Mass matrix
        m_arr = np.asarray(self.m)
        if m_arr.ndim == 0:
            # Uniform mass
            M = np.diag(np.full(self.n, float(m_arr)))
        else:
            M = np.diag(m_arr)
            
        # Solve generalized eigenvalue problem
        # K * v = lambda * M * v
        # lambda = omega^2
        eigenvalues, eigenvectors = scipy.linalg.eigh(K, b=M)
        
        # Convert eigenvalues to frequencies
        # lambda = omega^2 => omega = sqrt(lambda)
        eigenvalues = np.maximum(eigenvalues, 0.0)
        omega = np.sqrt(eigenvalues)
        
        return omega, eigenvectors



================================================================================
–§–ê–ô–õ: src\spectral_physics\medium_2d.py
================================================================================

import numpy as np
import scipy.linalg
import scipy.sparse
import scipy.sparse.linalg
from dataclasses import dataclass

@dataclass
class OscillatorGrid2D:
    """
    2D —Å–µ—Ç–∫–∞ —Å–≤—è–∑–∞–Ω–Ω—ã—Ö –æ—Å—Ü–∏–ª–ª—è—Ç–æ—Ä–æ–≤ (–∏–≥—Ä—É—à–µ—á–Ω–∞—è –º–æ–¥–µ–ª—å —É–ø—Ä—É–≥–æ–π –ø–ª–∞—Å—Ç–∏–Ω—ã).

    –°—Ö–µ–º–∞:
    - –∫–∞–∂–¥–∞—è —Ç–æ—á–∫–∞ (i, j) —Å–≤—è–∑–∞–Ω–∞ —Å —Å–æ—Å–µ–¥—è–º–∏ –ø–æ x –∏ y
    - –≤–æ–∑–º–æ–∂–Ω—ã —Ä–∞–∑–Ω—ã–µ –∂—ë—Å—Ç–∫–æ—Å—Ç–∏ kx, ky
    - –º–∞—Å—Å–∞ –≤ —É–∑–ª–µ –æ–¥–Ω–∞ –∏ —Ç–∞ –∂–µ
    - –ì—Ä–∞–Ω–∏—á–Ω—ã–µ —É—Å–ª–æ–≤–∏—è: –∑–∞–∫—Ä–µ–ø–ª—ë–Ω–Ω—ã–µ –∫—Ä–∞—è (–Ω—É–ª–µ–≤–æ–µ —Å–º–µ—â–µ–Ω–∏–µ –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ —Å–µ—Ç–∫–∏).
    """
    nx: int
    ny: int
    kx: float
    ky: float
    m: float
    
    # Optional local parameters (defects)
    mass_map: np.ndarray | None = None  # (ny, nx)
    kx_map: np.ndarray | None = None    # (ny, nx) - stiffness to right neighbor?
    # Let's define: kx_map[i, j] is stiffness between (i,j) and (i,j+1)
    # ky_map[i, j] is stiffness between (i,j) and (i+1,j)
    # Or simpler: kx_map[i, j] is "local stiffness coefficient" for node (i,j) in x-direction
    # Let's stick to the simple model: 
    # kx_map[i, j] overrides self.kx for connections involving node (i,j).
    # But connections are shared. Let's say connection (i,j)-(i,j+1) uses average or min?
    # Simpler: kx_map defines the link to the RIGHT (j+1)
    # ky_map defines the link to the DOWN (i+1)
    # This is unambiguous.
    
    ky_map: np.ndarray | None = None

    def stiffness_matrix(self) -> np.ndarray:
        """
        –°–æ–±—Ä–∞—Ç—å –º–∞—Ç—Ä–∏—Ü—É –∂—ë—Å—Ç–∫–æ—Å—Ç–∏ —Ä–∞–∑–º–µ—Ä–∞ (nx*ny, nx*ny).
        –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è 5-—Ç–æ—á–µ—á–Ω—ã–π —à–∞–±–ª–æ–Ω (—Ü–µ–Ω—Ç—Ä, –ª–µ–≤–æ, –ø—Ä–∞–≤–æ, –≤–µ—Ä—Ö, –Ω–∏–∑).
        
        –ò–Ω–¥–µ–∫—Å–∞—Ü–∏—è: k = i * nx + j, –≥–¥–µ i - —Å—Ç—Ä–æ–∫–∞ (0..ny-1), j - —Å—Ç–æ–ª–±–µ—Ü (0..nx-1).
        """
        N = self.nx * self.ny
        K = np.zeros((N, N))
        
        # Helper to get stiffness
        def get_kx(i, j):
            if self.kx_map is not None:
                return self.kx_map[i, j]
            return self.kx
            
        def get_ky(i, j):
            if self.ky_map is not None:
                return self.ky_map[i, j]
            return self.ky
        
        for i in range(self.ny):
            for j in range(self.nx):
                k = i * self.nx + j
                
                diag_val = 0.0
                
                # Link to Right (j+1)
                if j < self.nx - 1:
                    kval = get_kx(i, j)
                    k_right = i * self.nx + (j + 1)
                    
                    K[k, k] += kval
                    K[k_right, k_right] += kval
                    K[k, k_right] = -kval
                    K[k_right, k] = -kval
                else:
                    # Boundary condition: fixed wall on the right?
                    # Original code: 
                    # diag_val += self.kx (always added for left/right)
                    # If we follow original logic: "spring exists always"
                    # For right boundary: spring connects to wall.
                    kval = get_kx(i, j)
                    K[k, k] += kval
                    
                # Link to Left (j-1)
                # Handled by (j-1)'s link to Right?
                # No, we iterate all nodes.
                # Let's be careful not to double count if we iterate all.
                # Standard assembly: iterate elements (springs) or nodes?
                # If iterating nodes, we add contribution of all connected springs.
                pass

        # Re-implementing with clear "spring-based" assembly to avoid confusion
        K = np.zeros((N, N))
        
        # 1. Horizontal springs
        for i in range(self.ny):
            for j in range(self.nx):
                # Spring to the right of (i,j)
                # Connects (i,j) and (i,j+1) OR (i,j) and Wall
                
                k_curr = i * self.nx + j
                kval = get_kx(i, j)
                
                # Add to current node diagonal
                K[k_curr, k_curr] += kval
                
                if j < self.nx - 1:
                    k_right = i * self.nx + (j + 1)
                    K[k_right, k_right] += kval
                    K[k_curr, k_right] = -kval
                    K[k_right, k_curr] = -kval
                # If j == nx-1, it connects to wall (displacement 0), so only diagonal term remains.
                
                # Wait, what about the spring to the LEFT of (i,0)?
                # We need a spring there too if boundaries are fixed.
                # My previous logic: "diag_val += self.kx" implied spring to left and right.
                # So we need to iterate j from -1 to nx-1?
                # Let's assume:
                # Node j has spring to j+1 (defined by kx_map[i,j])
                # Node j has spring to j-1 (defined by kx_map[i,j-1]?)
                # Boundary: Wall -> Node 0. Let's say this is defined by kx_map[i, -1] ?? No.
                
                # Let's assume kx_map has shape (ny, nx+1) to cover all intervals?
                # Or just use kx_map for internal links and kx for boundaries?
                # Or simpler: kx_map[i,j] is the spring to the RIGHT of node j.
                # And we assume default kx for the spring to the LEFT of node 0.
                pass
        
        # Let's stick to the node-based logic but be consistent.
        # Node (i,j) is connected to:
        # Left: (i, j-1). Stiffness? Use get_kx(i, j-1) if j>0. If j=0, use get_kx(i, -1)?
        # Right: (i, j+1). Stiffness? Use get_kx(i, j).
        
        # To make it symmetric and simple:
        # kx_map[i, j] is the stiffness of the link between (i,j) and (i,j+1).
        # For boundary springs (Wall-0 and (N-1)-Wall), let's use self.kx (global).
        
        K = np.zeros((N, N))
        
        for i in range(self.ny):
            for j in range(self.nx):
                k_curr = i * self.nx + j
                
                # --- Horizontal ---
                
                # Link Left: (i, j-1) <-> (i, j)
                if j == 0:
                    k_left_val = self.kx # Wall
                else:
                    k_left_val = get_kx(i, j-1)
                    k_left = i * self.nx + (j - 1)
                    K[k_curr, k_left] = -k_left_val
                
                K[k_curr, k_curr] += k_left_val
                
                # Link Right: (i, j) <-> (i, j+1)
                if j == self.nx - 1:
                    k_right_val = self.kx # Wall
                else:
                    k_right_val = get_kx(i, j)
                    k_right = i * self.nx + (j + 1)
                    K[k_curr, k_right] = -k_right_val
                    
                K[k_curr, k_curr] += k_right_val
                
                # --- Vertical ---
                
                # Link Up: (i-1, j) <-> (i, j)
                if i == 0:
                    k_up_val = self.ky # Wall
                else:
                    k_up_val = get_ky(i-1, j)
                    k_up = (i - 1) * self.nx + j
                    K[k_curr, k_up] = -k_up_val
                    
                K[k_curr, k_curr] += k_up_val
                
                # Link Down: (i, j) <-> (i+1, j)
                if i == self.ny - 1:
                    k_down_val = self.ky # Wall
                else:
                    k_down_val = get_ky(i, j)
                    k_down = (i + 1) * self.nx + j
                    K[k_curr, k_down] = -k_down_val
                    
                K[k_curr, k_curr] += k_down_val
                
        return K

    def eigenmodes(self, n_modes: int | None = None) -> tuple[np.ndarray, np.ndarray]:
        """
        –ù–∞–π—Ç–∏ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ —á–∞—Å—Ç–æ—Ç—ã –∏ –º–æ–¥—ã.
        """
        K = self.stiffness_matrix()
        
        # Mass matrix M
        if self.mass_map is not None:
            m_vec = self.mass_map.flatten()
        else:
            m_vec = np.full(self.nx * self.ny, self.m)
            
        # Generalized eigenvalue problem: K v = lambda M v
        # Since M is diagonal, we can transform to standard EVP:
        # M^(-1/2) K M^(-1/2) u = lambda u, where v = M^(-1/2) u
        # Or just use eigh with b argument (if positive definite)
        
        # Let's use eigh(K, b=M) if possible, but M is diagonal array.
        # scipy.linalg.eigh supports b as matrix.
        M = np.diag(m_vec)
        
        if n_modes is not None and n_modes < len(m_vec):
             eigvals, eigvecs = scipy.linalg.eigh(
                K, b=M,
                subset_by_index=(0, n_modes - 1)
            )
        else:
            eigvals, eigvecs = scipy.linalg.eigh(K, b=M)
            
        eigvals = np.maximum(eigvals, 0.0)
        omega = np.sqrt(eigvals) # lambda = omega^2 (mass is already in M)
        
        return omega, eigvecs
        omega = np.sqrt(eigvals / self.m)
        
        return omega, eigvecs

    def ldos_map(
        self,
        n_modes: int,
        freq_window: tuple[float, float],
    ) -> np.ndarray:
        """
        –í–µ—Ä–Ω—É—Ç—å LDOS-–∫–∞—Ä—Ç—É —Ñ–æ—Ä–º—ã (ny, nx) –≤ –∑–∞–¥–∞–Ω–Ω–æ–º —á–∞—Å—Ç–æ—Ç–Ω–æ–º –æ–∫–Ω–µ.
        –ò—Å–ø–æ–ª—å–∑—É–µ—Ç eigenmodes(...) + ldos_from_modes(...).
        """
        from .ldos import ldos_from_modes
        
        omega, modes = self.eigenmodes(n_modes=n_modes)
        ldos_flat = ldos_from_modes(modes, omega, freq_window)
        
        return ldos_flat.reshape((self.ny, self.nx))



================================================================================
–§–ê–ô–õ: src\spectral_physics\ndt.py
================================================================================

import numpy as np
from dataclasses import dataclass
from .medium_2d import OscillatorGrid2D

@dataclass
class NDTProfile:
    """
    Profile of a 'healthy' material state for NDT.
    Stores statistical properties of the LDOS map.
    """
    freq_window: tuple[float, float]
    ldos_mean: np.ndarray   # Mean LDOS map (ny, nx)
    ldos_std: np.ndarray    # Std dev of LDOS map (ny, nx)

def build_ndt_profile(
    grid: OscillatorGrid2D,
    n_modes: int,
    freq_window: tuple[float, float],
    n_samples: int = 1,
    noise_level: float = 0.0
) -> NDTProfile:
    """
    Build an NDT profile by sampling the grid's LDOS.
    
    Args:
        grid: The OscillatorGrid2D instance (healthy state).
        n_modes: Number of modes to calculate for LDOS.
        freq_window: Frequency window (min, max) for LDOS.
        n_samples: Number of samples to average (useful if adding noise).
        noise_level: Amplitude of random mass noise to add for robustness.
        
    Returns:
        NDTProfile containing mean and std of LDOS.
    """
    ldos_maps = []
    
    base_mass = grid.m
    # If grid has mass_map, use it as base
    if grid.mass_map is not None:
        base_mass_map = grid.mass_map.copy()
    else:
        base_mass_map = np.full((grid.ny, grid.nx), base_mass)
        
    for _ in range(n_samples):
        # Perturb mass slightly if noise requested
        if noise_level > 0:
            noise = np.random.normal(0, noise_level, size=base_mass_map.shape)
            current_mass = base_mass_map + noise
            # Ensure mass stays positive
            current_mass = np.maximum(current_mass, 1e-3)
            
            # Create temp grid with perturbed mass
            temp_grid = OscillatorGrid2D(
                nx=grid.nx, ny=grid.ny,
                kx=grid.kx, ky=grid.ky,
                m=grid.m, # Base scalar m, but we override with map
                mass_map=current_mass,
                kx_map=grid.kx_map,
                ky_map=grid.ky_map
            )
            ldos = temp_grid.ldos_map(n_modes=n_modes, freq_window=freq_window)
        else:
            # No noise, just calc once (or n_samples times same result)
            ldos = grid.ldos_map(n_modes=n_modes, freq_window=freq_window)
            
        ldos_maps.append(ldos)
        
    ldos_stack = np.array(ldos_maps)
    
    mean_ldos = np.mean(ldos_stack, axis=0)
    if n_samples > 1 and noise_level > 0:
        std_ldos = np.std(ldos_stack, axis=0)
    else:
        # If single sample, std is undefined/zero. 
        std_ldos = np.zeros_like(mean_ldos)
        
    return NDTProfile(
        freq_window=freq_window,
        ldos_mean=mean_ldos,
        ldos_std=std_ldos
    )

def score_ndt_state(
    profile: NDTProfile,
    ldos_current: np.ndarray,
    epsilon: float = 1e-6
) -> np.ndarray:
    """
    Compare current LDOS with profile.
    Returns a 'defect score' map.
    
    If profile has valid std, use Z-score: |x - mean| / (std + eps).
    Otherwise, use absolute difference: |x - mean|.
    """
    diff = np.abs(ldos_current - profile.ldos_mean)
    
    # Check if we have valid std (non-zero max)
    if np.max(profile.ldos_std) > epsilon:
        # Z-score like metric
        score = diff / (profile.ldos_std + epsilon)
    else:
        # Just difference
        score = diff
        
    return score

def ndt_defect_mask(
    scores: np.ndarray,
    threshold: float
) -> np.ndarray:
    """
    Return boolean mask where score > threshold.
    """
    return scores > threshold



================================================================================
–§–ê–ô–õ: src\spectral_physics\report.py
================================================================================

from typing import Dict
import datetime

def generate_markdown_report(
    scores: Dict[str, float],
    thresholds: Dict[str, float],
    out_path: str,
    title: str = "Spectral Health Report",
) -> None:
    """
    –°–æ—Ö—Ä–∞–Ω–∏—Ç—å markdown-—Ñ–∞–π–ª —Å —Ç–∞–±–ª–∏—Ü–µ–π –ø–æ –∫–∞–Ω–∞–ª–∞–º.
    
    Args:
        scores: –°–ª–æ–≤–∞—Ä—å {–∏–º—è_–∫–∞–Ω–∞–ª–∞: –¥–∏—Å—Ç–∞–Ω—Ü–∏—è}.
        thresholds: –°–ª–æ–≤–∞—Ä—å {–∏–º—è_–∫–∞–Ω–∞–ª–∞: –ø–æ—Ä–æ–≥}.
        out_path: –ü—É—Ç—å –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –æ—Ç—á–µ—Ç–∞.
        title: –ó–∞–≥–æ–ª–æ–≤–æ–∫ –æ—Ç—á–µ—Ç–∞.
    """
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    lines = [
        f"# {title}",
        f"",
        f"**Date:** {timestamp}",
        f"",
        f"## Channel Status",
        f"",
        f"| Channel | Distance | Threshold | Status |",
        f"|---------|----------|-----------|--------|"
    ]
    
    any_anomaly = False
    
    for name, distance in scores.items():
        threshold = thresholds.get(name, 0.0)
        is_anom = distance > threshold
        status = "üî¥ **ANOMALY**" if is_anom else "üü¢ OK"
        
        if is_anom:
            any_anomaly = True
            
        lines.append(
            f"| `{name}` | {distance:.6f} | {threshold:.6f} | {status} |"
        )
        
    lines.append("")
    
    if any_anomaly:
        lines.append("> [!WARNING]")
        lines.append("> Anomalies detected! Please check the affected channels.")
    else:
        lines.append("> [!NOTE]")
        lines.append("> All systems nominal.")
        
    with open(out_path, 'w', encoding='utf-8') as f:
        f.write("\n".join(lines))


def generate_ndt_report(
    profile_ldos: "np.ndarray",
    current_ldos: "np.ndarray",
    scores: "np.ndarray",
    mask: "np.ndarray",
    out_path: str,
    title: str = "Spectral NDT Report"
) -> None:
    """
    Generate NDT report with defect statistics.
    """
    import numpy as np
    import datetime
    
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    n_defects = np.sum(mask)
    total_pixels = mask.size
    defect_ratio = n_defects / total_pixels * 100
    
    max_score = np.max(scores)
    mean_score = np.mean(scores)
    
    lines = [
        f"# {title}",
        f"",
        f"**Date:** {timestamp}",
        f"",
        f"## Defect Statistics",
        f"- **Defect Pixels:** {n_defects} / {total_pixels} ({defect_ratio:.2f}%)",
        f"- **Max Defect Score:** {max_score:.4f}",
        f"- **Mean Score:** {mean_score:.4f}",
        f"",
        f"## Defect Locations (Top 10)",
        f"| X | Y | Score |",
        f"|---|---|-------|"
    ]
    
    # Find top 10 defects
    if n_defects > 0:
        flat_indices = np.argsort(scores.flatten())[::-1]
        top_indices = flat_indices[:10]
        
        ny, nx = scores.shape
        for idx in top_indices:
            y, x = np.unravel_index(idx, (ny, nx))
            score = scores[y, x]
            if mask[y, x]:
                lines.append(f"| {x} | {y} | {score:.4f} |")
    else:
        lines.append("| - | - | - |")
        
    lines.append("")
    
    if n_defects > 0:
        lines.append("> [!WARNING]")
        lines.append(f"> **{n_defects} defect pixels detected!** Check the map.")
    else:
        lines.append("> [!NOTE]")
        lines.append("> No defects detected.")
        
    with open(out_path, 'w', encoding='utf-8') as f:
        f.write("\n".join(lines))




================================================================================
–§–ê–ô–õ: src\spectral_physics\root_finding.py
================================================================================

import numpy as np
from typing import Callable, Tuple


def symmetric_newton(
    f: Callable[[float], float],
    x0: float,
    h0: float = 1e-3,
    max_iter: int = 50,
    tol: float = 1e-10,
    tol_step: float = 1e-12,
) -> Tuple[float, int]:
    """
    –ù–∞–π—Ç–∏ –∫–æ—Ä–µ–Ω—å —É—Ä–∞–≤–Ω–µ–Ω–∏—è f(x) = 0 —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω—ã–º –º–µ—Ç–æ–¥–æ–º –ù—å—é—Ç–æ–Ω–∞,
    –Ω–µ –∏—Å–ø–æ–ª—å–∑—É—è –∞–Ω–∞–ª–∏—Ç–∏—á–µ—Å–∫—É—é –ø—Ä–æ–∏–∑–≤–æ–¥–Ω—É—é.

    –ò—Å–ø–æ–ª—å–∑—É–µ—Ç —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω—É—é —Ä–∞–∑–Ω–æ—Å—Ç–Ω—É—é –ø—Ä–æ–∏–∑–≤–æ–¥–Ω—É—é:
        f'(x) ‚âà (f(x + h) - f(x - h)) / (2*h)

    –∏ –∞–¥–∞–ø—Ç–∏–≤–Ω–æ —É–º–µ–Ω—å—à–∞–µ—Ç h, –µ—Å–ª–∏ —à–∞–≥ –ø–æ–ª—É—á–∞–µ—Ç—Å—è —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–∏–º
    –∏–ª–∏ –º–µ—Ç–æ–¥ –Ω–∞—á–∏–Ω–∞–µ—Ç —Ä–∞—Å—Ö–æ–¥–∏—Ç—å—Å—è.

    –ü–∞—Ä–∞–º–µ—Ç—Ä—ã:
        f: –≤—ã–∑—ã–≤–∞–µ–º–∞—è —Ñ—É–Ω–∫—Ü–∏—è f(x) -> float
        x0: –Ω–∞—á–∞–ª—å–Ω–æ–µ –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏–µ
        h0: –Ω–∞—á–∞–ª—å–Ω—ã–π —à–∞–≥ –¥–ª—è —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω–æ–π —Ä–∞–∑–Ω–æ—Å—Ç–∏
        max_iter: –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ —á–∏—Å–ª–æ –∏—Ç–µ—Ä–∞—Ü–∏–π
        tol: –¥–æ–ø—É—Å–∫ –ø–æ |f(x)|
        tol_step: –¥–æ–ø—É—Å–∫ –ø–æ –≤–µ–ª–∏—á–∏–Ω–µ —à–∞–≥–∞ |delta|

    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç:
        x_root: –Ω–∞–π–¥–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ x, –¥–ª—è –∫–æ—Ç–æ—Ä–æ–≥–æ f(x) ‚âà 0
        n_iter: —á–∏—Å–ª–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã—Ö –∏—Ç–µ—Ä–∞—Ü–∏–π
    
    Raises:
        ValueError: –µ—Å–ª–∏ –º–µ—Ç–æ–¥ —Ä–∞—Å—Ö–æ–¥–∏—Ç—Å—è (|x| —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–∏–º)
        
    Notes:
        –§—É–Ω–∫—Ü–∏—è –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç—Å—è, –µ—Å–ª–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ –õ–Æ–ë–û–ï –∏–∑ —É—Å–ª–æ–≤–∏–π:
        - |f(x)| < tol
        - |delta| < tol_step (–ø–æ–ª–µ–∑–Ω–æ –Ω–∞ –ø–ª–æ—Å–∫–∏—Ö —É—á–∞—Å—Ç–∫–∞—Ö)
        - –¥–æ—Å—Ç–∏–≥–Ω—É—Ç–æ max_iter
    """
    x = float(x0)
    h = float(h0)
    
    for i in range(max_iter):
        fx = f(x)
        
        # Check convergence by function value
        if abs(fx) < tol:
            return x, i
        
        # Check for divergence
        if abs(x) > 1e10:
            raise ValueError(f"Method diverged: |x| = {abs(x)} > 1e10")
        
        # Symmetric difference derivative
        # f'(x) ‚âà (f(x + h) - f(x - h)) / (2h)
        try:
            df = (f(x + h) - f(x - h)) / (2 * h)
        except Exception as e:
            raise ValueError(f"Failed to compute derivative at x={x}: {e}")
        
        # Protect against division by near-zero derivative
        if abs(df) < 1e-14:
            # Try reducing h
            h = h / 2
            if h < 1e-15:
                # Give up
                return x, i
            continue
        
        # Newton step
        delta = fx / df
        
        # Check convergence by step size
        if abs(delta) < tol_step:
            return x, i
        
        # Adaptive step: if step is too large, reduce it
        if abs(delta) > 100:
            delta = 100 * np.sign(delta)
            h = h / 2  # Also reduce h for next iteration
        
        x_new = x - delta
        
        # Simple backtracking: if new value is worse, reduce step
        try:
            fx_new = f(x_new)
            if abs(fx_new) > abs(fx) * 2:  # Getting worse
                delta = delta / 2
                x_new = x - delta
        except Exception:
            # If evaluation fails, reduce step
            delta = delta / 2
            x_new = x - delta
        
        x = x_new
    
    # Reached max iterations
    return x, max_iter





================================================================================
–§–ê–ô–õ: src\spectral_physics\spectrum.py
================================================================================

import numpy as np
from dataclasses import dataclass


@dataclass
class Spectrum1D:
    """
    One-dimensional discrete spectrum.
    
    Attributes:
        omega: Angular frequencies (1D array).
        power: Spectral power/energy density at each frequency (1D array).
    """
    omega: np.ndarray
    power: np.ndarray
    
    def __post_init__(self):
        """Validate that omega and power have the same shape."""
        self.omega = np.asarray(self.omega, dtype=float)
        self.power = np.asarray(self.power, dtype=float)
        
        if self.omega.shape != self.power.shape:
            raise ValueError(
                f"Shape mismatch: omega has shape {self.omega.shape}, "
                f"power has shape {self.power.shape}"
            )
    
    def normalize(self) -> "Spectrum1D":
        """
        Return a new Spectrum1D with normalized power (sum(power) = 1).
        
        Returns:
            New Spectrum1D instance with normalized power.
        
        Raises:
            ValueError: If total power is zero.
        """
        total = self.total_power()
        if total == 0:
            raise ValueError("Cannot normalize spectrum with zero total power")
        
        return Spectrum1D(
            omega=self.omega.copy(),
            power=self.power / total
        )
    
    def total_power(self) -> float:
        """
        Compute total power (integral/sum over all frequencies).
        
        Returns:
            Total power as a scalar.
        """
        return float(np.sum(self.power))
    
    def apply_filter(self, alpha: np.ndarray) -> "Spectrum1D":
        """
        Apply frequency-dependent filter/transparency alpha(omega).
        
        Args:
            alpha: Transparency/filter coefficients (same shape as power).
        
        Returns:
            New Spectrum1D with filtered power: new_power = power * alpha.
        
        Raises:
            ValueError: If alpha has incompatible shape.
        """
        alpha = np.asarray(alpha, dtype=float)
        
        if alpha.shape != self.power.shape:
            raise ValueError(
                f"Shape mismatch: alpha has shape {alpha.shape}, "
                f"expected {self.power.shape}"
            )
        
        return Spectrum1D(
            omega=self.omega.copy(),
            power=self.power * alpha
        )
    
    @classmethod
    def from_function(cls, omega: np.ndarray, func):
        """
        –°–æ–∑–¥–∞—Ç—å Spectrum1D –∏–∑ —Ñ—É–Ω–∫—Ü–∏–∏ power(omega).
        
        Args:
            omega: –ú–∞—Å—Å–∏–≤ —á–∞—Å—Ç–æ—Ç.
            func: –§—É–Ω–∫—Ü–∏—è, –ø—Ä–∏–Ω–∏–º–∞—é—â–∞—è omega –∏ –≤–æ–∑–≤—Ä–∞—â–∞—é—â–∞—è power.
        
        Returns:
            –ù–æ–≤—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä Spectrum1D.
        
        Raises:
            ValueError: –ï—Å–ª–∏ func(omega) –≤–µ—Ä–Ω—É–ª–∞ –º–∞—Å—Å–∏–≤ –Ω–µ—Å–æ–≤–º–µ—Å—Ç–∏–º–æ–π —Ñ–æ—Ä–º—ã.
        
        Example:
            >>> omega = np.linspace(0, 10, 100)
            >>> spec = Spectrum1D.from_function(omega, lambda w: np.exp(-w))
        """
        omega = np.asarray(omega, dtype=float)
        power = np.asarray(func(omega), dtype=float)
        
        if power.shape != omega.shape:
            raise ValueError(
                f"func(omega) must return array with same shape as omega. "
                f"Got power shape {power.shape}, expected {omega.shape}"
            )
        
        return cls(omega=omega, power=power)




================================================================================
–§–ê–ô–õ: src\spectral_physics\timeseries.py
================================================================================

import numpy as np
from .spectrum import Spectrum1D


def timeseries_to_spectrum(
    signal: np.ndarray,
    dt: float,
    window: str = "hann",
) -> Spectrum1D:
    """
    –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –æ–¥–Ω–æ–º–µ—Ä–Ω—ã–π –≤—Ä–µ–º–µ–Ω–Ω–æ–π —Å–∏–≥–Ω–∞–ª –≤ –∞–º–ø–ª–∏—Ç—É–¥–Ω—ã–π —Å–ø–µ–∫—Ç—Ä.
    
    –ü–∞—Ä–∞–º–µ—Ç—Ä—ã:
        signal: 1D-–º–∞—Å—Å–∏–≤ –æ—Ç—Å—á—ë—Ç–æ–≤ –≤–æ –≤—Ä–µ–º–µ–Ω–∏.
        dt: —à–∞–≥ –ø–æ –≤—Ä–µ–º–µ–Ω–∏ (—Å–µ–∫—É–Ω–¥—ã).
        window: —Ç–∏–ø –æ–∫–Ω–∞ ("hann" –∏–ª–∏ None).
    
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç:
        Spectrum1D —Å:
            omega: —É–≥–ª–æ–≤—ã–µ —á–∞—Å—Ç–æ—Ç—ã (rad/s) –¥–ª—è –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã—Ö —á–∞—Å—Ç–æ—Ç.
            power: |FFT|^2 / N –∏–ª–∏ –∞–Ω–∞–ª–æ–≥–∏—á–Ω–∞—è –Ω–æ—Ä–º–∏—Ä–æ–≤–∫–∞.
    
    Example:
        >>> t = np.arange(0, 1.0, 0.001)
        >>> signal = np.sin(2 * np.pi * 50 * t)  # 50 Hz
        >>> spectrum = timeseries_to_spectrum(signal, dt=0.001)
    """
    signal = np.asarray(signal, dtype=float)
    
    if signal.ndim != 1:
        raise ValueError(f"Signal must be 1D array, got shape {signal.shape}")
    
    n = len(signal)
    if n == 0:
        raise ValueError("Signal must not be empty")
    
    # –£–¥–∞–ª–µ–Ω–∏–µ DC-–∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞ (–≤—ã—á–∏—Ç–∞–Ω–∏–µ —Å—Ä–µ–¥–Ω–µ–≥–æ)
    signal_ac = signal - np.mean(signal)
    
    # –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –æ–∫–æ–Ω–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏
    if window == "hann":
        window_func = np.hanning(n)
        signal_windowed = signal_ac * window_func
    elif window is None:
        signal_windowed = signal_ac
    else:
        raise ValueError(f"Unknown window type: {window}. Use 'hann' or None.")
    
    # FFT (—Ç–æ–ª—å–∫–æ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–µ —á–∞—Å—Ç–æ—Ç—ã)
    fft_vals = np.fft.rfft(signal_windowed)
    
    # –ß–∞—Å—Ç–æ—Ç—ã –≤ –ì–µ—Ä—Ü–∞—Ö
    freq_hz = np.fft.rfftfreq(n, d=dt)
    
    # –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤ —É–≥–ª–æ–≤—ã–µ —á–∞—Å—Ç–æ—Ç—ã (rad/s)
    omega = 2 * np.pi * freq_hz
    
    # –ú–æ—â–Ω–æ—Å—Ç—å: |FFT|^2, –Ω–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –Ω–∞ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ—á–µ–∫
    # –ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç 2 –¥–ª—è —É—á—ë—Ç–∞ —ç–Ω–µ—Ä–≥–∏–∏ –≤ –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã—Ö —á–∞—Å—Ç–æ—Ç–∞—Ö (–∫—Ä–æ–º–µ DC –∏ Nyquist)
    power = np.abs(fft_vals) ** 2 / n
    
    # –£–¥–≤–æ–∏—Ç—å –º–æ—â–Ω–æ—Å—Ç—å –¥–ª—è –≤—Å–µ—Ö —á–∞—Å—Ç–æ—Ç –∫—Ä–æ–º–µ DC (–∏–Ω–¥–µ–∫—Å 0) –∏ Nyquist (–ø–æ—Å–ª–µ–¥–Ω–∏–π –¥–ª—è —á—ë—Ç–Ω–æ–≥–æ n)
    if n % 2 == 0:
        # –ß—ë—Ç–Ω–æ–µ n: DC –∏ Nyquist –Ω–µ —É–¥–≤–∞–∏–≤–∞—é—Ç—Å—è
        power[1:-1] *= 2
    else:
        # –ù–µ—á—ë—Ç–Ω–æ–µ n: —Ç–æ–ª—å–∫–æ DC –Ω–µ —É–¥–≤–∞–∏–≤–∞–µ—Ç—Å—è
        power[1:] *= 2
    
    return Spectrum1D(omega=omega, power=power)



================================================================================
–§–ê–ô–õ: src\spectral_physics_lab.egg-info\dependency_links.txt
================================================================================





================================================================================
–§–ê–ô–õ: src\spectral_physics_lab.egg-info\entry_points.txt
================================================================================

[console_scripts]
spectral-health = spectral_physics.cli:main



================================================================================
–§–ê–ô–õ: src\spectral_physics_lab.egg-info\requires.txt
================================================================================

numpy>=1.25
scipy>=1.11
matplotlib>=3.7
pyyaml>=6.0



================================================================================
–§–ê–ô–õ: src\spectral_physics_lab.egg-info\SOURCES.txt
================================================================================

README.md
pyproject.toml
src/spectral_physics/__init__.py
src/spectral_physics/atoms.py
src/spectral_physics/cli.py
src/spectral_physics/diagnostics.py
src/spectral_physics/geophysics_1d.py
src/spectral_physics/grav_toy.py
src/spectral_physics/io.py
src/spectral_physics/ldos.py
src/spectral_physics/material.py
src/spectral_physics/materials.py
src/spectral_physics/medium_1d.py
src/spectral_physics/medium_2d.py
src/spectral_physics/report.py
src/spectral_physics/root_finding.py
src/spectral_physics/spectrum.py
src/spectral_physics/timeseries.py
src/spectral_physics_lab.egg-info/PKG-INFO
src/spectral_physics_lab.egg-info/SOURCES.txt
src/spectral_physics_lab.egg-info/dependency_links.txt
src/spectral_physics_lab.egg-info/entry_points.txt
src/spectral_physics_lab.egg-info/requires.txt
src/spectral_physics_lab.egg-info/top_level.txt
tests/test_atoms.py
tests/test_diagnostics.py
tests/test_diagnostics_features.py
tests/test_geophysics_1d.py
tests/test_grav_toy.py
tests/test_io.py
tests/test_ldos.py
tests/test_material.py
tests/test_material_features.py
tests/test_materials.py
tests/test_medium_1d.py
tests/test_medium_2d.py
tests/test_report.py
tests/test_root_finding.py
tests/test_spectrum.py
tests/test_timeseries.py


================================================================================
–§–ê–ô–õ: src\spectral_physics_lab.egg-info\top_level.txt
================================================================================

spectral_physics



================================================================================
–§–ê–ô–õ: tests\test_atoms.py
================================================================================

import pytest
import numpy as np
from spectral_physics.atoms import (
    AtomicResonator, 
    spectral_overlap, 
    can_form_bond,
    H, O, C
)

def test_atomic_resonator_creation():
    atom = AtomicResonator.from_lines("Test", [(10.0, 1.0), (20.0, 0.5)], max_bonds=3)
    assert len(atom.omega) == 2
    assert atom.max_bonds == 3
    assert atom.name == "Test"
    
    spec = atom.spectrum()
    assert np.allclose(spec.omega, [10.0, 20.0])

def test_spectral_overlap_identical():
    # H vs H should have overlap
    # H has line at 1.0
    score = spectral_overlap(H, H, freq_tol=0.1)
    # Both normalized power is 1.0. Min(1,1) = 1.
    assert score > 0.9

def test_spectral_overlap_none():
    # Atom with far frequency
    X = AtomicResonator.from_lines("X", [(100.0, 1.0)], max_bonds=1)
    
    score = spectral_overlap(H, X, freq_tol=0.1)
    assert score == 0.0

def test_can_form_bond_logic():
    # H and O should bond (H=1.0, O has 1.0)
    assert can_form_bond(H, O, freq_tol=0.1, threshold=0.1)
    
    # Inert gas (He)
    He = AtomicResonator.from_lines("He", [(1.0, 1.0)], max_bonds=0)
    
    # Even if frequencies match, max_bonds=0 prevents bonding
    assert not can_form_bond(He, H, freq_tol=0.1, threshold=0.1)

def test_carbon_bonds():
    # C should bond with H
    assert can_form_bond(C, H, freq_tol=0.1, threshold=0.1)
    # C should bond with O
    assert can_form_bond(C, O, freq_tol=0.1, threshold=0.1)



================================================================================
–§–ê–ô–õ: tests\test_diagnostics.py
================================================================================

import numpy as np
import pytest
from spectral_physics.diagnostics import ChannelConfig, SpectralAnalyzer, HealthMonitor
from spectral_physics.spectrum import Spectrum1D


def test_channel_config_creation():
    """Test basic ChannelConfig creation."""
    config = ChannelConfig(
        name="test",
        dt=0.001,
        window="hann",
        freq_min=10.0,
        freq_max=100.0
    )
    
    assert config.name == "test"
    assert config.dt == 0.001
    assert config.window == "hann"
    assert config.freq_min == 10.0
    assert config.freq_max == 100.0


def test_spectral_analyzer_basic():
    """Test SpectralAnalyzer with known sine wave."""
    freq = 50.0  # Hz
    duration = 1.0
    dt = 0.001
    
    t = np.arange(0, duration, dt)
    signal = np.sin(2 * np.pi * freq * t)
    
    config = ChannelConfig(name="test", dt=dt)
    analyzer = SpectralAnalyzer(config)
    spectrum = analyzer.analyze(signal)
    
    # Should have peak near 50 Hz
    freq_hz = spectrum.omega / (2 * np.pi)
    peak_idx = np.argmax(spectrum.power)
    peak_freq = freq_hz[peak_idx]
    
    assert abs(peak_freq - freq) < 5.0  # Within 5 Hz


def test_spectral_analyzer_freq_filter():
    """Test that freq_min/freq_max actually filter frequencies."""
    duration = 1.0
    dt = 0.001
    
    t = np.arange(0, duration, dt)
    # Mix of low and high frequencies
    signal = (
        np.sin(2 * np.pi * 10 * t) +
        np.sin(2 * np.pi * 100 * t)
    )
    
    # Analyze with no filter
    config_all = ChannelConfig(name="all", dt=dt)
    analyzer_all = SpectralAnalyzer(config_all)
    spectrum_all = analyzer_all.analyze(signal)
    
    # Analyze with filter (only 50-150 Hz)
    config_filtered = ChannelConfig(
        name="filtered",
        dt=dt,
        freq_min=50.0,
        freq_max=150.0
    )
    analyzer_filtered = SpectralAnalyzer(config_filtered)
    spectrum_filtered = analyzer_filtered.analyze(signal)
    
    # Filtered spectrum should be smaller
    assert len(spectrum_filtered.omega) < len(spectrum_all.omega)
    
    # All frequencies in filtered spectrum should be in range
    freq_hz = spectrum_filtered.omega / (2 * np.pi)
    assert np.all(freq_hz >= 50.0)
    assert np.all(freq_hz <= 150.0)


def test_health_monitor_score():
    """Test HealthMonitor.score calculation."""
    omega = np.array([1.0, 2.0, 3.0])
    power_ref = np.array([1.0, 2.0, 1.0])
    power_current = np.array([1.0, 2.0, 1.0])  # Identical
    
    ref_spec = Spectrum1D(omega=omega, power=power_ref)
    current_spec = Spectrum1D(omega=omega, power=power_current)
    
    monitor = HealthMonitor(reference=ref_spec, threshold=0.1)
    score = monitor.score(current_spec)
    
    # Score should be zero for identical spectra
    assert abs(score) < 1e-10


def test_health_monitor_is_anomalous_false():
    """Test that  HealthMonitor correctly identifies normal spectrum."""
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([1.0, 2.0, 1.0])
    
    spec = Spectrum1D(omega=omega, power=power)
    monitor = HealthMonitor(reference=spec, threshold=0.1)
    
    is_anom = monitor.is_anomalous(spec)
    
    assert is_anom is False


def test_health_monitor_is_anomalous_true():
    """Test that HealthMonitor correctly identifies anomaly."""
    omega = np.array([1.0, 2.0, 3.0])
    power_ref = np.array([1.0, 2.0, 1.0])
    power_anom = np.array([5.0, 0.5, 3.0])  # Very different
    
    ref_spec = Spectrum1D(omega=omega, power=power_ref)
    anom_spec = Spectrum1D(omega=omega, power=power_anom)
    
    monitor = HealthMonitor(reference=ref_spec, threshold=0.1)
    is_anom = monitor.is_anomalous(anom_spec)
    
    assert is_anom is True


def test_spectral_analyzer_window_none():
    """Test SpectralAnalyzer with no window."""
    freq = 50.0
    duration = 1.0
    dt = 0.001
    
    t = np.arange(0, duration, dt)
    signal = np.sin(2 * np.pi * freq * t)
    
    config = ChannelConfig(name="test", dt=dt, window=None)
    analyzer = SpectralAnalyzer(config)
    spectrum = analyzer.analyze(signal)
    
    # Should still work
    assert len(spectrum.omega) > 0
    assert len(spectrum.power) > 0


def test_average_spectrum_basic():
    """Test averaging two identical spectra."""
    from spectral_physics.diagnostics import average_spectrum
    
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([1.0, 2.0, 1.0])
    
    spec1 = Spectrum1D(omega=omega, power=power)
    spec2 = Spectrum1D(omega=omega, power=power)
    
    avg = average_spectrum([spec1, spec2])
    
    np.testing.assert_array_equal(avg.omega, omega)
    np.testing.assert_array_equal(avg.power, power)


def test_average_spectrum_different_power():
    """Test averaging spectra with different powers."""
    from spectral_physics.diagnostics import average_spectrum
    
    omega = np.array([1.0, 2.0])
    spec1 = Spectrum1D(omega=omega, power=np.array([1.0, 1.0]))
    spec2 = Spectrum1D(omega=omega, power=np.array([3.0, 3.0]))
    
    avg = average_spectrum([spec1, spec2])
    
    # Average of 1 and 3 is 2
    expected = np.array([2.0, 2.0])
    np.testing.assert_array_equal(avg.power, expected)


def test_average_spectrum_mismatch():
    """Test that averaging spectra with different grids raises ValueError."""
    from spectral_physics.diagnostics import average_spectrum
    
    spec1 = Spectrum1D(omega=np.array([1.0]), power=np.array([1.0]))
    spec2 = Spectrum1D(omega=np.array([2.0]), power=np.array([1.0]))
    
    with pytest.raises(ValueError, match="different frequency grid"):
        average_spectrum([spec1, spec2])


def test_build_health_profile_simple():
    """Test building health profile from training data."""
    from spectral_physics.diagnostics import build_health_profile
    
    omega = np.array([1.0, 2.0])
    power = np.array([1.0, 1.0])
    spec = Spectrum1D(omega=omega, power=power)
    
    training_data = {
        "ch1": [spec, spec],
        "ch2": [spec, spec]
    }
    
    profile = build_health_profile(training_data)
    
    assert "ch1" in profile.signatures
    assert "ch2" in profile.signatures
    
    # Check that signatures are correct (distance to original should be 0)
    scores = profile.score({"ch1": spec, "ch2": spec})
    assert scores["ch1"] < 1e-10
    assert scores["ch2"] < 1e-10


def test_spectral_band_power():
    """Test spectral band power calculation."""
    from spectral_physics.diagnostics import spectral_band_power
    
    # 10 Hz and 100 Hz
    omega = np.array([2*np.pi*10, 2*np.pi*100])
    power = np.array([1.0, 2.0])
    spec = Spectrum1D(omega=omega, power=power)
    
    # Band covering only 10 Hz
    p1 = spectral_band_power(spec, freq_min=5, freq_max=15)
    assert abs(p1 - 1.0) < 1e-10
    
    # Band covering only 100 Hz
    p2 = spectral_band_power(spec, freq_min=90, freq_max=110)
    assert abs(p2 - 2.0) < 1e-10
    
    # Band covering both
    p3 = spectral_band_power(spec, freq_min=0, freq_max=200)
    assert abs(p3 - 3.0) < 1e-10


def test_spectral_entropy():
    """Test spectral entropy calculation."""
    from spectral_physics.diagnostics import spectral_entropy
    
    omega = np.array([1.0, 2.0, 3.0])
    
    # Uniform spectrum (max entropy)
    spec_uniform = Spectrum1D(omega=omega, power=np.array([1.0, 1.0, 1.0]))
    h_uniform = spectral_entropy(spec_uniform)
    
    # Peaked spectrum (lower entropy)
    spec_peaked = Spectrum1D(omega=omega, power=np.array([0.0, 10.0, 0.0]))
    h_peaked = spectral_entropy(spec_peaked)
    
    assert h_uniform > h_peaked
    # For single peak, entropy should be 0 (-1*log(1))
    assert abs(h_peaked) < 1e-10


def test_extract_features():
    """Test feature extraction."""
    from spectral_physics.diagnostics import extract_features
    
    # 10 Hz (power 1.0) and 100 Hz (power 2.0)
    omega = np.array([2*np.pi*10, 2*np.pi*100])
    power = np.array([1.0, 2.0])
    spec = Spectrum1D(omega=omega, power=power)
    
    bands = [(5, 15), (90, 110)]
    
    features = extract_features(spec, bands)
    
    assert len(features) == 3  # 2 bands + 1 entropy
    assert abs(features[0] - 1.0) < 1e-10
    assert abs(features[1] - 2.0) < 1e-10
    # Entropy should be > 0 for 2 peaks
    assert features[2] > 0






================================================================================
–§–ê–ô–õ: tests\test_diagnostics_features.py
================================================================================

import numpy as np
import pytest
from spectral_physics.spectrum import Spectrum1D
from spectral_physics.diagnostics import extract_features, spectral_band_power, spectral_entropy

def test_extract_features_structure():
    # Create a dummy spectrum
    omega = np.linspace(0, 100, 101)
    power = np.ones_like(omega)
    spec = Spectrum1D(omega, power)
    
    bands = [(0, 10), (10, 50)]
    features = extract_features(spec, bands)
    
    # Expect len(bands) + 1 (entropy)
    assert len(features) == 3
    assert isinstance(features, np.ndarray)

def test_spectral_band_power():
    # Spectrum with power 1.0 everywhere
    # omega is 0..100 rad/s -> freq is 0..100/(2pi) ~ 15.9 Hz
    # Let's use Hz directly for clarity in construction if possible, 
    # but Spectrum1D takes omega.
    
    # Let's make a simple discrete spectrum
    # 1 Hz = 2pi rad/s
    freq_hz = np.array([1.0, 2.0, 3.0])
    omega = freq_hz * 2 * np.pi
    power = np.array([10.0, 20.0, 30.0])
    
    spec = Spectrum1D(omega, power)
    
    # Band 0.5-1.5 Hz should capture 1.0 Hz (power 10)
    p1 = spectral_band_power(spec, 0.5, 1.5)
    assert p1 == 10.0
    
    # Band 1.5-2.5 Hz should capture 2.0 Hz (power 20)
    p2 = spectral_band_power(spec, 1.5, 2.5)
    assert p2 == 20.0
    
    # Band 0-10 Hz should capture all (60)
    p_all = spectral_band_power(spec, 0.0, 10.0)
    assert p_all == 60.0

def test_spectral_entropy():
    # 1. Flat spectrum (max entropy)
    omega = np.array([1, 2, 3, 4])
    power = np.array([1, 1, 1, 1]) # Normalized: 0.25 each
    spec = Spectrum1D(omega, power)
    
    # H = - sum(0.25 * ln(0.25)) * 4 = - ln(0.25) = ln(4)
    expected = np.log(4)
    assert np.isclose(spectral_entropy(spec), expected)
    
    # 2. Delta function (min entropy)
    power2 = np.array([1, 0, 0, 0])
    spec2 = Spectrum1D(omega, power2)
    # H = - (1*ln(1) + 0) = 0
    assert spectral_entropy(spec2) == 0.0



================================================================================
–§–ê–ô–õ: tests\test_geophysics_1d.py
================================================================================

import numpy as np
import pytest
from spectral_physics.geophysics_1d import (
    Layer, LayeredMedium1D, simulate_pulse_response, invert_single_layer_thickness
)

def test_layered_medium_creation():
    l1 = Layer(thickness=10.0, density=1.0, stiffness=1.0)
    l2 = Layer(thickness=10.0, density=2.0, stiffness=4.0)
    medium = LayeredMedium1D(layers=[l1, l2], dx=1.0)
    
    chain = medium.to_oscillator_chain()
    
    # Total depth 20, dx=1 -> 20 nodes
    assert chain.n == 20
    
    # First 10 nodes (0..9) should have mass ~ 1.0 * 1.0 = 1.0
    assert np.allclose(chain.m[:10], 1.0)
    
    # Next 10 nodes (10..19) should have mass ~ 2.0 * 1.0 = 2.0
    assert np.allclose(chain.m[10:], 2.0)

def test_simulation_runs():
    l1 = Layer(thickness=5.0, density=1.0, stiffness=1.0)
    medium = LayeredMedium1D(layers=[l1], dx=1.0)
    
    t, sig = simulate_pulse_response(medium, t_max=10.0, dt=0.1)
    
    assert len(t) == 100
    assert len(sig) == 100
    # Signal should not be all zeros (pulse happened)
    assert np.max(np.abs(sig)) > 0

def test_inversion_sanity():
    # Create target
    true_h = 5.0
    l1 = Layer(thickness=true_h, density=1.0, stiffness=1.0)
    l_sub = Layer(thickness=10.0, density=10.0, stiffness=10.0) # Hard substrate
    
    medium = LayeredMedium1D(layers=[l1, l_sub], dx=1.0)
    t_max = 20.0
    dt = 0.1
    t, target_sig = simulate_pulse_response(medium, t_max, dt)
    
    # Invert
    # Start guess 4.0
    h_found = invert_single_layer_thickness(
        target_sig, t, 
        density=1.0, stiffness=1.0, 
        thickness_guess=4.0,
        fixed_layers_below=[l_sub],
        dx=1.0
    )
    
    # Should be close to 5.0
    # Note: dx=1.0 makes resolution limited. 5.0 is exactly 5 nodes.
    # 4.0 is 4 nodes.
    # The optimizer should find 5.0 (or close to it if continuous interpretation)
    assert abs(h_found - true_h) < 1.5 # Tolerance due to dx discretization



================================================================================
–§–ê–ô–õ: tests\test_grav_toy.py
================================================================================

import numpy as np
import pytest
from spectral_physics.spectrum import Spectrum1D
from spectral_physics.grav_toy import spectral_pressure_difference


def test_spectral_pressure_equal_transparency():
    """Test that equal transparency gives zero pressure difference."""
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([1.0, 2.0, 1.0])
    spectrum = Spectrum1D(omega=omega, power=power)
    
    alpha = np.array([0.5, 0.5, 0.5])  # Same on both sides
    
    delta_p = spectral_pressure_difference(spectrum, alpha, alpha)
    
    assert abs(delta_p) < 1e-14


def test_spectral_pressure_left_blocks_more():
    """Test that if left blocks more, pressure pushes right (positive ŒîP)."""
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([1.0, 1.0, 1.0])
    spectrum = Spectrum1D(omega=omega, power=power)
    
    alpha_left = np.array([0.2, 0.2, 0.2])   # Blocks more (low transparency)
    alpha_right = np.array([0.8, 0.8, 0.8])  # Blocks less (high transparency)
    
    delta_p = spectral_pressure_difference(spectrum, alpha_left, alpha_right)
    
    # ŒîP = Œ£ power * (alpha_right - alpha_left)
    # = Œ£ 1.0 * (0.8 - 0.2) = 3 * 0.6 = 1.8
    expected = 3 * 0.6
    assert abs(delta_p - expected) < 1e-14


def test_spectral_pressure_right_blocks_more():
    """Test that if right blocks more, pressure pushes left (negative ŒîP)."""
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([2.0, 2.0, 2.0])
    spectrum = Spectrum1D(omega=omega, power=power)
    
    alpha_left = np.array([0.9, 0.9, 0.9])   # Blocks less
    alpha_right = np.array([0.1, 0.1, 0.1])  # Blocks more
    
    delta_p = spectral_pressure_difference(spectrum, alpha_left, alpha_right)
    
    # ŒîP = Œ£ 2.0 * (0.1 - 0.9) = 3 * 2.0 * (-0.8) = -4.8
    expected = 3 * 2.0 * (-0.8)
    assert abs(delta_p - expected) < 1e-14


def test_spectral_pressure_frequency_dependent():
    """Test with frequency-dependent transparency."""
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([1.0, 2.0, 3.0])
    spectrum = Spectrum1D(omega=omega, power=power)
    
    # Left transparent to low freq, blocks high freq
    alpha_left = np.array([1.0, 0.5, 0.0])
    
    # Right blocks low freq, transparent to high freq
    alpha_right = np.array([0.0, 0.5, 1.0])
    
    delta_p = spectral_pressure_difference(spectrum, alpha_left, alpha_right)
    
    # ŒîP = 1.0*(0.0-1.0) + 2.0*(0.5-0.5) + 3.0*(1.0-0.0)
    #    = -1.0 + 0.0 + 3.0 = 2.0
    expected = -1.0 + 0.0 + 3.0
    assert abs(delta_p - expected) < 1e-14


def test_spectral_pressure_shape_mismatch_left():
    """Test that mismatched left alpha shape raises ValueError."""
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([1.0, 2.0, 3.0])
    spectrum = Spectrum1D(omega=omega, power=power)
    
    alpha_left = np.array([0.5, 0.5])  # Wrong size
    alpha_right = np.array([0.5, 0.5, 0.5])
    
    with pytest.raises(ValueError, match="alpha_left"):
        spectral_pressure_difference(spectrum, alpha_left, alpha_right)


def test_spectral_pressure_shape_mismatch_right():
    """Test that mismatched right alpha shape raises ValueError."""
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([1.0, 2.0, 3.0])
    spectrum = Spectrum1D(omega=omega, power=power)
    
    alpha_left = np.array([0.5, 0.5, 0.5])
    alpha_right = np.array([0.5, 0.5])  # Wrong size
    
    with pytest.raises(ValueError, match="alpha_right"):
        spectral_pressure_difference(spectrum, alpha_left, alpha_right)


def test_spectral_pressure_realistic_scenario():
    """Test a more realistic scenario with Gaussian spectrum."""
    # Gaussian spectrum
    omega = np.linspace(0, 10, 100)
    power = np.exp(-(omega - 5)**2 / 2)
    spectrum = Spectrum1D(omega=omega, power=power)
    
    # Material that blocks high frequencies more
    alpha_left = np.exp(-omega / 10)  # Decays with frequency
    alpha_right = np.ones_like(omega) * 0.8  # Uniform transparency
    
    delta_p = spectral_pressure_difference(spectrum, alpha_left, alpha_right)
    
    # Should be positive (because left blocks more at high freq where power is)
    # The exact value depends on the convolution, but it should be positive
    assert delta_p != 0  # Non-trivial result



================================================================================
–§–ê–ô–õ: tests\test_io.py
================================================================================

import numpy as np
import pytest
import tempfile
from pathlib import Path
from spectral_physics.io import (
    load_timeseries_csv,
    save_spectrum_npz,
    load_spectrum_npz
)
from spectral_physics.spectrum import Spectrum1D


def test_load_timeseries_csv_simple():
    """Test loading simple CSV without header."""
    # Create temporary CSV
    with tempfile.NamedTemporaryFile(mode='w', suffix='.csv', delete=False) as f:
        f.write("1.0\n2.0\n3.0\n4.0\n5.0\n")
        temp_path = f.name
    
    try:
        signal = load_timeseries_csv(temp_path, column=0, skip_header=False)
        
        expected = np.array([1.0, 2.0, 3.0, 4.0, 5.0])
        np.testing.assert_array_equal(signal, expected)
    finally:
        Path(temp_path).unlink()


def test_load_timeseries_csv_with_header():
    """Test loading CSV with header."""
    with tempfile.NamedTemporaryFile(mode='w', suffix='.css', delete=False) as f:
        f.write("time,value\n")
        f.write("0.0,1.0\n0.1,2.0\n0.2,3.0\n")
        temp_path = f.name
    
    try:
        signal = load_timeseries_csv(temp_path, column=1, skip_header=True)
        
        expected = np.array([1.0, 2.0, 3.0])
        np.testing.assert_array_equal(signal, expected)
    finally:
        Path(temp_path).unlink()


def test_load_timeseries_csv_multiple_columns():
    """Test loading CSV with multiple columns."""
    with tempfile.NamedTemporaryFile(mode='w', suffix='.csv', delete=False) as f:
        f.write("1.0,10.0,100.0\n2.0,20.0,200.0\n3.0,30.0,300.0\n")
        temp_path = f.name
    
    try:
        # Load column 1
        signal = load_timeseries_csv(temp_path, column=1, skip_header=False)
        expected = np.array([10.0, 20.0, 30.0])
        np.testing.assert_array_equal(signal, expected)
    finally:
        Path(temp_path).unlink()


def test_load_timeseries_csv_file_not_found():
    """Test that missing file raises ValueError."""
    with pytest.raises(ValueError, match="File not found"):
        load_timeseries_csv("nonexistent.csv")


def test_load_timeseries_csv_invalid_column():
    """Test that invalid column index raises ValueError."""
    with tempfile.NamedTemporaryFile(mode='w', suffix='.csv', delete=False) as f:
        f.write("1.0,2.0\n3.0,4.0\n")
        temp_path = f.name
    
    try:
        with pytest.raises(ValueError, match="Column index .* out of range"):
            load_timeseries_csv(temp_path, column=5, skip_header=False)
    finally:
        Path(temp_path).unlink()


def test_save_load_spectrum_npz():
    """Test save and load spectrum roundtrip."""
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([0.5, 1.0, 0.5])
    
    original = Spectrum1D(omega=omega, power=power)
    
    # Save
    with tempfile.NamedTemporaryFile(suffix='.npz', delete=False) as f:
        temp_path = f.name
    
    try:
        save_spectrum_npz(original, temp_path)
        
        # Load
        loaded = load_spectrum_npz(temp_path)
        
        # Verify
        np.testing.assert_array_equal(loaded.omega, omega)
        np.testing.assert_array_equal(loaded.power, power)
    finally:
        Path(temp_path).unlink()


def test_load_spectrum_npz_missing_file():
    """Test that missing file raises ValueError."""
    with pytest.raises(ValueError, match="File not found"):
        load_spectrum_npz("nonexistent.npz")


def test_load_spectrum_npz_missing_keys():
    """Test that file missing required keys raises ValueError."""
    # Create npz with wrong keys
    with tempfile.NamedTemporaryFile(suffix='.npz', delete=False) as f:
        temp_path = f.name
    
    try:
        np.savez(temp_path, wrong_key=np.array([1, 2, 3]))
        
        with pytest.raises(ValueError, match="missing required keys"):
            load_spectrum_npz(temp_path)
    finally:
        Path(temp_path).unlink()


def test_save_load_health_profile_roundtrip():
    """Test save and load health profile roundtrip."""
    from spectral_physics.material import HealthProfile, MaterialSignature
    from spectral_physics.io import save_health_profile, load_health_profile
    
    omega = np.array([1.0, 2.0])
    power = np.array([1.0, 1.0])
    spec = Spectrum1D(omega=omega, power=power)
    sig = MaterialSignature(reference=spec)
    
    profile = HealthProfile(signatures={"ch1": sig, "ch2": sig})
    
    with tempfile.NamedTemporaryFile(suffix='.npz', delete=False) as f:
        temp_path = f.name
        
    try:
        save_health_profile(profile, temp_path)
        
        loaded = load_health_profile(temp_path)
        
        assert "ch1" in loaded.signatures
        assert "ch2" in loaded.signatures
        
        # Check content
        np.testing.assert_array_equal(
            loaded.signatures["ch1"].reference.power,
            power
        )
    finally:
        Path(temp_path).unlink()




================================================================================
–§–ê–ô–õ: tests\test_ldos.py
================================================================================

import numpy as np
import pytest
from spectral_physics.ldos import ldos_from_modes
from spectral_physics.medium_2d import OscillatorGrid2D

def test_ldos_empty_window():
    # 3 points, 2 modes
    modes = np.array([[1, 0], [0, 1], [1, 1]])
    omegas = np.array([1.0, 2.0])
    
    # Window that captures nothing
    ldos = ldos_from_modes(modes, omegas, (3.0, 4.0))
    
    assert np.all(ldos == 0)

def test_ldos_full_window():
    # 2 points, 2 modes
    # Mode 0: [1, 0] at w=1
    # Mode 1: [0, 1] at w=2
    modes = np.array([[1.0, 0.0], [0.0, 1.0]])
    omegas = np.array([1.0, 2.0])
    
    # Capture both
    ldos = ldos_from_modes(modes, omegas, (0.0, 3.0))
    
    # Point 0: 1^2 + 0^2 = 1
    # Point 1: 0^2 + 1^2 = 1
    assert np.allclose(ldos, [1.0, 1.0])

def test_grid_ldos_map_shape():
    grid = OscillatorGrid2D(nx=5, ny=5, kx=1.0, ky=1.0, m=1.0)
    
    # Calculate LDOS
    ldos_map = grid.ldos_map(n_modes=10, freq_window=(0.0, 10.0))
    
    assert ldos_map.shape == (5, 5)
    assert np.all(ldos_map >= 0)



================================================================================
–§–ê–ô–õ: tests\test_material.py
================================================================================

import numpy as np
import pytest
from spectral_physics.material import MaterialSignature
from spectral_physics.spectrum import Spectrum1D


def test_distance_identical_spectra():
    """Test that distance between identical spectra is zero."""
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([1.0, 2.0, 1.0])
    
    spec1 = Spectrum1D(omega=omega, power=power)
    spec2 = Spectrum1D(omega=omega, power=power.copy())
    
    sig = MaterialSignature(reference=spec1)
    distance = sig.distance_l2(spec2)
    
    assert abs(distance) < 1e-10


def test_distance_slightly_different():
    """Test distance for slightly different spectra."""
    omega = np.array([1.0, 2.0, 3.0])
    power1 = np.array([1.0, 2.0, 1.0])
    power2 = np.array([1.0, 2.1, 1.0])  # Slight difference
    
    spec1 = Spectrum1D(omega=omega, power=power1)
    spec2 = Spectrum1D(omega=omega, power=power2)
    
    sig = MaterialSignature(reference=spec1)
    distance = sig.distance_l2(spec2)
    
    # Should be small but non-zero
    assert distance > 0
    assert distance < 1.0


def test_distance_very_different():
    """Test distance for very different spectra."""
    omega = np.array([1.0, 2.0, 3.0])
    power1 = np.array([1.0, 2.0, 1.0])
    power2 = np.array([5.0, 0.5, 3.0])  # Very different shape
    
    spec1 = Spectrum1D(omega=omega, power=power1)
    spec2 = Spectrum1D(omega=omega, power=power2)
    
    sig = MaterialSignature(reference=spec1)
    distance = sig.distance_l2(spec2)
    
    # Should be large
    assert distance > 0.5


def test_distance_mismatched_frequencies():
    """Test that mismatched frequency grids raise ValueError."""
    omega1 = np.array([1.0, 2.0, 3.0])
    omega2 = np.array([1.0, 2.0, 3.0, 4.0])  # Different length
    
    spec1 = Spectrum1D(omega=omega1, power=np.array([1.0, 2.0, 1.0]))
    spec2 = Spectrum1D(omega=omega2, power=np.array([1.0, 2.0, 1.0, 1.0]))
    
    sig = MaterialSignature(reference=spec1)
    
    with pytest.raises(ValueError, match="Frequency grids do not match"):
        sig.distance_l2(spec2)


def test_is_anomalous_normal():
    """Test that identical spectrum is not anomalous."""
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([1.0, 2.0, 1.0])
    
    spec = Spectrum1D(omega=omega, power=power)
    sig = MaterialSignature(reference=spec)
    
    is_anom = sig.is_anomalous(spec, threshold=0.01)
    
    assert is_anom is False


def test_is_anomalous_below_threshold():
    """Test that small difference is not anomalous."""
    omega = np.array([1.0, 2.0, 3.0])
    power1 = np.array([1.0, 2.0, 1.0])
    power2 = np.array([1.0, 2.01, 1.0])  # Tiny difference
    
    spec1 = Spectrum1D(omega=omega, power=power1)
    spec2 = Spectrum1D(omega=omega, power=power2)
    
    sig = MaterialSignature(reference=spec1)
    is_anom = sig.is_anomalous(spec2, threshold=1.0)  # High threshold
    
    assert is_anom is False


def test_is_anomalous_above_threshold():
    """Test that large difference is anomalous."""
    omega = np.array([1.0, 2.0, 3.0])
    power1 = np.array([1.0, 2.0, 1.0])
    power2 = np.array([5.0, 0.5, 3.0])  # Very different
    
    spec1 = Spectrum1D(omega=omega, power=power1)
    spec2 = Spectrum1D(omega=omega, power=power2)
    
    sig = MaterialSignature(reference=spec1)
    is_anom = sig.is_anomalous(spec2, threshold=0.1)  # Low threshold
    
    assert is_anom is True


def test_distance_normalized():
    """Test that distance is based on normalized spectra."""
    omega = np.array([1.0, 2.0, 3.0])
    power1 = np.array([1.0, 2.0, 1.0])
    power2 = np.array([2.0, 4.0, 2.0])  # Same shape, double amplitude
    
    spec1 = Spectrum1D(omega=omega, power=power1)
    spec2 = Spectrum1D(omega=omega, power=power2)
    
    sig = MaterialSignature(reference=spec1)
    distance = sig.distance_l2(spec2)
    
    # Should be zero since normalized shapes are identical
    assert abs(distance) < 1e-10


def test_health_profile_score_identity():
    """Test HealthProfile score with identical spectra."""
    from spectral_physics.material import HealthProfile
    
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([1.0, 2.0, 1.0])
    spec = Spectrum1D(omega=omega, power=power)
    
    sig = MaterialSignature(reference=spec)
    profile = HealthProfile(signatures={"ch1": sig, "ch2": sig})
    
    current = {"ch1": spec, "ch2": spec}
    scores = profile.score(current)
    
    assert scores["ch1"] < 1e-10
    assert scores["ch2"] < 1e-10


def test_health_profile_is_anomalous_mixed():
    """Test HealthProfile with mixed anomalous/normal channels."""
    from spectral_physics.material import HealthProfile
    
    omega = np.array([1.0, 2.0, 3.0])
    power_ref = np.array([1.0, 2.0, 1.0])
    power_anom = np.array([5.0, 0.5, 3.0])
    
    spec_ref = Spectrum1D(omega=omega, power=power_ref)
    spec_anom = Spectrum1D(omega=omega, power=power_anom)
    
    sig = MaterialSignature(reference=spec_ref)
    profile = HealthProfile(signatures={"ch1": sig, "ch2": sig})
    
    current = {"ch1": spec_ref, "ch2": spec_anom}
    thresholds = {"ch1": 0.1, "ch2": 0.1}
    
    results = profile.is_anomalous(current, thresholds)
    
    assert results["ch1"] is False
    assert results["ch2"] is True


def test_distance_cosine_identical():
    """Test cosine distance for identical spectra."""
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([1.0, 2.0, 1.0])
    spec = Spectrum1D(omega=omega, power=power)
    
    sig = MaterialSignature(reference=spec)
    dist = sig.distance_cosine(spec)
    
    assert abs(dist) < 1e-10


def test_distance_cosine_orthogonal():
    """Test cosine distance for orthogonal-like spectra."""
    omega = np.array([1.0, 2.0])
    
    spec1 = Spectrum1D(omega=omega, power=np.array([1.0, 0.0]))
    spec2 = Spectrum1D(omega=omega, power=np.array([0.0, 1.0]))
    
    sig = MaterialSignature(reference=spec1)
    dist = sig.distance_cosine(spec2)
    
    # Cosine similarity is 0, so distance is 1 - 0 = 1
    assert abs(dist - 1.0) < 1e-10


def test_feature_signature_basic():
    """Test FeatureSignature distance."""
    from spectral_physics.material import FeatureSignature
    
    ref = np.array([1.0, 2.0, 3.0])
    sig = FeatureSignature(reference_features=ref)
    
    # Identical
    assert abs(sig.distance_l2(ref)) < 1e-10
    
    # Offset
    other = np.array([2.0, 2.0, 3.0]) # diff is [1, 0, 0]
    assert abs(sig.distance_l2(other) - 1.0) < 1e-10


def test_health_profile_score_features():
    """Test HealthProfile feature scoring."""
    from spectral_physics.material import HealthProfile, FeatureSignature, MaterialSignature
    from spectral_physics.diagnostics import extract_features
    
    # Setup dummy data
    omega = np.array([2*np.pi*10])
    power = np.array([1.0])
    spec = Spectrum1D(omega=omega, power=power)
    
    # Features for this spec: band_power(1.0) + entropy(0.0) = [1.0, 0.0]
    bands = [(5, 15)]
    feats = extract_features(spec, bands)
    
    feat_sig = FeatureSignature(reference_features=feats)
    mat_sig = MaterialSignature(reference=spec)
    
    profile = HealthProfile(
        signatures={"ch1": mat_sig},
        feature_signatures={"ch1": feat_sig}
    )
    
    # Score against itself should be 0
    scores = profile.score_features(
        {"ch1": spec},
        {"ch1": bands}
    )
    
    assert "ch1" in scores
    assert scores["ch1"] < 1e-10






================================================================================
–§–ê–ô–õ: tests\test_material_features.py
================================================================================

import numpy as np
import pytest
from spectral_physics.spectrum import Spectrum1D
from spectral_physics.material import FeatureSignature, HealthProfile, MaterialSignature

def test_feature_signature_distance():
    ref_feats = np.array([1.0, 2.0, 3.0])
    sig = FeatureSignature(reference_features=ref_feats)
    
    # Identical
    assert sig.distance_l2(ref_feats) == 0.0
    
    # Different
    other = np.array([2.0, 2.0, 3.0]) # diff 1.0 in first component
    assert sig.distance_l2(other) == 1.0
    
    # Shape mismatch
    with pytest.raises(ValueError):
        sig.distance_l2(np.array([1.0, 2.0]))

def test_health_profile_score_features(monkeypatch):
    # Mock extract_features to return predictable values
    import spectral_physics.material as mat
    
    # We need to mock it where it is imported inside the method or globally?
    # The method does: from .diagnostics import extract_features
    # So we need to mock spectral_physics.diagnostics.extract_features
    
    # But since it's a local import inside the function, mocking might be tricky if we don't patch the module.
    # Let's just use real objects, it's safer.
    
    # Setup
    omega = np.linspace(0, 10, 11)
    power = np.ones_like(omega)
    spec = Spectrum1D(omega, power)
    
    # Create profile with feature signature
    # Assume extract_features returns [band1, entropy] -> length 2 for 1 band
    # For power=1 everywhere, band power depends on width.
    # Let's just create a dummy FeatureSignature that matches what we expect from "healthy"
    
    # Let's compute expected features for "healthy"
    # Band 0-10 (all points? freq_hz = omega/2pi)
    # omega=10 -> freq ~ 1.59 Hz.
    # Band 0-2 Hz covers everything.
    # Power sum = 11.
    # Entropy = ln(11).
    
    bands = {'ch1': [(0.0, 2.0)]}
    
    # "Healthy" features
    feat_ref = np.array([11.0, np.log(11)])
    
    feat_sig = FeatureSignature(reference_features=feat_ref)
    
    profile = HealthProfile(
        signatures={'ch1': MaterialSignature(reference=spec)},
        feature_signatures={'ch1': feat_sig}
    )
    
    # 1. Test with identical spectrum
    scores = profile.score_features({'ch1': spec}, bands)
    assert 'ch1' in scores
    assert np.isclose(scores['ch1'], 0.0)
    
    # 2. Test with modified spectrum
    # Double the power -> band power doubles (22), entropy stays same (normalized)
    spec2 = Spectrum1D(omega, power * 2)
    scores2 = profile.score_features({'ch1': spec2}, bands)
    
    # Diff: band power 22 vs 11 -> diff 11. Entropy same.
    # Distance = sqrt(11^2 + 0) = 11.
    assert np.isclose(scores2['ch1'], 11.0)



================================================================================
–§–ê–ô–õ: tests\test_materials.py
================================================================================

import numpy as np
import pytest
from spectral_physics.materials import MaterialPatch, effective_coupling
from spectral_physics.atoms import AtomicResonator

def test_material_patch_spectrum():
    # Atom A: line at 1.0, power 1.0
    A = AtomicResonator.from_lines("A", [(1.0, 1.0)], max_bonds=1)
    # Atom B: line at 2.0, power 1.0
    B = AtomicResonator.from_lines("B", [(2.0, 1.0)], max_bonds=1)
    
    # Mix 50/50
    patch = MaterialPatch(atoms=[A, B], weights=np.array([0.5, 0.5]))
    
    spec = patch.surface_spectrum()
    
    assert len(spec.omega) == 2
    assert np.allclose(spec.omega, [1.0, 2.0])
    assert np.allclose(spec.power, [0.5, 0.5])

def test_effective_coupling():
    # Atom A: line at 1.0, power 1.0
    A = AtomicResonator.from_lines("A", [(1.0, 1.0)], max_bonds=1)
    patch = MaterialPatch(atoms=[A], weights=np.array([1.0]))
    
    # LDOS is constant 2.0
    ldos = np.array([2.0, 2.0, 2.0])
    
    # Window covers the line
    coupling = effective_coupling(ldos, patch, freq_window=(0.5, 1.5))
    
    # Power = 1.0. Avg LDOS = 2.0. Result = 2.0
    assert coupling == 2.0
    
    # Window does NOT cover the line
    coupling_zero = effective_coupling(ldos, patch, freq_window=(2.0, 3.0))
    assert coupling_zero == 0.0



================================================================================
–§–ê–ô–õ: tests\test_medium_1d.py
================================================================================

import numpy as np
import pytest
from spectral_physics.medium_1d import OscillatorChain1D


def test_oscillator_chain_creation():
    """Test basic OscillatorChain1D creation."""
    chain = OscillatorChain1D(n=10, k=1.0, m=1.0, gamma=0.0)
    
    assert chain.n == 10
    assert chain.k == 1.0
    assert chain.m == 1.0
    assert chain.gamma == 0.0


def test_oscillator_chain_validation():
    """Test parameter validation."""
    # n must be >= 1
    with pytest.raises(ValueError, match="Number of oscillators"):
        OscillatorChain1D(n=0, k=1.0, m=1.0)
    
    # m must be positive
    with pytest.raises(ValueError, match="Mass must be positive"):
        OscillatorChain1D(n=10, k=1.0, m=0.0)
    
    # k must be non-negative
    with pytest.raises(ValueError, match="Stiffness must be non-negative"):
        OscillatorChain1D(n=10, k=-1.0, m=1.0)
    
    # gamma must be non-negative
    with pytest.raises(ValueError, match="Damping must be non-negative"):
        OscillatorChain1D(n=10, k=1.0, m=1.0, gamma=-0.1)


def test_stiffness_matrix_shape():
    """Test stiffness matrix has correct shape."""
    chain = OscillatorChain1D(n=10, k=1.0, m=1.0)
    K = chain.stiffness_matrix()
    
    assert K.shape == (10, 10)


def test_stiffness_matrix_symmetric():
    """Test that stiffness matrix is symmetric."""
    chain = OscillatorChain1D(n=10, k=1.0, m=1.0)
    K = chain.stiffness_matrix()
    
    np.testing.assert_array_almost_equal(K, K.T)


def test_stiffness_matrix_structure():
    """Test stiffness matrix has correct tridiagonal structure."""
    chain = OscillatorChain1D(n=5, k=2.0, m=1.0)
    K = chain.stiffness_matrix()
    
    # Diagonal should be 2*k
    diagonal = np.diag(K)
    np.testing.assert_array_almost_equal(diagonal, np.full(5, 4.0))
    
    # Off-diagonal should be -k
    off_diag_upper = np.diag(K, k=1)
    np.testing.assert_array_almost_equal(off_diag_upper, np.full(4, -2.0))
    
    off_diag_lower = np.diag(K, k=-1)
    np.testing.assert_array_almost_equal(off_diag_lower, np.full(4, -2.0))


def test_eigenmodes_shape():
    """Test eigenmodes return correct shapes."""
    chain = OscillatorChain1D(n=10, k=1.0, m=1.0)
    omega, modes = chain.eigenmodes()
    
    assert omega.shape == (10,)
    assert modes.shape == (10, 10)


def test_eigenmodes_positive_frequencies():
    """Test that all eigenfrequencies are non-negative."""
    chain = OscillatorChain1D(n=10, k=1.0, m=1.0)
    omega, modes = chain.eigenmodes()
    
    assert np.all(omega >= 0)


def test_eigenmodes_count():
    """Test that number of modes equals n."""
    for n in [1, 5, 10, 20]:
        chain = OscillatorChain1D(n=n, k=1.0, m=1.0)
        omega, modes = chain.eigenmodes()
        
        assert len(omega) == n
        assert modes.shape[1] == n


def test_eigenmodes_sorted():
    """Test that eigenfrequencies are sorted."""
    chain = OscillatorChain1D(n=10, k=1.0, m=1.0)
    omega, modes = chain.eigenmodes()
    
    # eigh returns sorted eigenvalues
    assert np.all(omega[:-1] <= omega[1:])


def test_eigenmodes_orthogonal():
    """Test that eigenmodes are orthogonal."""
    chain = OscillatorChain1D(n=10, k=1.0, m=1.0)
    omega, modes = chain.eigenmodes()
    
    # Eigenvectors should be orthogonal: V^T V = I
    identity = modes.T @ modes
    np.testing.assert_array_almost_equal(identity, np.eye(10), decimal=10)


def test_different_parameters():
    """Test oscillator chain with different parameters."""
    chain1 = OscillatorChain1D(n=10, k=1.0, m=1.0)
    chain2 = OscillatorChain1D(n=10, k=2.0, m=1.0)  # Stiffer
    chain3 = OscillatorChain1D(n=10, k=1.0, m=2.0)  # Heavier
    
    omega1, _ = chain1.eigenmodes()
    omega2, _ = chain2.eigenmodes()
    omega3, _ = chain3.eigenmodes()
    
    # Stiffer chain should have higher frequencies
    assert np.all(omega2 > omega1)
    
    # Heavier chain should have lower frequencies
    assert np.all(omega3 < omega1)



================================================================================
–§–ê–ô–õ: tests\test_medium_2d.py
================================================================================

import numpy as np
import pytest
from spectral_physics.medium_2d import OscillatorGrid2D

def test_grid_2x2_stiffness():
    # 2x2 grid
    # Indices:
    # 0 1
    # 2 3
    #
    # Neighbors:
    # 0: 1(x), 2(y) + walls
    # 1: 0(x), 3(y) + walls
    # ...
    
    grid = OscillatorGrid2D(nx=2, ny=2, kx=1.0, ky=2.0, m=1.0)
    K = grid.stiffness_matrix()
    
    assert K.shape == (4, 4)
    
    # Check symmetry
    assert np.allclose(K, K.T)
    
    # Check diagonal elements
    # Each node has 2 neighbors in x (one might be wall) and 2 in y (one might be wall)
    # With fixed boundaries, every node is connected to 2 neighbors in X (k=1) and 2 in Y (k=2)
    # Total stiffness = 2*kx + 2*ky = 2*1 + 2*2 = 6
    expected_diag = 6.0
    assert np.allclose(np.diag(K), expected_diag)
    
    # Check off-diagonals
    # 0-1 (horizontal): -kx = -1
    assert K[0, 1] == -1.0
    # 0-2 (vertical): -ky = -2
    assert K[0, 2] == -2.0
    # 0-3 (diagonal): 0
    assert K[0, 3] == 0.0

def test_eigenmodes_positive():
    grid = OscillatorGrid2D(nx=3, ny=3, kx=1.0, ky=1.0, m=1.0)
    omega, modes = grid.eigenmodes()
    
    assert len(omega) == 9
    assert modes.shape == (9, 9)
    
    # Frequencies should be positive (stable system)
    assert np.all(omega >= 0)
    
    # First mode should be > 0 (no zero modes for fixed boundaries)
    assert omega[0] > 0

def test_eigenmodes_subset():
    grid = OscillatorGrid2D(nx=5, ny=5, kx=1.0, ky=1.0, m=1.0)
    n_modes = 5
    omega, modes = grid.eigenmodes(n_modes=n_modes)
    
    assert len(omega) == n_modes
    assert modes.shape == (25, n_modes)
    
    # Check sorted
    assert np.all(np.diff(omega) >= 0)



================================================================================
–§–ê–ô–õ: tests\test_ndt.py
================================================================================

import pytest
import numpy as np
from spectral_physics.medium_2d import OscillatorGrid2D
from spectral_physics.ndt import build_ndt_profile, score_ndt_state, ndt_defect_mask, NDTProfile

def test_build_ndt_profile():
    grid = OscillatorGrid2D(nx=10, ny=10, kx=1.0, ky=1.0, m=1.0)
    profile = build_ndt_profile(grid, n_modes=10, freq_window=(0.0, 2.0), n_samples=2, noise_level=0.1)
    
    assert isinstance(profile, NDTProfile)
    assert profile.ldos_mean.shape == (10, 10)
    assert profile.ldos_std.shape == (10, 10)
    assert profile.freq_window == (0.0, 2.0)

def test_score_ndt_state_no_defect():
    grid = OscillatorGrid2D(nx=10, ny=10, kx=1.0, ky=1.0, m=1.0)
    profile = build_ndt_profile(grid, n_modes=10, freq_window=(0.0, 2.0), n_samples=1, noise_level=0.0)
    
    # Same grid, should have zero score
    ldos = grid.ldos_map(n_modes=10, freq_window=(0.0, 2.0))
    scores = score_ndt_state(profile, ldos)
    
    assert np.allclose(scores, 0.0)

def test_score_ndt_state_with_defect():
    # Healthy
    grid = OscillatorGrid2D(nx=10, ny=10, kx=1.0, ky=1.0, m=1.0)
    profile = build_ndt_profile(grid, n_modes=10, freq_window=(0.0, 2.0), n_samples=1, noise_level=0.0)
    
    # Defect
    mass_map = np.ones((10, 10))
    mass_map[5, 5] = 10.0
    grid_defect = OscillatorGrid2D(nx=10, ny=10, kx=1.0, ky=1.0, m=1.0, mass_map=mass_map)
    
    ldos = grid_defect.ldos_map(n_modes=10, freq_window=(0.0, 2.0))
    scores = score_ndt_state(profile, ldos)
    
    # Center should have high score
    assert scores[5, 5] > 0.0
    
    # Mask
    mask = ndt_defect_mask(scores, threshold=0.1)
    assert mask[5, 5]



================================================================================
–§–ê–ô–õ: tests\test_report.py
================================================================================

import tempfile
import pytest
from pathlib import Path
from spectral_physics.report import generate_markdown_report

def test_generate_markdown_report_basic():
    """Test basic report generation."""
    scores = {"ch1": 0.05, "ch2": 0.25}
    thresholds = {"ch1": 0.1, "ch2": 0.2}
    
    with tempfile.NamedTemporaryFile(suffix='.md', delete=False) as f:
        temp_path = f.name
        
    try:
        generate_markdown_report(scores, thresholds, temp_path)
        
        with open(temp_path, 'r', encoding='utf-8') as f:
            content = f.read()
            
        assert "# Spectral Health Report" in content
        assert "| `ch1` | 0.050000 | 0.100000 | üü¢ OK |" in content
        assert "| `ch2` | 0.250000 | 0.200000 | üî¥ **ANOMALY** |" in content
        assert "Anomalies detected!" in content
        
    finally:
        Path(temp_path).unlink()

def test_generate_markdown_report_all_ok():
    """Test report generation when everything is OK."""
    scores = {"ch1": 0.05}
    thresholds = {"ch1": 0.1}
    
    with tempfile.NamedTemporaryFile(suffix='.md', delete=False) as f:
        temp_path = f.name
        
    try:
        generate_markdown_report(scores, thresholds, temp_path)
        
        with open(temp_path, 'r', encoding='utf-8') as f:
            content = f.read()
            
        assert "All systems nominal" in content
        assert "Anomalies detected!" not in content
        
    finally:
        Path(temp_path).unlink()



================================================================================
–§–ê–ô–õ: tests\test_root_finding.py
================================================================================

import numpy as np
import pytest
from spectral_physics.root_finding import symmetric_newton


def test_simple_quadratic():
    """Test f(x) = x^2 - 2, root should be sqrt(2)."""
    def f(x):
        return x**2 - 2
    
    x_root, n_iter = symmetric_newton(f, x0=1.0)
    
    expected = np.sqrt(2)
    assert abs(x_root - expected) < 1e-8
    assert n_iter < 50


def test_cubic_at_zero():
    """Test f(x) = x^3, root at 0 with flat minimum."""
    def f(x):
        return x**3
    
    x_root, n_iter = symmetric_newton(f, x0=0.1, tol=1e-6)
    
    assert abs(x_root) < 1e-4
    assert n_iter < 50


def test_with_kink():
    """Test function with kink: f(x) = abs(x) - 1e-3."""
    def f(x):
        return abs(x) - 1e-3
    
    # Start from positive side
    x_root, n_iter = symmetric_newton(f, x0=1.0, tol=1e-6)
    
    # Should converge to one of the roots (¬±1e-3)
    assert abs(abs(x_root) - 1e-3) < 1e-5


def test_cubic_polynomial():
    """Test f(x) = x^3 - x - 1."""
    def f(x):
        return x**3 - x - 1
    
    x_root, n_iter = symmetric_newton(f, x0=1.5)
    
    # Check that it's actually a root
    assert abs(f(x_root)) < 1e-8
    assert n_iter < 50


def test_return_type():
    """Test that function returns tuple of (float, int)."""
    def f(x):
        return x - 5
    
    result = symmetric_newton(f, x0=1.0)
    
    assert isinstance(result, tuple)
    assert len(result) == 2
    assert isinstance(result[0], float)
    assert isinstance(result[1], int)


def test_convergence_count():
    """Test that iteration count is reasonable."""
    def f(x):
        return x - 10  # Linear, should converge in 1 iteration
    
    x_root, n_iter = symmetric_newton(f, x0=0.0)
    
    assert abs(x_root - 10) < 1e-8
    assert n_iter <= 5  # Should be very fast for linear


def test_exponential_function():
    """Test f(x) = exp(x) - 2."""
    def f(x):
        return np.exp(x) - 2
    
    x_root, n_iter = symmetric_newton(f, x0=0.0)
    
    expected = np.log(2)
    assert abs(x_root - expected) < 1e-8


def test_trigonometric_function():
    """Test f(x) = sin(x)."""
    def f(x):
        return np.sin(x)
    
    x_root, n_iter = symmetric_newton(f, x0=3.0)
    
    # Should converge to pi
    assert abs(x_root - np.pi) < 1e-6


def test_max_iterations():
    """Test that max_iter limit is respected."""
    def f(x):
        return x**2 + 1  # No real root
    
    x_root, n_iter = symmetric_newton(f, x0=1.0, max_iter=10)
    
    assert n_iter == 10


def test_initial_guess_is_root():
    """Test when initial guess is already the root."""
    def f(x):
        return x - 5
    
    x_root, n_iter = symmetric_newton(f, x0=5.0)
    
    assert abs(x_root - 5.0) < 1e-8
    assert n_iter == 0  # Should converge immediately


def test_tol_step_stops_on_flat_region():
    """Test that tol_step criterion stops iteration on flat regions."""
    def f(x):
        return x**3
    
    # With very tight tol, we'd wait forever
    # But tol_step should kick in and stop earlier
    x_root, n_iter = symmetric_newton(f, x0=1.0, tol=1e-20, tol_step=1e-6)
    
    # Should stop due to small step, not small function value
    assert n_iter < 50
    # Result should still be close to zero
    assert abs(x_root) < 0.1




================================================================================
–§–ê–ô–õ: tests\test_spectrum.py
================================================================================

import numpy as np
import pytest
from spectral_physics.spectrum import Spectrum1D


def test_spectrum_creation():
    """Test basic Spectrum1D creation."""
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([0.5, 1.0, 0.5])
    
    spec = Spectrum1D(omega=omega, power=power)
    
    assert spec.omega.shape == (3,)
    assert spec.power.shape == (3,)
    np.testing.assert_array_equal(spec.omega, omega)
    np.testing.assert_array_equal(spec.power, power)


def test_spectrum_shape_mismatch():
    """Test that mismatched shapes raise ValueError."""
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([0.5, 1.0])  # Wrong size
    
    with pytest.raises(ValueError, match="Shape mismatch"):
        Spectrum1D(omega=omega, power=power)


def test_total_power():
    """Test total_power calculation."""
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([1.0, 2.0, 3.0])
    
    spec = Spectrum1D(omega=omega, power=power)
    total = spec.total_power()
    
    assert total == 6.0


def test_normalize():
    """Test spectrum normalization."""
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([1.0, 2.0, 3.0])
    
    spec = Spectrum1D(omega=omega, power=power)
    normalized = spec.normalize()
    
    # Check that sum is 1
    assert abs(normalized.total_power() - 1.0) < 1e-10
    
    # Check that relative proportions are preserved
    np.testing.assert_allclose(
        normalized.power,
        power / 6.0,
        rtol=1e-10
    )
    
    # Original should be unchanged
    assert spec.total_power() == 6.0


def test_normalize_zero_power():
    """Test that normalizing zero power raises ValueError."""
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([0.0, 0.0, 0.0])
    
    spec = Spectrum1D(omega=omega, power=power)
    
    with pytest.raises(ValueError, match="zero total power"):
        spec.normalize()


def test_apply_filter():
    """Test applying frequency-dependent filter."""
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([1.0, 2.0, 3.0])
    alpha = np.array([1.0, 0.5, 0.0])  # Pass first, attenuate second, block third
    
    spec = Spectrum1D(omega=omega, power=power)
    filtered = spec.apply_filter(alpha)
    
    expected_power = power * alpha
    np.testing.assert_array_equal(filtered.power, expected_power)
    np.testing.assert_array_equal(filtered.omega, omega)
    
    # Original should be unchanged
    np.testing.assert_array_equal(spec.power, power)


def test_apply_filter_shape_mismatch():
    """Test that mismatched filter shape raises ValueError."""
    omega = np.array([1.0, 2.0, 3.0])
    power = np.array([1.0, 2.0, 3.0])
    alpha = np.array([1.0, 0.5])  # Wrong size
    
    spec = Spectrum1D(omega=omega, power=power)
    
    with pytest.raises(ValueError, match="Shape mismatch"):
        spec.apply_filter(alpha)


def test_total_power_with_trapz():
    """Test that total_power matches np.trapz for uniform grid."""
    # Uniform frequency grid
    omega = np.linspace(0, 10, 100)
    power = np.exp(-omega)  # Exponential decay
    
    spec = Spectrum1D(omega=omega, power=power)
    
    # For sum, we just add all values
    total_sum = spec.total_power()
    
    # For trapz integration
    total_trapz = np.trapz(power, omega)
    
    # They should be different (sum vs integral)
    # but both should be reasonable
    assert total_sum > 0
    assert total_trapz > 0
    
    # The integral should be smaller than the sum for this case
    # because trapz accounts for spacing
    assert total_trapz < total_sum


def test_from_function():
    """Test creating Spectrum1D from a function."""
    omega = np.linspace(0, 1, 5)
    spec = Spectrum1D.from_function(omega, lambda w: 2*w)
    
    np.testing.assert_array_equal(spec.omega, omega)
    np.testing.assert_array_equal(spec.power, 2*omega)


def test_from_function_exponential():
    """Test from_function with exponential decay."""
    omega = np.linspace(0, 5, 50)
    spec = Spectrum1D.from_function(omega, np.exp)
    
    expected_power = np.exp(omega)
    np.testing.assert_array_almost_equal(spec.power, expected_power)


def test_from_function_shape_mismatch():
    """Test that from_function raises error for wrong return shape."""
    omega = np.linspace(0, 1, 5)
    
    def bad_func(w):
        return np.array([1.0, 2.0])  # Wrong shape
    
    with pytest.raises(ValueError, match="same shape"):
        Spectrum1D.from_function(omega, bad_func)





================================================================================
–§–ê–ô–õ: tests\test_timeseries.py
================================================================================

import numpy as np
import pytest
from spectral_physics.timeseries import timeseries_to_spectrum


def test_single_sine_wave():
    """Test that single sine wave produces peak at correct frequency."""
    # Generate 50 Hz sine wave
    freq = 50.0  # Hz
    duration = 1.0  # seconds
    dt = 0.001  # 1 ms sampling
    
    t = np.arange(0, duration, dt)
    signal = np.sin(2 * np.pi * freq * t)
    
    spectrum = timeseries_to_spectrum(signal, dt=dt)
    
    # Find peak frequency
    peak_idx = np.argmax(spectrum.power)
    peak_omega = spectrum.omega[peak_idx]
    peak_freq_hz = peak_omega / (2 * np.pi)
    
    # Should be close to 50 Hz
    assert abs(peak_freq_hz - freq) < 2.0  # Within 2 Hz


def test_two_sine_waves():
    """Test that sum of two sines produces two peaks."""
    freq1 = 50.0  # Hz
    freq2 = 120.0  # Hz
    duration = 1.0
    dt = 0.001
    
    t = np.arange(0, duration, dt)
    signal = np.sin(2 * np.pi * freq1 * t) + 0.5 * np.sin(2 * np.pi * freq2 * t)
    
    spectrum = timeseries_to_spectrum(signal, dt=dt)
    
    # Convert omega to Hz
    freq_hz = spectrum.omega / (2 * np.pi)
    
    # Find two largest peaks
    peak_indices = np.argsort(spectrum.power)[-2:]
    peak_freqs = sorted(freq_hz[peak_indices])
    
    # Should have peaks near 50 and 120 Hz
    assert abs(peak_freqs[0] - freq1) < 5.0
    assert abs(peak_freqs[1] - freq2) < 5.0


def test_constant_signal():
    """Test that constant signal has maximum only near zero frequency."""
    duration = 1.0
    dt = 0.001
    
    t = np.arange(0, duration, dt)
    signal = np.ones_like(t) * 5.0  # Constant
    
    spectrum = timeseries_to_spectrum(signal, dt=dt)
    
    # Peak should be at or very close to zero frequency
    peak_idx = np.argmax(spectrum.power)
    peak_omega = spectrum.omega[peak_idx]
    
    assert peak_omega < 10.0  # Very low frequency


def test_window_none():
    """Test that window=None works."""
    freq = 50.0
    duration = 1.0
    dt = 0.001
    
    t = np.arange(0, duration, dt)
    signal = np.sin(2 * np.pi * freq * t)
    
    spectrum = timeseries_to_spectrum(signal, dt=dt, window=None)
    
    # Should still produce spectrum
    assert len(spectrum.omega) > 0
    assert len(spectrum.power) > 0


def test_window_hann():
    """Test that window='hann' works."""
    freq = 50.0
    duration = 1.0
    dt = 0.001
    
    t = np.arange(0, duration, dt)
    signal = np.sin(2 * np.pi * freq * t)
    
    spectrum = timeseries_to_spectrum(signal, dt=dt, window="hann")
    
    # Should still produce spectrum
    assert len(spectrum.omega) > 0
    assert len(spectrum.power) > 0


def test_invalid_window():
    """Test that invalid window raises ValueError."""
    signal = np.array([1.0, 2.0, 3.0])
    dt = 0.1
    
    with pytest.raises(ValueError, match="Unknown window type"):
        timeseries_to_spectrum(signal, dt=dt, window="invalid")


def test_empty_signal():
    """Test that empty signal raises ValueError."""
    signal = np.array([])
    dt = 0.1
    
    with pytest.raises(ValueError, match="must not be empty"):
        timeseries_to_spectrum(signal, dt=dt)


def test_multidimensional_signal():
    """Test that 2D signal raises ValueError."""
    signal = np.array([[1.0, 2.0], [3.0, 4.0]])
    dt = 0.1
    
    with pytest.raises(ValueError, match="must be 1D array"):
        timeseries_to_spectrum(signal, dt=dt)


def test_dc_removal():
    """Test that DC component is removed."""
    duration = 1.0
    dt = 0.001
    
    t = np.arange(0, duration, dt)
    signal = 10.0 + np.sin(2 * np.pi * 50 * t)  # DC offset + sine
    
    spectrum = timeseries_to_spectrum(signal, dt=dt)
    
    # DC component (first element) should be small after DC removal
    # Note: won't be exactly zero due to window, but should be reduced
    assert spectrum.power[0] < np.max(spectrum.power)


def test_positive_frequencies_only():
    """Test that only positive frequencies are returned."""
    signal = np.random.randn(100)
    dt = 0.01
    
    spectrum = timeseries_to_spectrum(signal, dt=dt)
    
    # All frequencies should be >= 0
    assert np.all(spectrum.omega >= 0)


